

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>cc — Coupled cluster &mdash; PySCF 1.4.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="PySCF 1.4.0 documentation" href="index.html"/>
        <link rel="next" title="ci — Configuration interaction" href="ci.html"/>
        <link rel="prev" title="tddft — Time dependent density functional theory" href="tddft.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> PySCF
          

          
          </a>

          
            
            
              <div class="version">
                1.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">An overview of PySCF</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="gto.html">gto &#8212; Molecular structure and GTO basis</a></li>
<li class="toctree-l1"><a class="reference internal" href="lib.html">lib &#8212; Helper functions, parameters, and C extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="scf.html">scf &#8212; Mean-field methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="ao2mo.html">ao2mo &#8212; Integral transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="mcscf.html">mcscf &#8212; Multi-configurational self-consistent field</a></li>
<li class="toctree-l1"><a class="reference internal" href="fci.html">fci &#8212; Full configuration interaction</a></li>
<li class="toctree-l1"><a class="reference internal" href="symm.html">symm &#8211; Point group symmetry and spin symmetry</a></li>
<li class="toctree-l1"><a class="reference internal" href="df.html">df &#8212; Density fitting</a></li>
<li class="toctree-l1"><a class="reference internal" href="dft.html">dft &#8212; Density functional theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="tddft.html">tddft &#8212; Time dependent density functional theory</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">cc &#8212; Coupled cluster</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#examples">Examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#a-general-solver-for-customized-hamiltonian">A general solver for customized Hamiltonian</a></li>
<li class="toctree-l3"><a class="reference internal" href="#using-ccsd-as-casci-active-space-solver">Using CCSD as CASCI active space solver</a></li>
<li class="toctree-l3"><a class="reference internal" href="#gamma-point-ccsd-with-periodic-boundary-condition">Gamma point CCSD with Periodic boundary condition</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ccsd-with-truncated-mos-to-avoid-linear-dependency">CCSD with truncated MOs to avoid linear dependency</a></li>
<li class="toctree-l3"><a class="reference internal" href="#response-and-un-relaxed-ccsd-density-matrix">Response and un-relaxed CCSD density matrix</a></li>
<li class="toctree-l3"><a class="reference internal" href="#reusing-integrals-in-ccsd-and-relevant-calculations">Reusing integrals in CCSD and relevant calculations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#interfering-ccsd-diis">Interfering CCSD-DIIS</a></li>
<li class="toctree-l3"><a class="reference internal" href="#restart-ccsd">Restart CCSD</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#program-reference">Program reference</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#cc-ccsd-module-and-ccsd-class">cc.ccsd module and CCSD class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cc-rccsd-and-rccsd-class">cc.rccsd and RCCSD class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cc-uccsd-and-uccsd-class">cc.uccsd and UCCSD class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cc-addons">cc.addons</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ccsd-t">CCSD(T)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pyscf.cc.ccsd_grad">CCSD gradients</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ci.html">ci &#8212; Configuration interaction</a></li>
<li class="toctree-l1"><a class="reference internal" href="dmrgscf.html">dmrgscf</a></li>
<li class="toctree-l1"><a class="reference internal" href="fciqmcscf.html">fciqmcscf</a></li>
<li class="toctree-l1"><a class="reference internal" href="tools.html">tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="grad.html">grad &#8212; Analytical nuclear gradients</a></li>
<li class="toctree-l1"><a class="reference internal" href="hessian.html">hessian &#8212; Analytical nuclear Hessian</a></li>
<li class="toctree-l1"><a class="reference internal" href="pbc.html">pbc &#8212; Periodic boundary conditions</a></li>
<li class="toctree-l1"><a class="reference internal" href="lo.html">lo &#8212; Orbital localization</a></li>
<li class="toctree-l1"><a class="reference internal" href="advanced.html">Miscellaneous</a></li>
<li class="toctree-l1"><a class="reference internal" href="qmmm.html">qmmm &#8212; QM/MM interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="mrpt.html">mrpt &#8212; Multi-reference perturbation theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="benchmark.html">Benchmark</a></li>
<li class="toctree-l1"><a class="reference internal" href="code-rule.html">Code standard</a></li>
<li class="toctree-l1"><a class="reference internal" href="version.html">Version history</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">PySCF</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>cc &#8212; Coupled cluster</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/cc.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-cc">
<span id="cc-coupled-cluster"></span><span id="cc"></span><h1>cc &#8212; Coupled cluster<a class="headerlink" href="#module-cc" title="Permalink to this headline">¶</a></h1>
<p>The <a class="reference internal" href="#module-cc" title="cc: Computing coupled cluster energies and properties"><code class="xref py py-mod docutils literal"><span class="pre">cc</span></code></a> module implements the coupled cluster (CC) model to compute
energies, analytical nuclear gradients, density matrices, excited states, and
relevant properties.</p>
<p>To compute the CC energy, one first needs to perform a mean-field calculation using
the mean-field module <a class="reference internal" href="scf.html#module-scf" title="scf: restricted and unrestricted, closed shell and open shell Hartree-Fock methods"><code class="xref py py-mod docutils literal"><span class="pre">scf</span></code></a>.  The mean-field object defines the Hamiltonian
and the problem size, which are used to initialize the CC object:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">cc</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span>
<span class="n">mycc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>
<p>Unrelaxed density matrices are evaluated in the MO basis:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">dm1</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">make_rdm1</span><span class="p">()</span>
<span class="n">dm2</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">make_rdm2</span><span class="p">()</span>
</pre></div>
</div>
<p>The CCSD(T) energy can be obtained by:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyscf.cc</span> <span class="k">import</span> <span class="n">ccsd_t</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ccsd_t</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">mycc</span><span class="p">,</span> <span class="n">mycc</span><span class="o">.</span><span class="n">ao2mo</span><span class="p">())[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>Gradients are available:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyscf.cc</span> <span class="k">import</span> <span class="n">ccsd_grad</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">grad</span>
<span class="n">grad_e</span> <span class="o">=</span> <span class="n">ccsd_grad</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">mycc</span><span class="p">)</span>
<span class="n">grad_n</span> <span class="o">=</span> <span class="n">grad</span><span class="o">.</span><span class="n">grad_nuc</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="n">grad</span> <span class="o">=</span> <span class="n">grad_e</span> <span class="o">+</span> <span class="n">grad_nuc</span>
</pre></div>
</div>
<p>Excited states can be calculated with ionization potential (IP), electron affinity (EA),
and electronic excitation (EE) equation-of-motion (EOM) CCSD:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">RCCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span>
<span class="n">mycc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="n">e_ip</span><span class="p">,</span> <span class="n">c_ip</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">ipccsd</span><span class="p">(</span><span class="n">nroots</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">e_ea</span><span class="p">,</span> <span class="n">c_ea</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">eaccsd</span><span class="p">(</span><span class="n">nroots</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">e_ee</span><span class="p">,</span> <span class="n">c_ee</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">eeccsd</span><span class="p">(</span><span class="n">nroots</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">UCCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span>
<span class="n">mycc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="n">e_ip</span><span class="p">,</span> <span class="n">c_ip</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">ipccsd</span><span class="p">(</span><span class="n">nroots</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">e_ea</span><span class="p">,</span> <span class="n">c_ea</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">eaccsd</span><span class="p">(</span><span class="n">nroots</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">e_ee</span><span class="p">,</span> <span class="n">c_ee</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">eeccsd</span><span class="p">(</span><span class="n">nroots</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>All CC methods have two implementations.  One is simple and highly readable (suffixed
by <code class="docutils literal"><span class="pre">_slow</span></code> in the filename) and the other is extensively optimized for
computational efficiency.
All code in the <code class="docutils literal"><span class="pre">_slow</span></code> versions is structured as close as
possible to the formulas documented in the literature.  Pure Python/numpy
data structures and functions are used so that explicit memory management is avoided.
It is easy to make modifications or develop new methods based on the slow
implementations.</p>
<p>The computationally efficient (outcore) version is the default implementation
for the CC module.  In this implementation, the CPU usage, memory footprint,
memory efficiency, and IO overhead are carefully considered.  To keep a small
memory footprint, most integral tensors are stored on disk.  IO is one of the
main bottlenecks in this implementation.  Two techniques are used to reduce
the IO overhead.  One is the asynchronized IO to overlap the computation and
reading/writing of the 4-index tensors.  The other is AO-driven for the
contraction of T2 and <code class="docutils literal"><span class="pre">(vv|vv)</span></code> integrals in CCSD and CCSD-lambda functions.
These techniques allow the CC module to efficiently handle medium-sized
systems.  In a test system with 25 occupied orbitals and 1500 virtual orbitals, each
CCSD iteration takes about 2.5 hours.  The program does not automatically
switch to AO-driven CCSD for large systems.  The user must manually set the
<code class="xref py py-attr docutils literal"><span class="pre">direct</span></code> attribute to enable an AO-driven CCSD calculation:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span>
<span class="n">mycc</span><span class="o">.</span><span class="n">direct</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">mycc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>
<p>Some of the CC methods have an efficient incore implementation, where
all tensors are held in memory.  The incore implementation reduces the IO overhead
and optimizes certain formulas to gain the best FLOPS.  It is about 30% faster
than the outcore implementation.  Depending on the available memory, the incore
code can be used for systems with up to approximately 250 orbitals.</p>
<p>Point group symmetry is not considered in the CCSD programs, but it is used in
the CCSD(T) code to gain the best performance.</p>
<p>Arbitrary frozen orbitals (not limited to frozen core) are supported
by the CCSD, CCSD(T), density matrices, and EOM-CCSD modules, but not in
the analytical CCSD gradient module.</p>
<div class="section" id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<p>This section documents some examples about how to effectively use the CCSD
module, and how to incorporate the CCSD solver with other PySCF functions to
perform advanced simulations.  For a complete list of CC examples, see
<code class="docutils literal"><span class="pre">pyscf/examples/cc</span></code>.</p>
<div class="section" id="a-general-solver-for-customized-hamiltonian">
<h3>A general solver for customized Hamiltonian<a class="headerlink" href="#a-general-solver-for-customized-hamiltonian" title="Permalink to this headline">¶</a></h3>
<p>The CC module is not limited to molecular systems.  The program is implemented as
a general solver for arbitrary Hamiltonians.  It allows users to overwrite the
default molecular Hamiltonian with their own effective Hamiltonians.  In this
example, we create a Hubbard model and feed its Hamiltonian to the CCSD module.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Six-site 1D U/t=2 Hubbard-like model system with PBC at half filling.</span>
<span class="sd">The model is gapped at the mean-field level</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">ao2mo</span><span class="p">,</span> <span class="n">cc</span>

<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">mol</span><span class="o">.</span><span class="n">nelectron</span> <span class="o">=</span> <span class="n">n</span>
<span class="c1"># Setting incore_anyway=True to ensure the customized Hamiltonian (the _eri</span>
<span class="c1"># attribute) being used in post-HF calculations.  Without this parameter, some</span>
<span class="c1"># post-HF method may ignore the customized Hamiltonian if memory is not</span>
<span class="c1"># enough.</span>
<span class="n">mol</span><span class="o">.</span><span class="n">incore_anyway</span> <span class="o">=</span> <span class="kc">True</span>

<span class="n">h1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">h1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">h1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
<span class="n">h1</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">h1</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
<span class="n">eri</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">eri</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0</span>

<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="n">mf</span><span class="o">.</span><span class="n">get_hcore</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">h1</span>
<span class="n">mf</span><span class="o">.</span><span class="n">get_ovlp</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="n">mf</span><span class="o">.</span><span class="n">_eri</span> <span class="o">=</span> <span class="n">ao2mo</span><span class="o">.</span><span class="n">restore</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">eri</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>


<span class="c1"># In PySCF, the customized Hamiltonian needs to be created once in mf object.</span>
<span class="c1"># The Hamiltonian will be used everywhere whenever possible.  Here, the model</span>
<span class="c1"># Hamiltonian is passed to CCSD object via the mf object.</span>

<span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">RCCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span>
<span class="n">mycc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="n">e</span><span class="p">,</span><span class="n">v</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">ipccsd</span><span class="p">(</span><span class="n">nroots</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="using-ccsd-as-casci-active-space-solver">
<h3>Using CCSD as CASCI active space solver<a class="headerlink" href="#using-ccsd-as-casci-active-space-solver" title="Permalink to this headline">¶</a></h3>
<p>CCSD program can be wrapped as a Full CI solver, which can be combined with the
CASCI solver to approximate the multi-configuration calculation.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Using the CCSD method as the active space solver to compute an approximate</span>
<span class="sd">CASCI energy.</span>

<span class="sd">A wrapper is required to adapt the CCSD solver to CASCI fcisolver interface.</span>
<span class="sd">Inside the wrapper function, the CCSD code is the same as the example</span>
<span class="sd">40-ccsd_with_given_hamiltonian.py</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">cc</span><span class="p">,</span> <span class="n">ao2mo</span><span class="p">,</span> <span class="n">mcscf</span>

<span class="k">class</span> <span class="nc">AsFCISolver</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mycc</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">kernel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h1</span><span class="p">,</span> <span class="n">h2</span><span class="p">,</span> <span class="n">norb</span><span class="p">,</span> <span class="n">nelec</span><span class="p">,</span> <span class="n">ci0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ecore</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">fakemol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">nelec</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">nelec</span><span class="p">)</span>
        <span class="n">fakemol</span><span class="o">.</span><span class="n">nelectron</span> <span class="o">=</span> <span class="n">nelec</span>
        <span class="n">fake_hf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">fakemol</span><span class="p">)</span>
        <span class="n">fake_hf</span><span class="o">.</span><span class="n">_eri</span> <span class="o">=</span> <span class="n">ao2mo</span><span class="o">.</span><span class="n">restore</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">h2</span><span class="p">,</span> <span class="n">norb</span><span class="p">)</span>
        <span class="n">fake_hf</span><span class="o">.</span><span class="n">get_hcore</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">h1</span>
        <span class="n">fake_hf</span><span class="o">.</span><span class="n">get_ovlp</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">norb</span><span class="p">)</span>
        <span class="n">fake_hf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">fake_hf</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eris</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mycc</span><span class="o">.</span><span class="n">ao2mo</span><span class="p">()</span>
        <span class="n">e_corr</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mycc</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">eris</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">eris</span><span class="p">)</span>
        <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mycc</span><span class="o">.</span><span class="n">solve_lambda</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">eris</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">eris</span><span class="p">)</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">fake_hf</span><span class="o">.</span><span class="n">e_tot</span> <span class="o">+</span> <span class="n">e_corr</span>
        <span class="k">return</span> <span class="n">e</span><span class="o">+</span><span class="n">ecore</span><span class="p">,</span> <span class="p">[</span><span class="n">t1</span><span class="p">,</span><span class="n">t2</span><span class="p">,</span><span class="n">l1</span><span class="p">,</span><span class="n">l2</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">make_rdm1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fake_ci</span><span class="p">,</span> <span class="n">norb</span><span class="p">,</span> <span class="n">nelec</span><span class="p">):</span>
        <span class="n">mo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mycc</span><span class="o">.</span><span class="n">mo_coeff</span>
        <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span> <span class="o">=</span> <span class="n">fake_ci</span>
        <span class="n">dm1</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">,</span> <span class="p">(</span><span class="n">mo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mycc</span><span class="o">.</span><span class="n">make_rdm1</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">),</span> <span class="n">mo</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">dm1</span>

    <span class="k">def</span> <span class="nf">make_rdm12</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fake_ci</span><span class="p">,</span> <span class="n">norb</span><span class="p">,</span> <span class="n">nelec</span><span class="p">):</span>
        <span class="n">mo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mycc</span><span class="o">.</span><span class="n">mo_coeff</span>
        <span class="n">nmo</span> <span class="o">=</span> <span class="n">mo</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span> <span class="o">=</span> <span class="n">fake_ci</span>
        <span class="n">dm2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mycc</span><span class="o">.</span><span class="n">make_rdm2</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">)</span>
        <span class="n">dm2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mo</span><span class="p">,</span> <span class="n">dm2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nmo</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">dm2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dm2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">nmo</span><span class="p">),</span> <span class="n">mo</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">dm2</span> <span class="o">=</span> <span class="n">dm2</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">nmo</span><span class="p">]</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">dm2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mo</span><span class="p">,</span> <span class="n">dm2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nmo</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">dm2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dm2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">nmo</span><span class="p">),</span> <span class="n">mo</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">dm2</span> <span class="o">=</span> <span class="n">dm2</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">nmo</span><span class="p">]</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_rdm1</span><span class="p">(</span><span class="n">fake_ci</span><span class="p">,</span> <span class="n">norb</span><span class="p">,</span> <span class="n">nelec</span><span class="p">),</span> <span class="n">dm2</span>

    <span class="k">def</span> <span class="nf">spin_square</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fake_ci</span><span class="p">,</span> <span class="n">norb</span><span class="p">,</span> <span class="n">nelec</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>

<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span> <span class="o">=</span> <span class="s1">&#39;H 0 0 0; F 0 0 1.2&#39;</span><span class="p">,</span>
            <span class="n">basis</span> <span class="o">=</span> <span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">norb</span> <span class="o">=</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">nelec</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">nelectron</span>
<span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASCI</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="n">norb</span><span class="p">,</span> <span class="n">nelec</span><span class="p">)</span>
<span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span> <span class="o">=</span> <span class="n">AsFCISolver</span><span class="p">()</span>
<span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>

</pre></div>
</div>
</div>
<div class="section" id="gamma-point-ccsd-with-periodic-boundary-condition">
<h3>Gamma point CCSD with Periodic boundary condition<a class="headerlink" href="#gamma-point-ccsd-with-periodic-boundary-condition" title="Permalink to this headline">¶</a></h3>
<p>Integrals in Gamma point of periodic Hartree-Fock calculation are all real.
You can feed the integrals into any pyscf molecular module using the same
operations as the above example.  However, the interface between PBC code and
molecular code are more compatible.  You can treat the crystal object and the
molecule object in the same manner.  In this example, you can pass the PBC mean
field method to CC module to have the gamma point CCSD correlation.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Gamma point post-HF calculation needs only real integrals.</span>
<span class="sd">Methods implemented in finite-size system can be directly used here without</span>
<span class="sd">any modification.</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">pyscf.pbc</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>

<span class="n">cell</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mf">3.5668</span><span class="p">,</span>
    <span class="n">atom</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;C     0.      0.      0.    </span>
<span class="s1">              C     0.8917  0.8917  0.8917</span>
<span class="s1">              C     1.7834  1.7834  0.    </span>
<span class="s1">              C     2.6751  2.6751  0.8917</span>
<span class="s1">              C     1.7834  0.      1.7834</span>
<span class="s1">              C     2.6751  0.8917  2.6751</span>
<span class="s1">              C     0.      1.7834  1.7834</span>
<span class="s1">              C     0.8917  2.6751  2.6751&#39;&#39;&#39;</span><span class="p">,</span>
    <span class="n">basis</span> <span class="o">=</span> <span class="s1">&#39;6-31g&#39;</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span><span class="o">.</span><span class="n">density_fit</span><span class="p">()</span>
<span class="n">mf</span><span class="o">.</span><span class="n">with_df</span><span class="o">.</span><span class="n">gs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>

<span class="c1">#</span>
<span class="c1"># Import CC, TDDFT moduel from the molecular implementations</span>
<span class="c1">#</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">cc</span><span class="p">,</span> <span class="n">tddft</span>
<span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span>
<span class="n">mycc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>

<span class="n">mytd</span> <span class="o">=</span> <span class="n">tddft</span><span class="o">.</span><span class="n">TDHF</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span>
<span class="n">mytd</span><span class="o">.</span><span class="n">nstates</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">mytd</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="ccsd-with-truncated-mos-to-avoid-linear-dependency">
<h3>CCSD with truncated MOs to avoid linear dependency<a class="headerlink" href="#ccsd-with-truncated-mos-to-avoid-linear-dependency" title="Permalink to this headline">¶</a></h3>
<p>It is common to have linear dependence when one wants to systematically enlarge
the AO basis set to approach complete basis set limit.  The numerical
instability usually has noticeable effects on the CCSD convergence.  An
effective way to remove this negative effects is to truncate the AO sets and
allow the MO orbitals being less than AO functions.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">:func:`scf.addons.remove_linear_dep_` discards the small eigenvalues of overlap</span>
<span class="sd">matrix.  This reduces the number of MOs from 50 to 49.  The problem size of</span>
<span class="sd">the following CCSD method is 49.</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">cc</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">Mole</span><span class="p">()</span>
<span class="n">mol</span><span class="o">.</span><span class="n">atom</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">.</span><span class="mi">5</span><span class="o">*</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">)]</span>
<span class="n">mol</span><span class="o">.</span><span class="n">basis</span> <span class="o">=</span> <span class="s1">&#39;ccpvdz&#39;</span>
<span class="n">mol</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">addons</span><span class="o">.</span><span class="n">remove_linear_dep_</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

</pre></div>
</div>
</div>
<div class="section" id="response-and-un-relaxed-ccsd-density-matrix">
<h3>Response and un-relaxed CCSD density matrix<a class="headerlink" href="#response-and-un-relaxed-ccsd-density-matrix" title="Permalink to this headline">¶</a></h3>
<p>CCSD has two kinds of one-particle density matrices.  The (second order)
un-relaxed density matrix and the (relaxed) response density matrix.  The
<code class="xref py py-func docutils literal"><span class="pre">CCSD.make_rdm1()</span></code> function computes the un-relaxed density matrix which is
associated to the regular CCSD energy formula.  The response density is mainly
used to compute the first order response quantities eg the analytical nuclear
gradients.  It is not recommended to use the response density matrix for
population analysis.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1">#</span>
<span class="c1"># Author: Qiming Sun &lt;osirpt.sun@gmail.com&gt;</span>
<span class="c1">#</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">CCSD density matrix</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">cc</span>

<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span>
    <span class="n">atom</span> <span class="o">=</span> <span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">,</span>
    <span class="n">basis</span> <span class="o">=</span> <span class="s1">&#39;ccpvdz&#39;</span><span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

<span class="c1">#</span>
<span class="c1"># CCSD density matrix in MO basis</span>
<span class="c1">#</span>
<span class="n">dm1</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">make_rdm1</span><span class="p">()</span>
<span class="n">dm2</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">make_rdm2</span><span class="p">()</span>

<span class="c1">#</span>
<span class="c1"># Relaxed CCSD density matrix in MO basis</span>
<span class="c1">#</span>
<span class="kn">from</span> <span class="nn">pyscf.cc</span> <span class="k">import</span> <span class="n">ccsd_grad</span>
<span class="n">dm1</span> <span class="o">+=</span> <span class="n">ccsd_grad</span><span class="o">.</span><span class="n">response_dm1</span><span class="p">(</span><span class="n">mycc</span><span class="p">,</span> <span class="n">mycc</span><span class="o">.</span><span class="n">t1</span><span class="p">,</span> <span class="n">mycc</span><span class="o">.</span><span class="n">t2</span><span class="p">,</span> <span class="n">mycc</span><span class="o">.</span><span class="n">l1</span><span class="p">,</span> <span class="n">mycc</span><span class="o">.</span><span class="n">l2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="reusing-integrals-in-ccsd-and-relevant-calculations">
<h3>Reusing integrals in CCSD and relevant calculations<a class="headerlink" href="#reusing-integrals-in-ccsd-and-relevant-calculations" title="Permalink to this headline">¶</a></h3>
<p>By default the CCSD solver and the relevant CCSD lambda solver, CCSD(T), CCSD
gradients program generate MO integrals in their own runtime.  But in most
scenario, the same MO integrals can be generated once and reused in the four
modules.  To remove the overhead of recomputing MO integrals, the three module
support user to feed MO integrals.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1">#</span>
<span class="c1"># Author: Qiming Sun &lt;osirpt.sun@gmail.com&gt;</span>
<span class="c1">#</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">To avoid recomputing AO to MO integral transformation, integrals for CCSD,</span>
<span class="sd">CCSD(T), CCSD lambda equation etc can be reused.</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">cc</span>

<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">atom</span> <span class="o">=</span> <span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">,</span>
    <span class="n">basis</span> <span class="o">=</span> <span class="s1">&#39;ccpvdz&#39;</span><span class="p">)</span>

<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span>

<span class="c1">#</span>
<span class="c1"># CCSD module allows you feed MO integrals</span>
<span class="c1">#</span>
<span class="n">eris</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">ao2mo</span><span class="p">()</span>
<span class="n">mycc</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">eris</span><span class="o">=</span><span class="n">eris</span><span class="p">)</span>

<span class="c1">#</span>
<span class="c1"># The same MO integrals can be used in CCSD lambda equation</span>
<span class="c1">#</span>
<span class="n">mycc</span><span class="o">.</span><span class="n">solve_lambda</span><span class="p">(</span><span class="n">eris</span><span class="o">=</span><span class="n">eris</span><span class="p">)</span>

<span class="c1">#</span>
<span class="c1"># CCSD(T) module requires the same integrals used by CCSD module</span>
<span class="c1">#</span>
<span class="kn">from</span> <span class="nn">pyscf.cc</span> <span class="k">import</span> <span class="n">ccsd_t</span>
<span class="n">ccsd_t</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">mycc</span><span class="p">,</span> <span class="n">eris</span><span class="o">=</span><span class="n">eris</span><span class="p">)</span>

<span class="c1">#</span>
<span class="c1"># CCSD gradients need regular MO integrals to solve the relaxed 1-particle</span>
<span class="c1"># density matrix</span>
<span class="c1">#</span>
<span class="kn">from</span> <span class="nn">pyscf.cc</span> <span class="k">import</span> <span class="n">ccsd_grad</span>
<span class="n">grad_e</span> <span class="o">=</span> <span class="n">ccsd_grad</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">mycc</span><span class="p">,</span> <span class="n">eris</span><span class="o">=</span><span class="n">eris</span><span class="p">)</span>  <span class="c1"># The electronic part only</span>

</pre></div>
</div>
</div>
<div class="section" id="interfering-ccsd-diis">
<h3>Interfering CCSD-DIIS<a class="headerlink" href="#interfering-ccsd-diis" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="restart-ccsd">
<h3>Restart CCSD<a class="headerlink" href="#restart-ccsd" title="Permalink to this headline">¶</a></h3>
</div>
</div>
<div class="section" id="program-reference">
<h2>Program reference<a class="headerlink" href="#program-reference" title="Permalink to this headline">¶</a></h2>
<div class="section" id="cc-ccsd-module-and-ccsd-class">
<h3>cc.ccsd module and CCSD class<a class="headerlink" href="#cc-ccsd-module-and-ccsd-class" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="#pyscf.cc.ccsd.CCSD" title="pyscf.cc.ccsd.CCSD"><code class="xref py py-class docutils literal"><span class="pre">pyscf.cc.ccsd.CCSD</span></code></a> class is the object to hold the restricted CCSD environment
attributes and results.  The environment attributes are the parameters to
control the runtime behavior of the CCSD module, e.g. the convergence criteria, DIIS
parameters, and so on.  After the ground state CCSD calculation, correlation
energy, <code class="docutils literal"><span class="pre">T1</span></code> and <code class="docutils literal"><span class="pre">T2</span></code> amplitudes are stored in the CCSD object.
This class supports the calculation of CCSD 1- and 2-particle density matrices.</p>
<dl class="class">
<dt id="pyscf.cc.ccsd.CCSD">
<em class="property">class </em><code class="descclassname">pyscf.cc.ccsd.</code><code class="descname">CCSD</code><span class="sig-paren">(</span><em>mf</em>, <em>frozen=0</em>, <em>mo_coeff=None</em>, <em>mo_occ=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/cc/ccsd.html#CCSD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.ccsd.CCSD" title="Permalink to this definition">¶</a></dt>
<dd><p>restricted CCSD</p>
<dl class="docutils">
<dt>Attributes:</dt>
<dd><dl class="first last docutils">
<dt>verbose</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Print level.  Default value equals to <code class="xref py py-class docutils literal"><span class="pre">Mole.verbose</span></code></dd>
<dt>max_memory</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float or int</span><dd>Allowed memory in MB.  Default value equals to <code class="xref py py-class docutils literal"><span class="pre">Mole.max_memory</span></code></dd>
<dt>conv_tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>converge threshold.  Default is 1e-7.</dd>
<dt>conv_tol_normt</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>converge threshold for norm(t1,t2).  Default is 1e-5.</dd>
<dt>max_cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>max number of iterations.  Default is 50.</dd>
<dt>diis_space</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>DIIS space size.  Default is 6.</dd>
<dt>diis_start_cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>The step to start DIIS.  Default is 0.</dd>
<dt>direct</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>AO-direct CCSD. Default is False.</dd>
<dt>frozen</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int or list</span><dd><p class="first">If integer is given, the inner-most orbitals are frozen from CC
amplitudes.  Given the orbital indices (0-based) in a list, both
occupied and virtual orbitals can be frozen in CC calculation.</p>
<div class="last highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span> <span class="o">=</span> <span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span> <span class="o">=</span> <span class="s1">&#39;ccpvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># freeze 2 core orbitals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">frozen</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># freeze 2 core orbitals and 3 high lying unoccupied orbitals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mycc</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">frozen</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">18</span><span class="p">])</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
</dd>
</dl>
</dd>
</dl>
<p>Saved results</p>
<blockquote>
<div><dl class="docutils">
<dt>converged</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>CCSD converged or not</dd>
<dt>e_corr</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>CCSD correlation correction</dd>
<dt>e_tot</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Total CCSD energy (HF + correlation)</dd>
<dt>t1, t2</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier"></span><dd>T amplitudes t1[i,a], t2[i,j,a,b]  (i,j in occ, a,b in virt)</dd>
<dt>l1, l2</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier"></span><dd>Lambda amplitudes l1[i,a], l2[i,j,a,b]  (i,j in occ, a,b in virt)</dd>
</dl>
</div></blockquote>
</dd></dl>

<span class="target" id="module-pyscf.cc.ccsd"></span><dl class="attribute">
<dt id="pyscf.cc.ccsd.CC">
<code class="descclassname">pyscf.cc.ccsd.</code><code class="descname">CC</code><a class="headerlink" href="#pyscf.cc.ccsd.CC" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pyscf.cc.ccsd.CCSD" title="pyscf.cc.ccsd.CCSD"><code class="xref py py-class docutils literal"><span class="pre">CCSD</span></code></a></p>
</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><code class="descclassname">pyscf.cc.ccsd.</code><code class="descname">CCSD</code><span class="sig-paren">(</span><em>mf</em>, <em>frozen=0</em>, <em>mo_coeff=None</em>, <em>mo_occ=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/cc/ccsd.html#CCSD"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>restricted CCSD</p>
<dl class="docutils">
<dt>Attributes:</dt>
<dd><dl class="first last docutils">
<dt>verbose</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Print level.  Default value equals to <code class="xref py py-class docutils literal"><span class="pre">Mole.verbose</span></code></dd>
<dt>max_memory</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float or int</span><dd>Allowed memory in MB.  Default value equals to <code class="xref py py-class docutils literal"><span class="pre">Mole.max_memory</span></code></dd>
<dt>conv_tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>converge threshold.  Default is 1e-7.</dd>
<dt>conv_tol_normt</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>converge threshold for norm(t1,t2).  Default is 1e-5.</dd>
<dt>max_cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>max number of iterations.  Default is 50.</dd>
<dt>diis_space</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>DIIS space size.  Default is 6.</dd>
<dt>diis_start_cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>The step to start DIIS.  Default is 0.</dd>
<dt>direct</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>AO-direct CCSD. Default is False.</dd>
<dt>frozen</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int or list</span><dd><p class="first">If integer is given, the inner-most orbitals are frozen from CC
amplitudes.  Given the orbital indices (0-based) in a list, both
occupied and virtual orbitals can be frozen in CC calculation.</p>
<div class="last highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span> <span class="o">=</span> <span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span> <span class="o">=</span> <span class="s1">&#39;ccpvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># freeze 2 core orbitals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">frozen</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># freeze 2 core orbitals and 3 high lying unoccupied orbitals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mycc</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">frozen</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">18</span><span class="p">])</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
</dd>
</dl>
</dd>
</dl>
<p>Saved results</p>
<blockquote>
<div><dl class="docutils">
<dt>converged</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>CCSD converged or not</dd>
<dt>e_corr</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>CCSD correlation correction</dd>
<dt>e_tot</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Total CCSD energy (HF + correlation)</dd>
<dt>t1, t2</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier"></span><dd>T amplitudes t1[i,a], t2[i,j,a,b]  (i,j in occ, a,b in virt)</dd>
<dt>l1, l2</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier"></span><dd>Lambda amplitudes l1[i,a], l2[i,j,a,b]  (i,j in occ, a,b in virt)</dd>
</dl>
</div></blockquote>
<dl class="method">
<dt id="pyscf.cc.ccsd.CCSD.as_scanner">
<code class="descname">as_scanner</code><span class="sig-paren">(</span><em>cc</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.cc.ccsd.CCSD.as_scanner" title="Permalink to this definition">¶</a></dt>
<dd><p>Generating a scanner/solver for CCSD PES.</p>
<p>The returned solver is a function. This function requires one argument
&#8220;mol&#8221; as input and returns total CCSD energy.</p>
<p>The solver will automatically use the results of last calculation as the
initial guess of the new calculation.  All parameters assigned in the
CCSD and the underlying SCF objects (conv_tol, max_memory etc) are
automatically applied in the solver.</p>
<p>Note scanner has side effects.  It may change many underlying objects
(_scf, with_df, with_x2c, ...) during calculation.</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">cc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cc_scanner</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">))</span><span class="o">.</span><span class="n">as_scanner</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e_tot</span><span class="p">,</span> <span class="n">grad</span> <span class="o">=</span> <span class="n">cc_scanner</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e_tot</span><span class="p">,</span> <span class="n">grad</span> <span class="o">=</span> <span class="n">cc_scanner</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.5&#39;</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.cc.ccsd.CCSD.energy">
<code class="descname">energy</code><span class="sig-paren">(</span><em>mycc</em>, <em>t1</em>, <em>t2</em>, <em>eris</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.cc.ccsd.CCSD.energy" title="Permalink to this definition">¶</a></dt>
<dd><p>CCSD correlation energy</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.cc.ccsd.CCSD.make_rdm1">
<code class="descname">make_rdm1</code><span class="sig-paren">(</span><em>t1=None</em>, <em>t2=None</em>, <em>l1=None</em>, <em>l2=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/cc/ccsd.html#CCSD.make_rdm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.ccsd.CCSD.make_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Un-relaxed 1-particle density matrix in MO space</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.cc.ccsd.CCSD.make_rdm2">
<code class="descname">make_rdm2</code><span class="sig-paren">(</span><em>t1=None</em>, <em>t2=None</em>, <em>l1=None</em>, <em>l2=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/cc/ccsd.html#CCSD.make_rdm2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.ccsd.CCSD.make_rdm2" title="Permalink to this definition">¶</a></dt>
<dd><p>2-particle density matrix in MO space.  The density matrix is
stored as</p>
<p>dm2[p,r,q,s] = &lt;p^+ q^+ s r&gt;</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyscf.cc.ccsd.as_scanner">
<code class="descclassname">pyscf.cc.ccsd.</code><code class="descname">as_scanner</code><span class="sig-paren">(</span><em>cc</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/cc/ccsd.html#as_scanner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.ccsd.as_scanner" title="Permalink to this definition">¶</a></dt>
<dd><p>Generating a scanner/solver for CCSD PES.</p>
<p>The returned solver is a function. This function requires one argument
&#8220;mol&#8221; as input and returns total CCSD energy.</p>
<p>The solver will automatically use the results of last calculation as the
initial guess of the new calculation.  All parameters assigned in the
CCSD and the underlying SCF objects (conv_tol, max_memory etc) are
automatically applied in the solver.</p>
<p>Note scanner has side effects.  It may change many underlying objects
(_scf, with_df, with_x2c, ...) during calculation.</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">cc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cc_scanner</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">))</span><span class="o">.</span><span class="n">as_scanner</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e_tot</span><span class="p">,</span> <span class="n">grad</span> <span class="o">=</span> <span class="n">cc_scanner</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e_tot</span><span class="p">,</span> <span class="n">grad</span> <span class="o">=</span> <span class="n">cc_scanner</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.5&#39;</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.cc.ccsd.energy">
<code class="descclassname">pyscf.cc.ccsd.</code><code class="descname">energy</code><span class="sig-paren">(</span><em>mycc</em>, <em>t1</em>, <em>t2</em>, <em>eris</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/cc/ccsd.html#energy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.ccsd.energy" title="Permalink to this definition">¶</a></dt>
<dd><p>CCSD correlation energy</p>
</dd></dl>

</div>
<div class="section" id="cc-rccsd-and-rccsd-class">
<h3>cc.rccsd and RCCSD class<a class="headerlink" href="#cc-rccsd-and-rccsd-class" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="#pyscf.cc.rccsd.RCCSD" title="pyscf.cc.rccsd.RCCSD"><code class="xref py py-class docutils literal"><span class="pre">pyscf.cc.rccsd.RCCSD</span></code></a> is also a class for restricted CCSD calculations, but
different to the <a class="reference internal" href="#pyscf.cc.ccsd.CCSD" title="pyscf.cc.ccsd.CCSD"><code class="xref py py-class docutils literal"><span class="pre">pyscf.cc.ccsd.CCSD</span></code></a> class.  It uses different formula
to compute the ground state CCSD solution.  Although slower than the
implmentation in the <a class="reference internal" href="#pyscf.cc.ccsd.CCSD" title="pyscf.cc.ccsd.CCSD"><code class="xref py py-class docutils literal"><span class="pre">pyscf.cc.ccsd.CCSD</span></code></a> class, it supports the system
with complex integrals.  Another difference is that this class supports EOM-CCSD
methods, including EOM-IP-CCSD, EOM-EA-CCSD, EOM-EE-CCSD, EOM-SF-CCSD.</p>
<dl class="class">
<dt id="pyscf.cc.rccsd.RCCSD">
<em class="property">class </em><code class="descclassname">pyscf.cc.rccsd.</code><code class="descname">RCCSD</code><span class="sig-paren">(</span><em>mf</em>, <em>frozen=0</em>, <em>mo_coeff=None</em>, <em>mo_occ=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/cc/rccsd.html#RCCSD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.rccsd.RCCSD" title="Permalink to this definition">¶</a></dt>
<dd><p>restricted CCSD with IP-EOM, EA-EOM, EE-EOM, and SF-EOM capabilities</p>
<p>Ground-state CCSD is performed in optimized ccsd.CCSD and EOM is performed here.</p>
</dd></dl>

<span class="target" id="module-pyscf.cc.rccsd"></span><dl class="class">
<dt>
<em class="property">class </em><code class="descclassname">pyscf.cc.rccsd.</code><code class="descname">RCCSD</code><span class="sig-paren">(</span><em>mf</em>, <em>frozen=0</em>, <em>mo_coeff=None</em>, <em>mo_occ=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/cc/rccsd.html#RCCSD"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>restricted CCSD with IP-EOM, EA-EOM, EE-EOM, and SF-EOM capabilities</p>
<p>Ground-state CCSD is performed in optimized ccsd.CCSD and EOM is performed here.</p>
<dl class="method">
<dt id="pyscf.cc.rccsd.RCCSD.ccsd">
<code class="descname">ccsd</code><span class="sig-paren">(</span><em>t1=None</em>, <em>t2=None</em>, <em>eris=None</em>, <em>mbpt2=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/cc/rccsd.html#RCCSD.ccsd"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.rccsd.RCCSD.ccsd" title="Permalink to this definition">¶</a></dt>
<dd><p>Ground-state CCSD.</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>mbpt2</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Use one-shot MBPT2 approximation to CCSD.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.cc.rccsd.RCCSD.eaccsd">
<code class="descname">eaccsd</code><span class="sig-paren">(</span><em>nroots=1</em>, <em>left=False</em>, <em>koopmans=False</em>, <em>guess=None</em>, <em>partition=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/cc/rccsd.html#RCCSD.eaccsd"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.rccsd.RCCSD.eaccsd" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate (N+1)-electron charged excitations via EA-EOM-CCSD.</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd>See ipccd()</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.cc.rccsd.RCCSD.eeccsd">
<code class="descname">eeccsd</code><span class="sig-paren">(</span><em>nroots=1</em>, <em>koopmans=False</em>, <em>guess=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/cc/rccsd.html#RCCSD.eeccsd"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.rccsd.RCCSD.eeccsd" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate N-electron neutral excitations via EE-EOM-CCSD.</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>nroots</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Number of roots (eigenvalues) requested</dd>
<dt>koopmans</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Calculate Koopmans&#8217;-like (1p1h) excitations only, targeting via
overlap.</dd>
<dt>guess</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">list of ndarray</span><dd>List of guess vectors to use for targeting via overlap.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.cc.rccsd.RCCSD.eomsf_ccsd_matvec">
<code class="descname">eomsf_ccsd_matvec</code><span class="sig-paren">(</span><em>vector</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/cc/rccsd.html#RCCSD.eomsf_ccsd_matvec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.rccsd.RCCSD.eomsf_ccsd_matvec" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin flip EOM-CCSD</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.cc.rccsd.RCCSD.ipccsd">
<code class="descname">ipccsd</code><span class="sig-paren">(</span><em>nroots=1</em>, <em>left=False</em>, <em>koopmans=False</em>, <em>guess=None</em>, <em>partition=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/cc/rccsd.html#RCCSD.ipccsd"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.rccsd.RCCSD.ipccsd" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate (N-1)-electron charged excitations via IP-EOM-CCSD.</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>nroots</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Number of roots (eigenvalues) requested</dd>
<dt>partition</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool or str</span><dd>Use a matrix-partitioning for the doubles-doubles block.
Can be None, &#8216;mp&#8217; (Moller-Plesset, i.e. orbital energies on the diagonal),
or &#8216;full&#8217; (full diagonal elements).</dd>
<dt>koopmans</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Calculate Koopmans&#8217;-like (quasiparticle) excitations only, targeting via
overlap.</dd>
<dt>guess</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">list of ndarray</span><dd>List of guess vectors to use for targeting via overlap.</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyscf.cc.rccsd.kernel">
<code class="descclassname">pyscf.cc.rccsd.</code><code class="descname">kernel</code><span class="sig-paren">(</span><em>cc</em>, <em>eris</em>, <em>t1=None</em>, <em>t2=None</em>, <em>max_cycle=50</em>, <em>tol=1e-08</em>, <em>tolnormt=1e-06</em>, <em>verbose=4</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/cc/rccsd.html#kernel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.rccsd.kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Exactly the same as pyscf.cc.ccsd.kernel, which calls a
<em>local</em> energy() function.</p>
</dd></dl>

</div>
<div class="section" id="cc-uccsd-and-uccsd-class">
<h3>cc.uccsd and UCCSD class<a class="headerlink" href="#cc-uccsd-and-uccsd-class" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="#pyscf.cc.uccsd.UCCSD" title="pyscf.cc.uccsd.UCCSD"><code class="xref py py-class docutils literal"><span class="pre">pyscf.cc.uccsd.UCCSD</span></code></a> class supports the CCSD calculation based on UHF
wavefunction as well as the ROHF wavefunction.  Besides the ground state UCCSD calculation,
UCCSD lambda equation, 1-particle and 2-particle density matrices, EOM-IP-CCSD,
EOM-EA-CCSD, EOM-EE-CCSD are all available in this class.  Note this class does
not support complex integrals.</p>
<dl class="class">
<dt id="pyscf.cc.uccsd.UCCSD">
<em class="property">class </em><code class="descclassname">pyscf.cc.uccsd.</code><code class="descname">UCCSD</code><span class="sig-paren">(</span><em>mf</em>, <em>frozen=0</em>, <em>mo_coeff=None</em>, <em>mo_occ=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/cc/uccsd.html#UCCSD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.uccsd.UCCSD" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<span class="target" id="module-pyscf.cc.uccsd"></span><p>UCCSD with spatial integrals</p>
<dl class="function">
<dt id="pyscf.cc.uccsd.get_umoidx">
<code class="descclassname">pyscf.cc.uccsd.</code><code class="descname">get_umoidx</code><span class="sig-paren">(</span><em>cc</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/cc/uccsd.html#get_umoidx"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.uccsd.get_umoidx" title="Permalink to this definition">¶</a></dt>
<dd><p>Get MO boolean indices for unrestricted reference, accounting for frozen orbs.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.cc.uccsd.kernel">
<code class="descclassname">pyscf.cc.uccsd.</code><code class="descname">kernel</code><span class="sig-paren">(</span><em>cc</em>, <em>eris</em>, <em>t1=None</em>, <em>t2=None</em>, <em>max_cycle=50</em>, <em>tol=1e-08</em>, <em>tolnormt=1e-06</em>, <em>verbose=4</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/cc/uccsd.html#kernel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.uccsd.kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Exactly the same as pyscf.cc.ccsd.kernel, which calls a
<em>local</em> energy() function.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.cc.uccsd.uspatial2spin">
<code class="descclassname">pyscf.cc.uccsd.</code><code class="descname">uspatial2spin</code><span class="sig-paren">(</span><em>cc</em>, <em>moidx</em>, <em>mo_coeff</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/cc/uccsd.html#uspatial2spin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.uccsd.uspatial2spin" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the results of an unrestricted mean-field calculation to spin-orbital form.</p>
<p>Spin-orbital ordering is determined by orbital energy without regard for spin.</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>fock</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">(nso,nso) ndarray</span><dd>The Fock matrix in the basis of spin-orbitals</dd>
<dt>so_coeff</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">(nao, nso) ndarray</span><dd>The matrix of spin-orbital coefficients in the AO basis</dd>
<dt>spin</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">(nso,) ndarary</span><dd>The spin (0 or 1) of each spin-orbital</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="cc-addons">
<h3>cc.addons<a class="headerlink" href="#cc-addons" title="Permalink to this headline">¶</a></h3>
<p>Helper functions for CCSD, RCCSD and UCCSD modules are implemented in
<code class="xref py py-mod docutils literal"><span class="pre">cc.addons</span></code></p>
<span class="target" id="module-pyscf.cc.addons"></span><dl class="function">
<dt id="pyscf.cc.addons.spatial2spin">
<code class="descclassname">pyscf.cc.addons.</code><code class="descname">spatial2spin</code><span class="sig-paren">(</span><em>tx</em>, <em>orbspin=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/cc/addons.html#spatial2spin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.addons.spatial2spin" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert T1/T2 of spatial orbital representation to T1/T2 of
spin-orbital representation</p>
<p>call orbspin_of_sorted_mo_energy to get orbspin</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.cc.addons.spatial2spinorb">
<code class="descclassname">pyscf.cc.addons.</code><code class="descname">spatial2spinorb</code><span class="sig-paren">(</span><em>tx</em>, <em>orbspin=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.cc.addons.spatial2spinorb" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert T1/T2 of spatial orbital representation to T1/T2 of
spin-orbital representation</p>
<p>call orbspin_of_sorted_mo_energy to get orbspin</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.cc.addons.spin2spatial">
<code class="descclassname">pyscf.cc.addons.</code><code class="descname">spin2spatial</code><span class="sig-paren">(</span><em>tx</em>, <em>orbspin</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/cc/addons.html#spin2spatial"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.addons.spin2spatial" title="Permalink to this definition">¶</a></dt>
<dd><p>call orbspin_of_sorted_mo_energy to get orbspin</p>
</dd></dl>

</div>
<div class="section" id="ccsd-t">
<h3>CCSD(T)<a class="headerlink" href="#ccsd-t" title="Permalink to this headline">¶</a></h3>
<span class="target" id="module-pyscf.cc.ccsd_t"></span></div>
<div class="section" id="module-pyscf.cc.ccsd_grad">
<span id="ccsd-gradients"></span><h3>CCSD gradients<a class="headerlink" href="#module-pyscf.cc.ccsd_grad" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="pyscf.cc.ccsd_grad.as_scanner">
<code class="descclassname">pyscf.cc.ccsd_grad.</code><code class="descname">as_scanner</code><span class="sig-paren">(</span><em>cc</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/cc/ccsd_grad.html#as_scanner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.ccsd_grad.as_scanner" title="Permalink to this definition">¶</a></dt>
<dd><p>Generating a scanner/solver for CCSD PES.</p>
<p>The returned solver is a function. This function requires one argument
&#8220;mol&#8221; as input and returns total CCSD energy.</p>
<p>The solver will automatically use the results of last calculation as the
initial guess of the new calculation.  All parameters assigned in the
CCSD and the underlying SCF objects (conv_tol, max_memory etc) are
automatically applied in the solver.</p>
<p>Note scanner has side effects.  It may change many underlying objects
(_scf, with_df, with_x2c, ...) during calculation.</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">cc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cc_scanner</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">))</span><span class="o">.</span><span class="n">as_scanner</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e_tot</span><span class="p">,</span> <span class="n">grad</span> <span class="o">=</span> <span class="n">cc_scanner</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e_tot</span><span class="p">,</span> <span class="n">grad</span> <span class="o">=</span> <span class="n">cc_scanner</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.5&#39;</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="ci.html" class="btn btn-neutral float-right" title="ci — Configuration interaction" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="tddft.html" class="btn btn-neutral" title="tddft — Time dependent density functional theory" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015-, Qiming Sun &lt;osirpt.sun@gmail.com&gt;.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.4.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: ''
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>