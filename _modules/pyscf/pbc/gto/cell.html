

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pyscf.pbc.gto.cell &mdash; PySCF 1.5.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="PySCF 1.5.0 documentation" href="../../../../index.html"/>
        <link rel="up" title="Module code" href="../../../index.html"/> 

  
  <script src="../../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../../index.html" class="icon icon-home"> PySCF
          

          
          </a>

          
            
            
              <div class="version">
                1.5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../overview.html">1. An overview of PySCF</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorial.html">2. Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../install.html">3. Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../gto.html">4. gto &#8212; Molecular structure and GTO basis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../lib.html">5. <code class="docutils literal"><span class="pre">lib</span></code> &#8212; Helper functions, parameters, and C extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../scf.html">6. scf &#8212; Mean-field methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../ao2mo.html">7. ao2mo &#8212; Integral transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../mcscf.html">8. mcscf &#8212; Multi-configurational self-consistent field</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../fci.html">9. fci &#8212; Full configuration interaction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../symm.html">10. symm &#8211; Point group symmetry and spin symmetry</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../df.html">11. df &#8212; Density fitting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../dft.html">12. dft &#8212; Density functional theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tddft.html">13. tddft &#8212; Time dependent density functional theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../cc.html">14. cc &#8212; Coupled cluster</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../ci.html">15. ci &#8212; Configuration interaction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../dmrgscf.html">16. dmrgscf</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../fciqmcscf.html">17. fciqmcscf</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tools.html">18. tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../grad.html">19. grad &#8212; Analytical nuclear gradients</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../hessian.html">20. hessian &#8212; Analytical nuclear Hessian</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../pbc.html">21. pbc &#8212; Periodic boundary conditions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../lo.html">22. lo &#8212; Orbital localization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../advanced.html">23. Miscellaneous</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../qmmm.html">24. qmmm &#8212; QM/MM interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../mrpt.html">25. mrpt &#8212; Multi-reference perturbation theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../benchmark.html">26. Benchmark</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../code-rule.html">27. Code standard</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../version.html">28. Version history</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">PySCF</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
      <li>pyscf.pbc.gto.cell</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pyscf.pbc.gto.cell</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1"># Copyright 2014-2018 The PySCF Developers. All Rights Reserved.</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="c1">#</span>
<span class="c1"># Author: Qiming Sun &lt;osirpt.sun@gmail.com&gt;</span>
<span class="c1">#         Timothy Berkelbach &lt;tim.berkelbach@gmail.com&gt;</span>
<span class="c1">#</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">ctypes</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.linalg</span>
<span class="kn">import</span> <span class="nn">scipy.misc</span>
<span class="kn">import</span> <span class="nn">scipy.special</span>
<span class="kn">import</span> <span class="nn">scipy.optimize</span>
<span class="kn">import</span> <span class="nn">pyscf.lib.parameters</span> <span class="k">as</span> <span class="nn">param</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">lib</span>
<span class="kn">from</span> <span class="nn">pyscf.dft</span> <span class="k">import</span> <span class="n">radi</span>
<span class="kn">from</span> <span class="nn">pyscf.lib</span> <span class="k">import</span> <span class="n">logger</span>
<span class="kn">from</span> <span class="nn">pyscf.gto</span> <span class="k">import</span> <span class="n">mole</span>
<span class="kn">from</span> <span class="nn">pyscf.gto</span> <span class="k">import</span> <span class="n">moleintor</span>
<span class="kn">from</span> <span class="nn">pyscf.gto.mole</span> <span class="k">import</span> <span class="n">_symbol</span><span class="p">,</span> <span class="n">_rm_digit</span><span class="p">,</span> <span class="n">_atom_symbol</span><span class="p">,</span> <span class="n">_std_symbol</span><span class="p">,</span> <span class="n">charge</span>
<span class="kn">from</span> <span class="nn">pyscf.gto.mole</span> <span class="k">import</span> <span class="n">conc_env</span><span class="p">,</span> <span class="n">uncontract</span>
<span class="kn">from</span> <span class="nn">pyscf.pbc.gto</span> <span class="k">import</span> <span class="n">basis</span>
<span class="kn">from</span> <span class="nn">pyscf.pbc.gto</span> <span class="k">import</span> <span class="n">pseudo</span>
<span class="kn">from</span> <span class="nn">pyscf.pbc.gto</span> <span class="k">import</span> <span class="n">_pbcintor</span>
<span class="kn">from</span> <span class="nn">pyscf.pbc.gto.eval_gto</span> <span class="k">import</span> <span class="n">eval_gto</span> <span class="k">as</span> <span class="n">pbc_eval_gto</span>
<span class="kn">from</span> <span class="nn">pyscf.pbc.tools</span> <span class="k">import</span> <span class="n">pbc</span> <span class="k">as</span> <span class="n">pbctools</span>
<span class="kn">from</span> <span class="nn">pyscf.gto.basis</span> <span class="k">import</span> <span class="n">ALIAS</span> <span class="k">as</span> <span class="n">MOLE_ALIAS</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">__config__</span>

<span class="n">INTEGRAL_PRECISION</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">__config__</span><span class="p">,</span> <span class="s1">&#39;pbc_gto_cell_Cell_precision&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">8</span><span class="p">)</span>
<span class="n">WRAP_AROUND</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">__config__</span><span class="p">,</span> <span class="s1">&#39;pbc_gto_cell_make_kpts_wrap_around&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="n">WITH_GAMMA</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">__config__</span><span class="p">,</span> <span class="s1">&#39;pbc_gto_cell_make_kpts_with_gamma&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">EXP_DELIMITER</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">__config__</span><span class="p">,</span> <span class="s1">&#39;pbc_gto_cell_split_basis_exp_delimiter&#39;</span><span class="p">,</span>
                        <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>


<span class="c1"># For code compatiblity in python-2 and python-3</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,):</span>
    <span class="n">unicode</span> <span class="o">=</span> <span class="nb">str</span>

<span class="n">libpbc</span> <span class="o">=</span> <span class="n">_pbcintor</span><span class="o">.</span><span class="n">libpbc</span>

<span class="k">def</span> <span class="nf">M</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39;This is a shortcut to build up Cell object.</span>

<span class="sd">    Examples:</span>

<span class="sd">    &gt;&gt;&gt; from pyscf.pbc import gto</span>
<span class="sd">    &gt;&gt;&gt; cell = gto.M(a=numpy.eye(3)*4, atom=&#39;He 1 1 1&#39;, basis=&#39;6-31g&#39;)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">cell</span> <span class="o">=</span> <span class="n">Cell</span><span class="p">()</span>
    <span class="n">cell</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cell</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">M</span>


<span class="k">def</span> <span class="nf">format_pseudo</span><span class="p">(</span><span class="n">pseudo_tab</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39;Convert the input :attr:`Cell.pseudo` (dict) to the internal data format::</span>

<span class="sd">       { atom: ( (nelec_s, nele_p, nelec_d, ...),</span>
<span class="sd">                rloc, nexp, (cexp_1, cexp_2, ..., cexp_nexp),</span>
<span class="sd">                nproj_types,</span>
<span class="sd">                (r1, nproj1, ( (hproj1[1,1], hproj1[1,2], ..., hproj1[1,nproj1]),</span>
<span class="sd">                               (hproj1[2,1], hproj1[2,2], ..., hproj1[2,nproj1]),</span>
<span class="sd">                               ...</span>
<span class="sd">                               (hproj1[nproj1,1], hproj1[nproj1,2], ...        ) )),</span>
<span class="sd">                (r2, nproj2, ( (hproj2[1,1], hproj2[1,2], ..., hproj2[1,nproj1]),</span>
<span class="sd">                ... ) )</span>
<span class="sd">                )</span>
<span class="sd">        ... }</span>

<span class="sd">    Args:</span>
<span class="sd">        pseudo_tab : dict</span>
<span class="sd">            Similar to :attr:`Cell.pseudo` (a dict), it **cannot** be a str</span>

<span class="sd">    Returns:</span>
<span class="sd">        Formatted :attr:`~Cell.pseudo`</span>

<span class="sd">    Examples:</span>

<span class="sd">    &gt;&gt;&gt; pbc.format_pseudo({&#39;H&#39;:&#39;gth-blyp&#39;, &#39;He&#39;: &#39;gth-pade&#39;})</span>
<span class="sd">    {&#39;H&#39;: [[1],</span>
<span class="sd">        0.2, 2, [-4.19596147, 0.73049821], 0],</span>
<span class="sd">     &#39;He&#39;: [[2],</span>
<span class="sd">        0.2, 2, [-9.1120234, 1.69836797], 0]}</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">fmt_pseudo</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">pseudo_tab</span><span class="p">:</span>
        <span class="n">symb</span> <span class="o">=</span> <span class="n">_symbol</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
        <span class="n">rawsymb</span> <span class="o">=</span> <span class="n">_rm_digit</span><span class="p">(</span><span class="n">symb</span><span class="p">)</span>
        <span class="n">stdsymb</span> <span class="o">=</span> <span class="n">_std_symbol</span><span class="p">(</span><span class="n">rawsymb</span><span class="p">)</span>
        <span class="n">symb</span> <span class="o">=</span> <span class="n">symb</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">rawsymb</span><span class="p">,</span> <span class="n">stdsymb</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pseudo_tab</span><span class="p">[</span><span class="n">atom</span><span class="p">],</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">unicode</span><span class="p">)):</span>
            <span class="n">fmt_pseudo</span><span class="p">[</span><span class="n">symb</span><span class="p">]</span> <span class="o">=</span> <span class="n">pseudo</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">pseudo_tab</span><span class="p">[</span><span class="n">atom</span><span class="p">]),</span> <span class="n">stdsymb</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fmt_pseudo</span><span class="p">[</span><span class="n">symb</span><span class="p">]</span> <span class="o">=</span> <span class="n">pseudo_tab</span><span class="p">[</span><span class="n">atom</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">fmt_pseudo</span>

<span class="k">def</span> <span class="nf">make_pseudo_env</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">_atm</span><span class="p">,</span> <span class="n">_pseudo</span><span class="p">,</span> <span class="n">pre_env</span><span class="o">=</span><span class="p">[]):</span>
    <span class="k">for</span> <span class="n">ia</span><span class="p">,</span> <span class="n">atom</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">_atom</span><span class="p">):</span>
        <span class="n">symb</span> <span class="o">=</span> <span class="n">atom</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">symb</span> <span class="ow">in</span> <span class="n">_pseudo</span><span class="p">:</span>
            <span class="n">_atm</span><span class="p">[</span><span class="n">ia</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">_pseudo</span><span class="p">[</span><span class="n">symb</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">_pseudobas</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">_atm</span><span class="p">,</span> <span class="n">_pseudobas</span><span class="p">,</span> <span class="n">pre_env</span>

<span class="k">def</span> <span class="nf">format_basis</span><span class="p">(</span><span class="n">basis_tab</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Convert the input :attr:`Cell.basis` to the internal data format::</span>

<span class="sd">      { atom: (l, kappa, ((-exp, c_1, c_2, ..), nprim, nctr, ptr-exps, ptr-contraction-coeff)), ... }</span>

<span class="sd">    Args:</span>
<span class="sd">        basis_tab : dict</span>
<span class="sd">            Similar to :attr:`Cell.basis`, it **cannot** be a str</span>

<span class="sd">    Returns:</span>
<span class="sd">        Formated :attr:`~Cell.basis`</span>

<span class="sd">    Examples:</span>

<span class="sd">    &gt;&gt;&gt; pbc.format_basis({&#39;H&#39;:&#39;gth-szv&#39;})</span>
<span class="sd">    {&#39;H&#39;: [[0,</span>
<span class="sd">        (8.3744350009, -0.0283380461),</span>
<span class="sd">        (1.8058681460, -0.1333810052),</span>
<span class="sd">        (0.4852528328, -0.3995676063),</span>
<span class="sd">        (0.1658236932, -0.5531027541)]]}</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="n">basis_name</span><span class="p">,</span> <span class="n">symb</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">basis_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;unc&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">uncontract</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">basis_name</span><span class="p">[</span><span class="mi">3</span><span class="p">:],</span> <span class="n">symb</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">basis</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">basis_name</span><span class="p">,</span> <span class="n">symb</span><span class="p">)</span>

    <span class="n">fmt_basis</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">basis_tab</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">symb</span> <span class="o">=</span> <span class="n">_atom_symbol</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
        <span class="n">stdsymb</span> <span class="o">=</span> <span class="n">_std_symbol</span><span class="p">(</span><span class="n">symb</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">stdsymb</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;GHOST-&#39;</span><span class="p">):</span>
            <span class="n">stdsymb</span> <span class="o">=</span> <span class="n">stdsymb</span><span class="p">[</span><span class="mi">6</span><span class="p">:]</span>
        <span class="n">atom_basis</span> <span class="o">=</span> <span class="n">basis_tab</span><span class="p">[</span><span class="n">atom</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atom_basis</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">unicode</span><span class="p">)):</span>
            <span class="k">if</span> <span class="s1">&#39;gth&#39;</span> <span class="ow">in</span> <span class="n">atom_basis</span><span class="p">:</span>
                <span class="n">bset</span> <span class="o">=</span> <span class="n">convert</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">atom_basis</span><span class="p">),</span> <span class="n">symb</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bset</span> <span class="o">=</span> <span class="n">atom_basis</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bset</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">rawb</span> <span class="ow">in</span> <span class="n">atom_basis</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rawb</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">unicode</span><span class="p">))</span> <span class="ow">and</span> <span class="s1">&#39;gth&#39;</span> <span class="ow">in</span> <span class="n">rawb</span><span class="p">:</span>
                    <span class="n">bset</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">convert</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">rawb</span><span class="p">),</span> <span class="n">stdsymb</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">bset</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rawb</span><span class="p">)</span>
        <span class="n">fmt_basis</span><span class="p">[</span><span class="n">symb</span><span class="p">]</span> <span class="o">=</span> <span class="n">bset</span>
    <span class="k">return</span> <span class="n">mole</span><span class="o">.</span><span class="n">format_basis</span><span class="p">(</span><span class="n">fmt_basis</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="n">cell</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Deepcopy of the given :class:`Cell` object</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="kn">import</span> <span class="nn">copy</span>
    <span class="n">newcell</span> <span class="o">=</span> <span class="n">mole</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
    <span class="n">newcell</span><span class="o">.</span><span class="n">_pseudo</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">_pseudo</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">newcell</span>

<span class="k">def</span> <span class="nf">pack</span><span class="p">(</span><span class="n">cell</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Pack the input args of :class:`Cell` to a dict, which can be serialized</span>
<span class="sd">    with :mod:`pickle`</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">cldic</span> <span class="o">=</span> <span class="n">mole</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
    <span class="n">cldic</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">a</span>
    <span class="n">cldic</span><span class="p">[</span><span class="s1">&#39;mesh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">mesh</span>
    <span class="n">cldic</span><span class="p">[</span><span class="s1">&#39;precision&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">precision</span>
    <span class="n">cldic</span><span class="p">[</span><span class="s1">&#39;pseudo&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">pseudo</span>
    <span class="n">cldic</span><span class="p">[</span><span class="s1">&#39;ke_cutoff&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">ke_cutoff</span>
    <span class="n">cldic</span><span class="p">[</span><span class="s1">&#39;rcut&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">rcut</span>
    <span class="n">cldic</span><span class="p">[</span><span class="s1">&#39;exp_to_discard&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">exp_to_discard</span>
    <span class="n">cldic</span><span class="p">[</span><span class="s1">&#39;ew_eta&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">ew_eta</span>
    <span class="n">cldic</span><span class="p">[</span><span class="s1">&#39;ew_cut&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">ew_cut</span>
    <span class="n">cldic</span><span class="p">[</span><span class="s1">&#39;dimension&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">dimension</span>
    <span class="k">return</span> <span class="n">cldic</span>

<span class="k">def</span> <span class="nf">unpack</span><span class="p">(</span><span class="n">celldic</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Convert the packed dict to a :class:`Cell` object, to generate the</span>
<span class="sd">    input arguments for :class:`Cell` object.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">cl</span> <span class="o">=</span> <span class="n">Cell</span><span class="p">()</span>
    <span class="n">cl</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">celldic</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cl</span>


<span class="k">def</span> <span class="nf">dumps</span><span class="p">(</span><span class="n">cell</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Serialize Cell object to a JSON formatted str.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">exclude_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">((</span><span class="s1">&#39;output&#39;</span><span class="p">,</span> <span class="s1">&#39;stdout&#39;</span><span class="p">,</span> <span class="s1">&#39;_keys&#39;</span><span class="p">))</span>

    <span class="n">celldic</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">__dict__</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">exclude_keys</span><span class="p">:</span>
        <span class="k">del</span><span class="p">(</span><span class="n">celldic</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">celldic</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">celldic</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">celldic</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">celldic</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">celldic</span><span class="p">[</span><span class="s1">&#39;atom&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">atom</span><span class="p">)</span>
    <span class="n">celldic</span><span class="p">[</span><span class="s1">&#39;basis&#39;</span><span class="p">]</span><span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
    <span class="n">celldic</span><span class="p">[</span><span class="s1">&#39;pseudo&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">pseudo</span><span class="p">)</span>
    <span class="n">celldic</span><span class="p">[</span><span class="s1">&#39;ecp&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">ecp</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">celldic</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">skip_value</span><span class="p">(</span><span class="n">dic</span><span class="p">):</span>
            <span class="n">dic1</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">dic</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">unicode</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">long</span><span class="p">,</span> <span class="nb">float</span><span class="p">))):</span>
                    <span class="n">dic1</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                    <span class="n">dic1</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>   <span class="c1"># Should I recursively skip_vaule?</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
                    <span class="n">dic1</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="n">dic1</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">skip_value</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span><span class="p">(</span><span class="s1">&#39;Function cell.dumps drops attribute </span><span class="si">%s</span><span class="s1"> because &#39;</span>
                          <span class="s1">&#39;it is not JSON-serializable&#39;</span> <span class="o">%</span> <span class="n">k</span><span class="p">)</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">dic1</span>
        <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">skip_value</span><span class="p">(</span><span class="n">celldic</span><span class="p">),</span> <span class="n">skipkeys</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">loads</span><span class="p">(</span><span class="n">cellstr</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Deserialize a str containing a JSON document to a Cell object.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">array</span>  <span class="c1"># for eval function</span>
    <span class="n">celldic</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">cellstr</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">3</span><span class="p">,):</span>
<span class="c1"># Convert to utf8 because JSON loads fucntion returns unicode.</span>
        <span class="k">def</span> <span class="nf">byteify</span><span class="p">(</span><span class="n">inp</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">byteify</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">byteify</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">inp</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()])</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">byteify</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">inp</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">unicode</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">inp</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">inp</span>
        <span class="n">celldic</span> <span class="o">=</span> <span class="n">byteify</span><span class="p">(</span><span class="n">celldic</span><span class="p">)</span>
    <span class="n">cell</span> <span class="o">=</span> <span class="n">Cell</span><span class="p">()</span>
    <span class="n">cell</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">celldic</span><span class="p">)</span>
    <span class="n">cell</span><span class="o">.</span><span class="n">atom</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">atom</span><span class="p">)</span>
    <span class="n">cell</span><span class="o">.</span><span class="n">basis</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
    <span class="n">cell</span><span class="o">.</span><span class="n">pseudo</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">pseudo</span><span class="p">)</span>
    <span class="n">cell</span><span class="o">.</span><span class="n">ecp</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">ecp</span><span class="p">)</span>
    <span class="n">cell</span><span class="o">.</span><span class="n">_atm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">_atm</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">cell</span><span class="o">.</span><span class="n">_bas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">_bas</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">cell</span><span class="o">.</span><span class="n">_env</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">_env</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    <span class="n">cell</span><span class="o">.</span><span class="n">_ecpbas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">_ecpbas</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">cell</span>

<span class="k">def</span> <span class="nf">conc_cell</span><span class="p">(</span><span class="n">cell1</span><span class="p">,</span> <span class="n">cell2</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Concatenate two Cell objects.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">cell3</span> <span class="o">=</span> <span class="n">Cell</span><span class="p">()</span>
    <span class="n">cell3</span><span class="o">.</span><span class="n">_atm</span><span class="p">,</span> <span class="n">cell3</span><span class="o">.</span><span class="n">_bas</span><span class="p">,</span> <span class="n">cell3</span><span class="o">.</span><span class="n">_env</span> <span class="o">=</span> \
            <span class="n">conc_env</span><span class="p">(</span><span class="n">cell1</span><span class="o">.</span><span class="n">_atm</span><span class="p">,</span> <span class="n">cell1</span><span class="o">.</span><span class="n">_bas</span><span class="p">,</span> <span class="n">cell1</span><span class="o">.</span><span class="n">_env</span><span class="p">,</span>
                     <span class="n">cell2</span><span class="o">.</span><span class="n">_atm</span><span class="p">,</span> <span class="n">cell2</span><span class="o">.</span><span class="n">_bas</span><span class="p">,</span> <span class="n">cell2</span><span class="o">.</span><span class="n">_env</span><span class="p">)</span>
    <span class="n">off</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell1</span><span class="o">.</span><span class="n">_env</span><span class="p">)</span>
    <span class="n">natm_off</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell1</span><span class="o">.</span><span class="n">_atm</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell2</span><span class="o">.</span><span class="n">_ecpbas</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">cell3</span><span class="o">.</span><span class="n">_ecpbas</span> <span class="o">=</span> <span class="n">cell1</span><span class="o">.</span><span class="n">_ecpbas</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ecpbas2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">cell2</span><span class="o">.</span><span class="n">_ecpbas</span><span class="p">)</span>
        <span class="n">ecpbas2</span><span class="p">[:,</span><span class="n">mole</span><span class="o">.</span><span class="n">ATOM_OF</span>  <span class="p">]</span> <span class="o">+=</span> <span class="n">natm_off</span>
        <span class="n">ecpbas2</span><span class="p">[:,</span><span class="n">mole</span><span class="o">.</span><span class="n">PTR_EXP</span>  <span class="p">]</span> <span class="o">+=</span> <span class="n">off</span>
        <span class="n">ecpbas2</span><span class="p">[:,</span><span class="n">mole</span><span class="o">.</span><span class="n">PTR_COEFF</span><span class="p">]</span> <span class="o">+=</span> <span class="n">off</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell1</span><span class="o">.</span><span class="n">_ecpbas</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">cell3</span><span class="o">.</span><span class="n">_ecpbas</span> <span class="o">=</span> <span class="n">ecpbas2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cell3</span><span class="o">.</span><span class="n">_ecpbas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">cell1</span><span class="o">.</span><span class="n">_ecpbas</span><span class="p">,</span> <span class="n">ecpbas2</span><span class="p">))</span>

    <span class="n">cell3</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">cell1</span><span class="o">.</span><span class="n">verbose</span>
    <span class="n">cell3</span><span class="o">.</span><span class="n">output</span> <span class="o">=</span> <span class="n">cell1</span><span class="o">.</span><span class="n">output</span>
    <span class="n">cell3</span><span class="o">.</span><span class="n">max_memory</span> <span class="o">=</span> <span class="n">cell1</span><span class="o">.</span><span class="n">max_memory</span>
    <span class="n">cell3</span><span class="o">.</span><span class="n">charge</span> <span class="o">=</span> <span class="n">cell1</span><span class="o">.</span><span class="n">charge</span> <span class="o">+</span> <span class="n">cell2</span><span class="o">.</span><span class="n">charge</span>
    <span class="n">cell3</span><span class="o">.</span><span class="n">spin</span> <span class="o">=</span> <span class="n">cell1</span><span class="o">.</span><span class="n">spin</span> <span class="o">+</span> <span class="n">cell2</span><span class="o">.</span><span class="n">spin</span>
    <span class="n">cell3</span><span class="o">.</span><span class="n">cart</span> <span class="o">=</span> <span class="n">cell1</span><span class="o">.</span><span class="n">cart</span> <span class="ow">and</span> <span class="n">cell2</span><span class="o">.</span><span class="n">cart</span>
    <span class="n">cell3</span><span class="o">.</span><span class="n">_atom</span> <span class="o">=</span> <span class="n">cell1</span><span class="o">.</span><span class="n">_atom</span> <span class="o">+</span> <span class="n">cell2</span><span class="o">.</span><span class="n">_atom</span>
    <span class="n">cell3</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="n">cell1</span><span class="o">.</span><span class="n">unit</span>
    <span class="n">cell3</span><span class="o">.</span><span class="n">_basis</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">cell2</span><span class="o">.</span><span class="n">_basis</span><span class="p">)</span>
    <span class="n">cell3</span><span class="o">.</span><span class="n">_basis</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cell1</span><span class="o">.</span><span class="n">_basis</span><span class="p">)</span>
    <span class="c1"># Whether to update the lattice_vectors?</span>
    <span class="n">cell3</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">cell1</span><span class="o">.</span><span class="n">a</span>
    <span class="n">cell3</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">((</span><span class="n">cell1</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="n">cell2</span><span class="o">.</span><span class="n">mesh</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">cell3</span><span class="o">.</span><span class="n">ke_cutoff</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">cell1</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="n">cell2</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>
    <span class="n">cell3</span><span class="o">.</span><span class="n">precision</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">cell1</span><span class="o">.</span><span class="n">precision</span><span class="p">,</span> <span class="n">cell2</span><span class="o">.</span><span class="n">precision</span><span class="p">)</span>
    <span class="n">cell3</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">cell1</span><span class="o">.</span><span class="n">dimension</span><span class="p">,</span> <span class="n">cell2</span><span class="o">.</span><span class="n">dimension</span><span class="p">)</span>
    <span class="n">cell3</span><span class="o">.</span><span class="n">low_dim_ft_type</span> <span class="o">=</span> <span class="n">cell1</span><span class="o">.</span><span class="n">low_dim_ft_type</span> <span class="ow">or</span> <span class="n">cell2</span><span class="o">.</span><span class="n">low_dim_ft_type</span>
    <span class="n">cell3</span><span class="o">.</span><span class="n">ew_eta</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">cell1</span><span class="o">.</span><span class="n">ew_eta</span><span class="p">,</span> <span class="n">cell2</span><span class="o">.</span><span class="n">ew_eta</span><span class="p">)</span>
    <span class="n">cell3</span><span class="o">.</span><span class="n">ew_cut</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">cell1</span><span class="o">.</span><span class="n">ew_cut</span><span class="p">,</span> <span class="n">cell2</span><span class="o">.</span><span class="n">ew_cut</span><span class="p">)</span>
    <span class="n">cell3</span><span class="o">.</span><span class="n">rcut</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">cell1</span><span class="o">.</span><span class="n">rcut</span><span class="p">,</span> <span class="n">cell2</span><span class="o">.</span><span class="n">rcut</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">cell2</span><span class="o">.</span><span class="n">_pseudo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cell3</span><span class="o">.</span><span class="n">_pseudo</span> <span class="o">=</span> <span class="n">cell1</span><span class="o">.</span><span class="n">_pseudo</span>
    <span class="k">elif</span> <span class="n">cell1</span><span class="o">.</span><span class="n">_pseudo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cell3</span><span class="o">.</span><span class="n">_pseudo</span> <span class="o">=</span> <span class="n">cell2</span><span class="o">.</span><span class="n">_pseudo</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cell3</span><span class="o">.</span><span class="n">_pseudo</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">cell2</span><span class="o">.</span><span class="n">_pseudo</span><span class="p">)</span>
        <span class="n">cell3</span><span class="o">.</span><span class="n">_pseudo</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cell1</span><span class="o">.</span><span class="n">_pseudo</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">cell2</span><span class="o">.</span><span class="n">_ecp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cell3</span><span class="o">.</span><span class="n">_ecp</span> <span class="o">=</span> <span class="n">cell1</span><span class="o">.</span><span class="n">_ecp</span>
    <span class="k">elif</span> <span class="n">cell1</span><span class="o">.</span><span class="n">_ecp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cell3</span><span class="o">.</span><span class="n">_ecp</span> <span class="o">=</span> <span class="n">cell2</span><span class="o">.</span><span class="n">_ecp</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cell3</span><span class="o">.</span><span class="n">_ecp</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">cell2</span><span class="o">.</span><span class="n">_ecp</span><span class="p">)</span>
        <span class="n">cell3</span><span class="o">.</span><span class="n">_ecp</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cell1</span><span class="o">.</span><span class="n">_ecp</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">cell3</span>

<span class="k">def</span> <span class="nf">intor_cross</span><span class="p">(</span><span class="n">intor</span><span class="p">,</span> <span class="n">cell1</span><span class="p">,</span> <span class="n">cell2</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">kpts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kpt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39;1-electron integrals from two cells like</span>

<span class="sd">    .. math::</span>

<span class="sd">        \langle \mu | intor | \nu \rangle, \mu \in cell1, \nu \in cell2</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="kn">import</span> <span class="nn">copy</span>
    <span class="n">intor</span><span class="p">,</span> <span class="n">comp</span> <span class="o">=</span> <span class="n">moleintor</span><span class="o">.</span><span class="n">_get_intor_and_comp</span><span class="p">(</span><span class="n">cell1</span><span class="o">.</span><span class="n">_add_suffix</span><span class="p">(</span><span class="n">intor</span><span class="p">),</span> <span class="n">comp</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">kpts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">kpt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kpts_lst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">kpt</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kpts_lst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">kpts_lst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">kpts</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">nkpts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">kpts_lst</span><span class="p">)</span>

    <span class="n">pcell</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">cell1</span><span class="p">)</span>
    <span class="n">pcell</span><span class="o">.</span><span class="n">precision</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">cell1</span><span class="o">.</span><span class="n">precision</span><span class="p">,</span> <span class="n">cell2</span><span class="o">.</span><span class="n">precision</span><span class="p">)</span>
    <span class="n">pcell</span><span class="o">.</span><span class="n">_atm</span><span class="p">,</span> <span class="n">pcell</span><span class="o">.</span><span class="n">_bas</span><span class="p">,</span> <span class="n">pcell</span><span class="o">.</span><span class="n">_env</span> <span class="o">=</span> \
    <span class="n">atm</span><span class="p">,</span> <span class="n">bas</span><span class="p">,</span> <span class="n">env</span> <span class="o">=</span> <span class="n">conc_env</span><span class="p">(</span><span class="n">cell1</span><span class="o">.</span><span class="n">_atm</span><span class="p">,</span> <span class="n">cell1</span><span class="o">.</span><span class="n">_bas</span><span class="p">,</span> <span class="n">cell1</span><span class="o">.</span><span class="n">_env</span><span class="p">,</span>
                             <span class="n">cell2</span><span class="o">.</span><span class="n">_atm</span><span class="p">,</span> <span class="n">cell2</span><span class="o">.</span><span class="n">_bas</span><span class="p">,</span> <span class="n">cell2</span><span class="o">.</span><span class="n">_env</span><span class="p">)</span>
    <span class="n">shls_slice</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cell1</span><span class="o">.</span><span class="n">nbas</span><span class="p">,</span> <span class="n">cell1</span><span class="o">.</span><span class="n">nbas</span><span class="p">,</span> <span class="n">pcell</span><span class="o">.</span><span class="n">nbas</span><span class="p">)</span>
    <span class="n">ao_loc</span> <span class="o">=</span> <span class="n">moleintor</span><span class="o">.</span><span class="n">make_loc</span><span class="p">(</span><span class="n">bas</span><span class="p">,</span> <span class="n">intor</span><span class="p">)</span>
    <span class="n">ni</span> <span class="o">=</span> <span class="n">ao_loc</span><span class="p">[</span><span class="n">shls_slice</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> <span class="n">ao_loc</span><span class="p">[</span><span class="n">shls_slice</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">nj</span> <span class="o">=</span> <span class="n">ao_loc</span><span class="p">[</span><span class="n">shls_slice</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span> <span class="o">-</span> <span class="n">ao_loc</span><span class="p">[</span><span class="n">shls_slice</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nkpts</span><span class="p">,</span><span class="n">comp</span><span class="p">,</span><span class="n">ni</span><span class="p">,</span><span class="n">nj</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">hermi</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">aosym</span> <span class="o">=</span> <span class="s1">&#39;s1&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">aosym</span> <span class="o">=</span> <span class="s1">&#39;s2&#39;</span>
    <span class="n">fill</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">libpbc</span><span class="p">,</span> <span class="s1">&#39;PBCnr2c_fill_k&#39;</span><span class="o">+</span><span class="n">aosym</span><span class="p">)</span>
    <span class="n">fintor</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">moleintor</span><span class="o">.</span><span class="n">libcgto</span><span class="p">,</span> <span class="n">intor</span><span class="p">)</span>
    <span class="n">cintopt</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">c_null_ptr</span><span class="p">()</span>
    <span class="n">pbcopt</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;pbcopt&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">pbcopt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pbcopt</span> <span class="o">=</span> <span class="n">_pbcintor</span><span class="o">.</span><span class="n">PBCOpt</span><span class="p">(</span><span class="n">pcell</span><span class="p">)</span><span class="o">.</span><span class="n">init_rcut_cond</span><span class="p">(</span><span class="n">pcell</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pbcopt</span><span class="p">,</span> <span class="n">_pbcintor</span><span class="o">.</span><span class="n">PBCOpt</span><span class="p">):</span>
        <span class="n">cpbcopt</span> <span class="o">=</span> <span class="n">pbcopt</span><span class="o">.</span><span class="n">_this</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cpbcopt</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">c_null_ptr</span><span class="p">()</span>

    <span class="n">Ls</span> <span class="o">=</span> <span class="n">cell1</span><span class="o">.</span><span class="n">get_lattice_Ls</span><span class="p">(</span><span class="n">rcut</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">cell1</span><span class="o">.</span><span class="n">rcut</span><span class="p">,</span> <span class="n">cell2</span><span class="o">.</span><span class="n">rcut</span><span class="p">))</span>
    <span class="n">expkL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">kpts_lst</span><span class="p">,</span> <span class="n">Ls</span><span class="o">.</span><span class="n">T</span><span class="p">)),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
    <span class="n">drv</span> <span class="o">=</span> <span class="n">libpbc</span><span class="o">.</span><span class="n">PBCnr2c_drv</span>
    <span class="n">drv</span><span class="p">(</span><span class="n">fintor</span><span class="p">,</span> <span class="n">fill</span><span class="p">,</span> <span class="n">out</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">),</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">(</span><span class="n">nkpts</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">(</span><span class="n">comp</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Ls</span><span class="p">)),</span>
        <span class="n">Ls</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">),</span>
        <span class="n">expkL</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">),</span>
        <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="o">*</span><span class="mi">4</span><span class="p">)(</span><span class="o">*</span><span class="p">(</span><span class="n">shls_slice</span><span class="p">[:</span><span class="mi">4</span><span class="p">])),</span>
        <span class="n">ao_loc</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">),</span> <span class="n">cintopt</span><span class="p">,</span> <span class="n">cpbcopt</span><span class="p">,</span>
        <span class="n">atm</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">(</span><span class="n">pcell</span><span class="o">.</span><span class="n">natm</span><span class="p">),</span>
        <span class="n">bas</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">(</span><span class="n">pcell</span><span class="o">.</span><span class="n">nbas</span><span class="p">),</span>
        <span class="n">env</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">))</span>

    <span class="n">mat</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">kpt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">kpts_lst</span><span class="p">):</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">hermi</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ic</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">comp</span><span class="p">):</span>
                <span class="n">lib</span><span class="o">.</span><span class="n">hermi_triu</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">ic</span><span class="p">],</span> <span class="n">hermi</span><span class="o">=</span><span class="n">hermi</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">comp</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">kpt</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">9</span><span class="p">:</span>  <span class="c1"># gamma_point</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">real</span>
        <span class="n">mat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">kpts</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">kpts</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,):</span>  <span class="c1"># A single k-point</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">mat</span>


<span class="k">def</span> <span class="nf">get_nimgs</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39;Choose number of basis function images in lattice sums</span>
<span class="sd">    to include for given precision in overlap, using</span>

<span class="sd">    precision ~ \int r^l e^{-\alpha r^2} (r-rcut)^l e^{-\alpha (r-rcut)^2}</span>
<span class="sd">    ~ (rcut^2/(2\alpha))^l e^{\alpha/2 rcut^2}</span>

<span class="sd">    where \alpha is the smallest exponent in the basis. Note</span>
<span class="sd">    that assumes an isolated exponent in the middle of the box, so</span>
<span class="sd">    it adds one additional lattice vector to be safe.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">precision</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">precision</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">precision</span>

    <span class="n">rcut</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">cell</span><span class="o">.</span><span class="n">bas_rcut</span><span class="p">(</span><span class="n">ib</span><span class="p">,</span> <span class="n">precision</span><span class="p">)</span> <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">nbas</span><span class="p">)])</span>

    <span class="c1"># nimgs determines the supercell size</span>
    <span class="n">nimgs</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">get_bounding_sphere</span><span class="p">(</span><span class="n">rcut</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">nimgs</span>

<span class="k">def</span> <span class="nf">_estimate_rcut</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="n">INTEGRAL_PRECISION</span><span class="p">):</span>
    <span class="n">C</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">200</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">alpha</span> <span class="o">/</span> <span class="n">precision</span>
    <span class="n">r0</span> <span class="o">=</span> <span class="mi">20</span>
    <span class="c1"># +1. to ensure np.log returning positive value</span>
    <span class="n">r0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">C</span><span class="o">*</span><span class="p">(</span><span class="n">r0</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">alpha</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mf">1.</span><span class="p">)</span> <span class="o">/</span> <span class="n">alpha</span><span class="p">)</span>
    <span class="n">rcut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="mf">2.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">C</span><span class="o">*</span><span class="p">(</span><span class="n">r0</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">alpha</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mf">1.</span><span class="p">)</span> <span class="o">/</span> <span class="n">alpha</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rcut</span>

<span class="k">def</span> <span class="nf">bas_rcut</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">bas_id</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="n">INTEGRAL_PRECISION</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39;Estimate the largest distance between the function and its image to</span>
<span class="sd">    reach the precision in overlap</span>

<span class="sd">    precision ~ \int g(r-0) g(r-R)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">l</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">bas_angular</span><span class="p">(</span><span class="n">bas_id</span><span class="p">)</span>
    <span class="n">es</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">bas_exp</span><span class="p">(</span><span class="n">bas_id</span><span class="p">)</span>
    <span class="n">cs</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">bas_ctr_coeff</span><span class="p">(</span><span class="n">bas_id</span><span class="p">))</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">rcut</span> <span class="o">=</span> <span class="n">_estimate_rcut</span><span class="p">(</span><span class="n">es</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">precision</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rcut</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">_estimate_ke_cutoff</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="n">INTEGRAL_PRECISION</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Energy cutoff estimation&#39;&#39;&#39;</span>
    <span class="n">log_k0</span> <span class="o">=</span> <span class="mf">2.5</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">l2fac2</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">factorial2</span><span class="p">(</span><span class="n">l</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">log_rest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">precision</span><span class="o">*</span><span class="n">l2fac2</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">alpha</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">l</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">32</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">c</span><span class="o">**</span><span class="mi">4</span><span class="o">*</span><span class="n">weight</span><span class="p">))</span>
    <span class="n">Ecut</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">alpha</span> <span class="o">*</span> <span class="p">(</span><span class="n">log_k0</span><span class="o">*</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">l</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="n">log_rest</span><span class="p">)</span>
    <span class="n">log_k0</span> <span class="o">=</span> <span class="o">.</span><span class="mi">5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">Ecut</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">Ecut</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">alpha</span> <span class="o">*</span> <span class="p">(</span><span class="n">log_k0</span><span class="o">*</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">l</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="n">log_rest</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Ecut</span>

<span class="k">def</span> <span class="nf">estimate_ke_cutoff</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="n">INTEGRAL_PRECISION</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Energy cutoff estimation&#39;&#39;&#39;</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">reciprocal_vectors</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">cell</span><span class="o">.</span><span class="n">dimension</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">cell</span><span class="o">.</span><span class="n">dimension</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">cell</span><span class="o">.</span><span class="n">dimension</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">b</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span>

    <span class="n">Ecut_max</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">nbas</span><span class="p">):</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">bas_angular</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">es</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">bas_exp</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">cs</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">bas_ctr_coeff</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ke_guess</span> <span class="o">=</span> <span class="n">_estimate_ke_cutoff</span><span class="p">(</span><span class="n">es</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">precision</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="n">Ecut_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">Ecut_max</span><span class="p">,</span> <span class="n">ke_guess</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">Ecut_max</span>

<span class="k">def</span> <span class="nf">error_for_ke_cutoff</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">ke_cutoff</span><span class="p">):</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">reciprocal_vectors</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">cell</span><span class="o">.</span><span class="n">dimension</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">cell</span><span class="o">.</span><span class="n">dimension</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">cell</span><span class="o">.</span><span class="n">dimension</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">b</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span>

    <span class="n">kmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">ke_cutoff</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">errmax</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">nbas</span><span class="p">):</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">bas_angular</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">es</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">bas_exp</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">cs</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">bas_ctr_coeff</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">fac</span> <span class="o">=</span> <span class="mi">64</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">cs</span><span class="o">**</span><span class="mi">4</span><span class="o">*</span><span class="n">w</span> <span class="o">/</span> <span class="n">scipy</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">factorial2</span><span class="p">(</span><span class="n">l</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">efac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">ke_cutoff</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">es</span><span class="p">))</span>
        <span class="k">if</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ka</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">factorial2</span><span class="p">(</span><span class="n">l</span><span class="o">*</span><span class="mi">4</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">es</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">l</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">err0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">es</span><span class="p">)</span><span class="o">*</span><span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">erfc</span><span class="p">(</span><span class="n">kmax</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">es</span><span class="p">))</span> <span class="o">*</span> <span class="n">ka</span>
            <span class="n">ka</span> <span class="o">*=</span> <span class="n">efac</span> <span class="o">*</span> <span class="n">kmax</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span><span class="p">):</span>
                <span class="n">err0</span> <span class="o">+=</span> <span class="n">ka</span>
                <span class="n">ka</span> <span class="o">*=</span> <span class="n">ke_cutoff</span> <span class="o">/</span> <span class="p">(</span><span class="n">es</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="o">+</span><span class="mi">3</span><span class="p">))</span>
            <span class="n">errmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">errmax</span><span class="p">,</span> <span class="p">(</span><span class="n">fac</span><span class="o">/</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">es</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">l</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">err0</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">err1</span> <span class="o">=</span> <span class="o">.</span><span class="mi">5</span><span class="o">*</span><span class="n">fac</span><span class="o">/</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">es</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">kmax</span><span class="o">**</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">l</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">efac</span>
            <span class="n">errmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">errmax</span><span class="p">,</span> <span class="n">err1</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">ke_cutoff</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="o">*</span><span class="n">es</span><span class="p">):</span>
                <span class="n">err2</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.41</span><span class="o">*</span><span class="n">efac</span><span class="o">+</span><span class="mf">2.51</span><span class="p">)</span><span class="o">*</span><span class="n">fac</span><span class="o">/</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">es</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">l</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">kmax</span><span class="o">**</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">l</span><span class="o">+</span><span class="mi">5</span><span class="p">)</span>
                <span class="n">errmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">errmax</span><span class="p">,</span> <span class="n">err2</span><span class="p">[</span><span class="n">ke_cutoff</span><span class="o">&lt;</span><span class="mi">5</span><span class="o">*</span><span class="n">es</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">ke_cutoff</span> <span class="o">&lt;</span> <span class="n">es</span><span class="p">):</span>
                <span class="n">err2</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.41</span><span class="o">*</span><span class="n">efac</span><span class="o">+</span><span class="mf">2.51</span><span class="p">)</span><span class="o">*</span><span class="n">fac</span><span class="o">/</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">l</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">es</span><span class="p">)</span>
                <span class="n">errmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">errmax</span><span class="p">,</span> <span class="n">err2</span><span class="p">[</span><span class="n">ke_cutoff</span><span class="o">&lt;</span><span class="n">es</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">errmax</span>

<span class="k">def</span> <span class="nf">get_bounding_sphere</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">rcut</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Finds all the lattice points within a sphere of radius rcut.  </span>

<span class="sd">    Defines a parallelipiped given by -N_x &lt;= n_x &lt;= N_x, with x in [1,3]</span>
<span class="sd">    See Martin p. 85</span>

<span class="sd">    Args:</span>
<span class="sd">        rcut : number</span>
<span class="sd">            real space cut-off for interaction</span>

<span class="sd">    Returns:</span>
<span class="sd">        cut : ndarray of 3 ints defining N_x</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1">#Gmat = cell.reciprocal_vectors(norm_to=1)</span>
    <span class="c1">#n1 = np.ceil(lib.norm(Gmat[0,:])*rcut)</span>
    <span class="c1">#n2 = np.ceil(lib.norm(Gmat[1,:])*rcut)</span>
    <span class="c1">#n3 = np.ceil(lib.norm(Gmat[2,:])*rcut)</span>
    <span class="c1">#cut = np.array([n1, n2, n3]).astype(int)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">reciprocal_vectors</span><span class="p">(</span><span class="n">norm_to</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">heights_inv</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">nimgs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">rcut</span><span class="o">*</span><span class="n">heights_inv</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">dimension</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
        <span class="n">nimgs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">nimgs</span>

<span class="k">def</span> <span class="nf">get_Gv</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Calculate three-dimensional G-vectors for the cell; see MH (3.8).</span>

<span class="sd">    Indices along each direction go as [0...N-1, -N...-1] to follow FFT convention.</span>

<span class="sd">    Args:</span>
<span class="sd">        cell : instance of :class:`Cell`</span>

<span class="sd">    Returns:</span>
<span class="sd">        Gv : (ngrids, 3) ndarray of floats</span>
<span class="sd">            The array of G-vectors.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">mesh</span>
    <span class="k">if</span> <span class="s1">&#39;gs&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;cell.gs is deprecated.  It is replaced by cell.mesh,&#39;</span>
                      <span class="s1">&#39;the number of PWs (=2*gs+1) along each direction.&#39;</span><span class="p">)</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;gs&#39;</span><span class="p">]]</span>

    <span class="n">gx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">mesh</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">1.</span><span class="o">/</span><span class="n">mesh</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">gy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">mesh</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">1.</span><span class="o">/</span><span class="n">mesh</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">gz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">mesh</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mf">1.</span><span class="o">/</span><span class="n">mesh</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">gxyz</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">cartesian_prod</span><span class="p">((</span><span class="n">gx</span><span class="p">,</span> <span class="n">gy</span><span class="p">,</span> <span class="n">gz</span><span class="p">))</span>

    <span class="n">b</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">reciprocal_vectors</span><span class="p">()</span>
    <span class="n">Gv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">gxyz</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Gv</span>

<span class="k">def</span> <span class="nf">get_Gv_weights</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Calculate G-vectors and weights.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Gv : (ngris, 3) ndarray of floats</span>
<span class="sd">            The array of G-vectors.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">mesh</span>
    <span class="k">if</span> <span class="s1">&#39;gs&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;cell.gs is deprecated.  It is replaced by cell.mesh,&#39;</span>
                      <span class="s1">&#39;the number of PWs (=2*gs+1) along each direction.&#39;</span><span class="p">)</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;gs&#39;</span><span class="p">]]</span>

    <span class="k">def</span> <span class="nf">plus_minus</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="c1">#rs, ws = radi.delley(n)</span>
        <span class="c1">#rs, ws = radi.treutler_ahlrichs(n)</span>
        <span class="c1">#rs, ws = radi.mura_knowles(n)</span>
        <span class="n">rs</span><span class="p">,</span> <span class="n">ws</span> <span class="o">=</span> <span class="n">radi</span><span class="o">.</span><span class="n">gauss_chebyshev</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="c1">#return np.hstack((0,rs,-rs[::-1])), np.hstack((0,ws,ws[::-1]))</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">rs</span><span class="p">,</span><span class="o">-</span><span class="n">rs</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">ws</span><span class="p">,</span><span class="n">ws</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

    <span class="n">low_dim_ft_type</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">low_dim_ft_type</span>
    <span class="c1"># Default, the 3D uniform grids</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">reciprocal_vectors</span><span class="p">()</span>
    <span class="n">rx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">mesh</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">1.</span><span class="o">/</span><span class="n">mesh</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">ry</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">mesh</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">1.</span><span class="o">/</span><span class="n">mesh</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">rz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">mesh</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mf">1.</span><span class="o">/</span><span class="n">mesh</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">cell</span><span class="o">.</span><span class="n">dimension</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">rx</span><span class="p">,</span> <span class="n">wx</span> <span class="o">=</span> <span class="n">plus_minus</span><span class="p">(</span><span class="n">mesh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">ry</span><span class="p">,</span> <span class="n">wy</span> <span class="o">=</span> <span class="n">plus_minus</span><span class="p">(</span><span class="n">mesh</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">rz</span><span class="p">,</span> <span class="n">wz</span> <span class="o">=</span> <span class="n">plus_minus</span><span class="p">(</span><span class="n">mesh</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">rx</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">ry</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">rz</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;i,j,k-&gt;ijk&#39;</span><span class="p">,</span> <span class="n">wx</span><span class="p">,</span> <span class="n">wy</span><span class="p">,</span> <span class="n">wz</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">cell</span><span class="o">.</span><span class="n">dimension</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">wx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">mesh</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">ry</span><span class="p">,</span> <span class="n">wy</span> <span class="o">=</span> <span class="n">plus_minus</span><span class="p">(</span><span class="n">mesh</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">rz</span><span class="p">,</span> <span class="n">wz</span> <span class="o">=</span> <span class="n">plus_minus</span><span class="p">(</span><span class="n">mesh</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">ry</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">rz</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;i,j,k-&gt;ijk&#39;</span><span class="p">,</span> <span class="n">wx</span><span class="p">,</span> <span class="n">wy</span><span class="p">,</span> <span class="n">wz</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">cell</span><span class="o">.</span><span class="n">dimension</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># Don&#39;t redefine the grids</span>
        <span class="k">if</span> <span class="n">low_dim_ft_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">wxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">area</span><span class="p">,</span> <span class="n">mesh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">mesh</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">rz</span><span class="p">,</span> <span class="n">wz</span> <span class="o">=</span> <span class="n">plus_minus</span><span class="p">(</span><span class="n">mesh</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">rz</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;i,k-&gt;ik&#39;</span><span class="p">,</span> <span class="n">wxy</span><span class="p">,</span> <span class="n">wz</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># dimension == 3</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
    <span class="n">Gvbase</span> <span class="o">=</span> <span class="p">(</span><span class="n">rx</span><span class="p">,</span> <span class="n">ry</span><span class="p">,</span> <span class="n">rz</span><span class="p">)</span>
    <span class="n">Gv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">lib</span><span class="o">.</span><span class="n">cartesian_prod</span><span class="p">(</span><span class="n">Gvbase</span><span class="p">),</span> <span class="n">b</span><span class="p">)</span>
    <span class="c1"># This could be appropriate to catch any bugs</span>
    <span class="k">if</span> <span class="n">cell</span><span class="o">.</span><span class="n">dimension</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">low_dim_ft_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># 1/cell.vol == det(b)/(2pi)^3</span>
        <span class="n">weights</span> <span class="o">*=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span>
    <span class="k">return</span> <span class="n">Gv</span><span class="p">,</span> <span class="n">Gvbase</span><span class="p">,</span> <span class="n">weights</span>

<span class="k">def</span> <span class="nf">get_SI</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">Gv</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Calculate the structure factor for all atoms; see MH (3.34).</span>

<span class="sd">    Args:</span>
<span class="sd">        cell : instance of :class:`Cell`</span>

<span class="sd">        Gv : (N,3) array</span>
<span class="sd">            G vectors</span>

<span class="sd">    Returns:</span>
<span class="sd">        SI : (natm, ngrids) ndarray, dtype=np.complex128</span>
<span class="sd">            The structure factor for each atom at each G-vector.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">Gv</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Gv</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">get_Gv</span><span class="p">()</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">atom_coords</span><span class="p">()</span>
    <span class="n">SI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">Gv</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">SI</span>

<span class="k">def</span> <span class="nf">get_ewald_params</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="n">INTEGRAL_PRECISION</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39;Choose a reasonable value of Ewald &#39;eta&#39; and &#39;cut&#39; parameters.</span>

<span class="sd">    Choice is based on largest G vector and desired relative precision.</span>

<span class="sd">    The relative error in the G-space sum is given by</span>

<span class="sd">        precision ~ 4\pi Gmax^2 e^{(-Gmax^2)/(4 \eta^2)}</span>

<span class="sd">    which determines eta. Then, real-space cutoff is determined by (exp.</span>
<span class="sd">    factors only)</span>

<span class="sd">        precision ~ erfc(eta*rcut) / rcut ~ e^{(-eta**2 rcut*2)}</span>

<span class="sd">    Returns:</span>
<span class="sd">        ew_eta, ew_cut : float</span>
<span class="sd">            The Ewald &#39;eta&#39; and &#39;cut&#39; parameters.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">cell</span><span class="o">.</span><span class="n">natm</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">cell</span><span class="o">.</span><span class="n">dimension</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">mesh</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">_cut_mesh_for_ewald</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">mesh</span><span class="p">)</span>
        <span class="n">Gmax</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="n">lib</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">reciprocal_vectors</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">log_precision</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">precision</span><span class="o">/</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">Gmax</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">ew_eta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="n">Gmax</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">log_precision</span><span class="p">))</span>
        <span class="n">ew_cut</span> <span class="o">=</span> <span class="n">_estimate_rcut</span><span class="p">(</span><span class="n">ew_eta</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">precision</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
<span class="c1"># Non-uniform PW grids are used for low-dimensional ewald summation.  The cutoff</span>
<span class="c1"># estimation for long range part based on exp(G^2/(4*eta^2)) does not work for</span>
<span class="c1"># non-uniform grids.  Smooth model density is preferred.</span>
        <span class="n">ew_cut</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">rcut</span>
        <span class="n">ew_eta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">ew_cut</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">precision</span><span class="p">)</span><span class="o">/</span><span class="n">ew_cut</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">ew_eta</span><span class="p">,</span> <span class="n">ew_cut</span>

<span class="c1"># roughly 4 grids per axis</span>
<span class="k">def</span> <span class="nf">_cut_mesh_for_ewald</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">mesh</span><span class="p">):</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
    <span class="n">mesh_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">lattice_vectors</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
                          <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">mesh_max</span><span class="p">[</span><span class="n">cell</span><span class="o">.</span><span class="n">dimension</span><span class="p">:]</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">[</span><span class="n">cell</span><span class="o">.</span><span class="n">dimension</span><span class="p">:]</span>
    <span class="n">mesh_max</span><span class="p">[</span><span class="n">mesh_max</span><span class="o">&lt;</span><span class="mi">80</span><span class="p">]</span> <span class="o">=</span> <span class="mi">80</span>
    <span class="n">mesh</span><span class="p">[</span><span class="n">mesh</span><span class="o">&gt;</span><span class="n">mesh_max</span><span class="p">]</span> <span class="o">=</span> <span class="n">mesh_max</span><span class="p">[</span><span class="n">mesh</span><span class="o">&gt;</span><span class="n">mesh_max</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">mesh</span>

<span class="c1"># In testing: two types of background charge.</span>
<span class="k">if</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">_SI_for_uniform_model_charge</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">Gv</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Background charge on one plane which passes through the charge center.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">chargs</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">atom_charges</span><span class="p">()</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">atom_coords</span><span class="p">()</span>
        <span class="n">charge_center</span> <span class="o">=</span> <span class="n">mole</span><span class="o">.</span><span class="n">charge_center</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">_atom</span><span class="p">,</span> <span class="n">chargs</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cell</span><span class="o">.</span><span class="n">dimension</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">G0idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">Gv</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">SI_on_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;gx,x-&gt;g&#39;</span><span class="p">,</span> <span class="n">Gv</span><span class="p">[</span><span class="n">G0idx</span><span class="p">,</span><span class="mi">1</span><span class="p">:],</span> <span class="n">charge_center</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
        <span class="k">elif</span> <span class="n">cell</span><span class="o">.</span><span class="n">dimension</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">G0idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">Gv</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Gv</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">SI_on_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="p">(</span><span class="n">Gv</span><span class="p">[</span><span class="n">G0idx</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">charge_center</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">G0idx</span> <span class="o">=</span> <span class="n">SI_on_z</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">G0idx</span><span class="p">,</span> <span class="n">SI_on_z</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">_SI_for_uniform_model_charge</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">Gv</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Background charge on multiple planes.  Each plane passes through one</span>
<span class="sd">        nucleus.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">chargs</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">atom_charges</span><span class="p">()</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">atom_coords</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">cell</span><span class="o">.</span><span class="n">dimension</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">G0idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">Gv</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">SI_on_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;gx,ix-&gt;ig&#39;</span><span class="p">,</span> <span class="n">Gv</span><span class="p">[</span><span class="n">G0idx</span><span class="p">,</span><span class="mi">1</span><span class="p">:],</span> <span class="n">coords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]))</span>
            <span class="n">SI_on_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;i,ig-&gt;g&quot;</span><span class="p">,</span> <span class="n">chargs</span><span class="p">,</span> <span class="n">SI_on_z</span><span class="p">)</span> <span class="o">/</span> <span class="n">chargs</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">cell</span><span class="o">.</span><span class="n">dimension</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">G0idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">Gv</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Gv</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">SI_on_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;g,i-&gt;ig&#39;</span><span class="p">,</span> <span class="n">Gv</span><span class="p">[</span><span class="n">G0idx</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">coords</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]))</span>
            <span class="n">SI_on_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;i,ig-&gt;g&quot;</span><span class="p">,</span> <span class="n">chargs</span><span class="p">,</span> <span class="n">SI_on_z</span><span class="p">)</span> <span class="o">/</span> <span class="n">chargs</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">G0idx</span> <span class="o">=</span> <span class="n">SI_on_z</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">G0idx</span><span class="p">,</span> <span class="n">SI_on_z</span>

<span class="k">def</span> <span class="nf">ewald</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">ew_eta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ew_cut</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Perform real (R) and reciprocal (G) space Ewald sum for the energy.</span>

<span class="sd">    Formulation of Martin, App. F2.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float</span>
<span class="sd">            The Ewald energy consisting of overlap, self, and G-space sum.</span>

<span class="sd">    See Also:</span>
<span class="sd">        pyscf.pbc.gto.get_ewald_params</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">cell</span><span class="o">.</span><span class="n">natm</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">ew_eta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">ew_eta</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">ew_eta</span>
    <span class="k">if</span> <span class="n">ew_cut</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">ew_cut</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">ew_cut</span>
    <span class="n">chargs</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">atom_charges</span><span class="p">()</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">atom_coords</span><span class="p">()</span>
    <span class="n">low_dim_ft_type</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">low_dim_ft_type</span>
    <span class="n">Lall</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">get_lattice_Ls</span><span class="p">(</span><span class="n">rcut</span><span class="o">=</span><span class="n">ew_cut</span><span class="p">)</span>
    <span class="n">ewovrl</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">qi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">chargs</span><span class="p">):</span>
        <span class="n">ri</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="n">qj</span> <span class="o">=</span> <span class="n">chargs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">rj</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">r1</span> <span class="o">=</span> <span class="n">ri</span><span class="o">-</span><span class="n">rj</span> <span class="o">+</span> <span class="n">Lall</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ji,ji-&gt;j&#39;</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r1</span><span class="p">))</span>
            <span class="n">ewovrl</span> <span class="o">+=</span> <span class="p">(</span><span class="n">qi</span> <span class="o">*</span> <span class="n">qj</span> <span class="o">/</span> <span class="n">r</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">erfc</span><span class="p">(</span><span class="n">ew_eta</span> <span class="o">*</span> <span class="n">r</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="c1"># exclude the point where Lall == 0</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Lall</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">r</span><span class="p">[</span><span class="n">r</span><span class="o">&lt;</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="n">e200</span>
    <span class="n">ewovrl</span> <span class="o">+=</span> <span class="o">.</span><span class="mi">5</span> <span class="o">*</span> <span class="p">(</span><span class="n">chargs</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">r</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">erfc</span><span class="p">(</span><span class="n">ew_eta</span> <span class="o">*</span> <span class="n">r</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="c1"># last line of Eq. (F.5) in Martin</span>
    <span class="n">ewself</span>  <span class="o">=</span> <span class="o">-.</span><span class="mi">5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">chargs</span><span class="p">,</span><span class="n">chargs</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ew_eta</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cell</span><span class="o">.</span><span class="n">dimension</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">ewself</span> <span class="o">+=</span> <span class="o">-.</span><span class="mi">5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">chargs</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="p">(</span><span class="n">ew_eta</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">cell</span><span class="o">.</span><span class="n">vol</span><span class="p">)</span>

    <span class="c1"># g-space sum (using g grid) (Eq. (F.6) in Martin, but note errors as below)</span>
    <span class="c1"># Eq. (F.6) in Martin is off by a factor of 2, the</span>
    <span class="c1"># exponent is wrong (8-&gt;4) and the square is in the wrong place</span>
    <span class="c1">#</span>
    <span class="c1"># Formula should be</span>
    <span class="c1">#   1/2 * 4\pi / Omega \sum_I \sum_{G\neq 0} |ZS_I(G)|^2 \exp[-|G|^2/4\eta^2]</span>
    <span class="c1"># where</span>
    <span class="c1">#   ZS_I(G) = \sum_a Z_a exp (i G.R_a)</span>
    <span class="c1"># See also Eq. (32) of ewald.pdf at</span>
    <span class="c1">#   http://www.fisica.uniud.it/~giannozz/public/ewald.pdf</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">_cut_mesh_for_ewald</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>
    <span class="n">Gv</span><span class="p">,</span> <span class="n">Gvbase</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">get_Gv_weights</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
    <span class="n">absG2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;gi,gi-&gt;g&#39;</span><span class="p">,</span> <span class="n">Gv</span><span class="p">,</span> <span class="n">Gv</span><span class="p">)</span>
    <span class="n">absG2</span><span class="p">[</span><span class="n">absG2</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="n">e200</span>
    <span class="k">if</span> <span class="n">low_dim_ft_type</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">cell</span><span class="o">.</span><span class="n">dimension</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">coulG</span> <span class="o">=</span> <span class="mi">4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">absG2</span>
        <span class="n">coulG</span> <span class="o">*=</span> <span class="n">weights</span>
        <span class="n">ZSI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;i,ij-&gt;j&quot;</span><span class="p">,</span> <span class="n">chargs</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">get_SI</span><span class="p">(</span><span class="n">Gv</span><span class="p">))</span>
        <span class="n">ZexpG2</span> <span class="o">=</span> <span class="n">ZSI</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">absG2</span><span class="o">/</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">ew_eta</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">cell</span><span class="o">.</span><span class="n">dimension</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">cell</span><span class="o">.</span><span class="n">dimension</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">G0idx</span><span class="p">,</span> <span class="n">SI_on_z</span> <span class="o">=</span> <span class="n">_SI_for_uniform_model_charge</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">Gv</span><span class="p">)</span>
            <span class="n">bg_charge</span> <span class="o">=</span> <span class="n">chargs</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">*</span> <span class="n">SI_on_z</span>
            <span class="n">ZexpG2</span><span class="p">[</span><span class="n">G0idx</span><span class="p">]</span> <span class="o">-=</span> <span class="n">bg_charge</span>
            <span class="n">ZSI_without_bg</span> <span class="o">=</span> <span class="n">ZSI</span><span class="p">[</span><span class="n">G0idx</span><span class="p">]</span> <span class="o">-</span> <span class="n">bg_charge</span>
            <span class="c1"># (m-s|Z)</span>
            <span class="n">ewg</span> <span class="o">=</span> <span class="o">.</span><span class="mi">5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;i,i,i&#39;</span><span class="p">,</span> <span class="n">ZSI</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">ZexpG2</span><span class="p">,</span> <span class="n">coulG</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
            <span class="c1"># (Z-s|s)</span>
            <span class="n">ewg</span> <span class="o">-=</span> <span class="o">.</span><span class="mi">5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;i,i,i&#39;</span><span class="p">,</span> <span class="n">ZSI_without_bg</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">bg_charge</span><span class="p">,</span>
                                  <span class="n">coulG</span><span class="p">[</span><span class="n">G0idx</span><span class="p">])</span><span class="o">.</span><span class="n">real</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ewg</span> <span class="o">=</span> <span class="o">.</span><span class="mi">5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;i,i,i&#39;</span><span class="p">,</span> <span class="n">ZSI</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">ZexpG2</span><span class="p">,</span> <span class="n">coulG</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>

    <span class="k">elif</span> <span class="n">low_dim_ft_type</span> <span class="o">==</span> <span class="s1">&#39;analytic_2d_1&#39;</span> <span class="ow">and</span> <span class="n">cell</span><span class="o">.</span><span class="n">dimension</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># The following 2D ewald summation is taken from:</span>
        <span class="c1"># R. Sundararaman and T. Arias PRB 87, 2013</span>
        <span class="k">def</span> <span class="nf">fn</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span><span class="n">Gnorm</span><span class="p">,</span><span class="n">z</span><span class="p">):</span>
            <span class="n">Gnorm_z</span> <span class="o">=</span> <span class="n">Gnorm</span><span class="o">*</span><span class="n">z</span>
            <span class="n">large_idx</span> <span class="o">=</span> <span class="n">Gnorm_z</span> <span class="o">&gt;</span> <span class="mf">20.0</span>
            <span class="n">Gnorm_z</span><span class="p">[</span><span class="n">large_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">over</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">Gnorm_z</span><span class="p">)</span><span class="o">*</span><span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">erfc</span><span class="p">(</span><span class="n">Gnorm</span><span class="o">/</span><span class="mf">2.</span><span class="o">/</span><span class="n">eta</span> <span class="o">+</span> <span class="n">eta</span><span class="o">*</span><span class="n">z</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">large_idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">Gnorm</span><span class="p">[</span><span class="n">large_idx</span><span class="p">]</span><span class="o">/</span><span class="mf">2.</span><span class="o">/</span><span class="n">eta</span> <span class="o">+</span> <span class="n">eta</span><span class="o">*</span><span class="n">z</span>
                <span class="n">ret</span><span class="p">[</span><span class="n">large_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">Gnorm</span><span class="p">[</span><span class="n">large_idx</span><span class="p">]</span><span class="o">*</span><span class="n">z</span><span class="o">-</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">/</span><span class="n">x</span> <span class="o">*</span>
                                      <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">/</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="p">)</span>
            <span class="k">return</span> <span class="n">ret</span>
        <span class="k">def</span> <span class="nf">gn</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span><span class="n">Gnorm</span><span class="p">,</span><span class="n">z</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">Gnorm</span><span class="o">*</span><span class="p">(</span><span class="n">fn</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span><span class="n">Gnorm</span><span class="p">,</span><span class="n">z</span><span class="p">)</span> <span class="o">+</span> <span class="n">fn</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span><span class="n">Gnorm</span><span class="p">,</span><span class="o">-</span><span class="n">z</span><span class="p">))</span>
        <span class="k">def</span> <span class="nf">gn0</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span><span class="n">z</span><span class="p">):</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">z</span><span class="o">*</span><span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">erf</span><span class="p">(</span><span class="n">eta</span><span class="o">*</span><span class="n">z</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">eta</span><span class="o">*</span><span class="n">z</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">eta</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
        <span class="n">ewg</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">reciprocal_vectors</span><span class="p">()</span>
        <span class="n">inv_area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="c1"># Perform the reciprocal space summation over  all reciprocal vectors</span>
        <span class="c1"># within the x,y plane.</span>
        <span class="n">planarG2_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">Gv</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">absG2</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">Gv</span> <span class="o">=</span> <span class="n">Gv</span><span class="p">[</span><span class="n">planarG2_idx</span><span class="p">]</span>
        <span class="n">absG2</span> <span class="o">=</span> <span class="n">absG2</span><span class="p">[</span><span class="n">planarG2_idx</span><span class="p">]</span>
        <span class="n">absG</span> <span class="o">=</span> <span class="n">absG2</span><span class="o">**</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="c1"># Performing the G != 0 summation.</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">ri</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span>
            <span class="n">qi</span> <span class="o">=</span> <span class="n">chargs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">rj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span>
                <span class="n">rij</span> <span class="o">=</span> <span class="n">rj</span> <span class="o">-</span> <span class="n">ri</span>
                <span class="n">qij</span> <span class="o">=</span> <span class="n">qi</span><span class="o">*</span><span class="n">chargs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

                <span class="n">Gdotr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Gv</span><span class="p">,</span><span class="n">rij</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">qij</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">Gdotr</span><span class="p">)</span><span class="o">*</span><span class="n">gn</span><span class="p">(</span><span class="n">ew_eta</span><span class="p">,</span><span class="n">absG</span><span class="p">,</span><span class="n">rij</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">ewg</span> <span class="o">+=</span> <span class="n">val</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="c1"># Performing the G == 0 summation.</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">vi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span>
            <span class="n">qi</span> <span class="o">=</span> <span class="n">chargs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">vj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span>
                <span class="n">rij</span> <span class="o">=</span> <span class="n">vj</span> <span class="o">-</span> <span class="n">vi</span>
                <span class="n">qij</span> <span class="o">=</span> <span class="n">qi</span><span class="o">*</span><span class="n">chargs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

                <span class="n">val</span> <span class="o">=</span> <span class="n">qij</span><span class="o">*</span><span class="n">gn0</span><span class="p">(</span><span class="n">ew_eta</span><span class="p">,</span><span class="n">rij</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">ewg</span> <span class="o">+=</span> <span class="n">val</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">ewg</span> <span class="o">*=</span> <span class="n">inv_area</span><span class="o">*</span><span class="mf">0.5</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Low dimension ft_type &#39;</span><span class="p">,</span>
            <span class="n">low_dim_ft_type</span><span class="p">,</span> <span class="s1">&#39; not implemented for dimension &#39;</span><span class="p">,</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">dimension</span><span class="p">)</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;Ewald components = </span><span class="si">%.15g</span><span class="s1">, </span><span class="si">%.15g</span><span class="s1">, </span><span class="si">%.15g</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">ewovrl</span><span class="p">,</span> <span class="n">ewself</span><span class="p">,</span> <span class="n">ewg</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ewovrl</span> <span class="o">+</span> <span class="n">ewself</span> <span class="o">+</span> <span class="n">ewg</span>

<span class="n">energy_nuc</span> <span class="o">=</span> <span class="n">ewald</span>

<span class="k">def</span> <span class="nf">make_kpts</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">nks</span><span class="p">,</span> <span class="n">wrap_around</span><span class="o">=</span><span class="n">WRAP_AROUND</span><span class="p">,</span> <span class="n">with_gamma_point</span><span class="o">=</span><span class="n">WITH_GAMMA</span><span class="p">,</span>
              <span class="n">scaled_center</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Given number of kpoints along x,y,z , generate kpoints</span>

<span class="sd">    Args:</span>
<span class="sd">        nks : (3,) ndarray</span>

<span class="sd">    Kwargs:</span>
<span class="sd">        wrap_around : bool</span>
<span class="sd">            To ensure all kpts are in first Brillouin zone.</span>
<span class="sd">        with_gamma_point : bool</span>
<span class="sd">            Whether to shift Monkhorst-pack grid to include gamma-point.</span>
<span class="sd">        scaled_center : (3,) array</span>
<span class="sd">            Shift all points in the Monkhorst-pack grid to be centered on</span>
<span class="sd">            scaled_center, given as the zeroth index of the returned kpts.</span>
<span class="sd">            Scaled meaning that the k-points are scaled to a grid from </span>
<span class="sd">            [-1,1] x [-1,1] x [-1,1]</span>

<span class="sd">    Returns:</span>
<span class="sd">        kpts in absolute value (unit 1/Bohr).  Gamma point is placed at the</span>
<span class="sd">        first place in the k-points list</span>

<span class="sd">    Examples:</span>

<span class="sd">    &gt;&gt;&gt; cell.make_kpts((4,4,4))</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">ks_each_axis</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nks</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">with_gamma_point</span> <span class="ow">or</span> <span class="n">scaled_center</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ks</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">+.</span><span class="mi">5</span><span class="p">)</span><span class="o">/</span><span class="n">n</span><span class="o">-.</span><span class="mi">5</span>
        <span class="k">if</span> <span class="n">wrap_around</span><span class="p">:</span>
            <span class="n">ks</span><span class="p">[</span><span class="n">ks</span><span class="o">&gt;=.</span><span class="mi">5</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">ks_each_axis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ks</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">scaled_center</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">scaled_center</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">]</span>
    <span class="n">scaled_kpts</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">cartesian_prod</span><span class="p">(</span><span class="n">ks_each_axis</span><span class="p">)</span>
    <span class="n">scaled_kpts</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">scaled_center</span><span class="p">)</span>
    <span class="n">kpts</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">get_abs_kpts</span><span class="p">(</span><span class="n">scaled_kpts</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">kpts</span>

<span class="k">def</span> <span class="nf">get_uniform_grids</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Generate a uniform real-space grid consistent w/ samp thm; see MH (3.19).</span>

<span class="sd">    Args:</span>
<span class="sd">        cell : instance of :class:`Cell`</span>

<span class="sd">    Returns:</span>
<span class="sd">        coords : (ngx*ngy*ngz, 3) ndarray</span>
<span class="sd">            The real-space grid point coordinates.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">mesh</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">mesh</span>
    <span class="k">if</span> <span class="s1">&#39;gs&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;cell.gs is deprecated.  It is replaced by cell.mesh,&#39;</span>
                      <span class="s1">&#39;the number of PWs (=2*gs+1) along each direction.&#39;</span><span class="p">)</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;gs&#39;</span><span class="p">]]</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    <span class="n">qv</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">cartesian_prod</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">mesh</span><span class="p">])</span>
    <span class="n">a_frac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;i,ij-&gt;ij&#39;</span><span class="p">,</span> <span class="mf">1.</span><span class="o">/</span><span class="n">mesh</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">lattice_vectors</span><span class="p">())</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">qv</span><span class="p">,</span> <span class="n">a_frac</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">coords</span>
<span class="n">gen_uniform_grids</span> <span class="o">=</span> <span class="n">get_uniform_grids</span>

<span class="c1"># Check whether ecp keywords are presented in pp and whether pp keywords are</span>
<span class="c1"># presented in ecp.  The return (ecp, pp) should have only the ecp keywords and</span>
<span class="c1"># pp keywords in each dict.</span>
<span class="c1"># The &quot;misplaced&quot; ecp/pp keywords have lowest priority, ie if the atom is</span>
<span class="c1"># defined in ecp, the misplaced ecp atom found in pp does NOT replace the</span>
<span class="c1"># definition in ecp, and versa vise.</span>
<span class="k">def</span> <span class="nf">classify_ecp_pseudo</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">ecp</span><span class="p">,</span> <span class="n">pp</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">classify</span><span class="p">(</span><span class="n">ecp</span><span class="p">,</span> <span class="n">pp_alias</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ecp</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">unicode</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">pseudo</span><span class="o">.</span><span class="n">_format_pseudo_name</span><span class="p">(</span><span class="n">ecp</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">pp_alias</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">{},</span> <span class="nb">str</span><span class="p">(</span><span class="n">ecp</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ecp</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">ecp_as_pp</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">ecp</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">ecp</span><span class="p">[</span><span class="n">atom</span><span class="p">]</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">unicode</span><span class="p">))</span> <span class="ow">and</span>
                    <span class="n">pseudo</span><span class="o">.</span><span class="n">_format_pseudo_name</span><span class="p">(</span><span class="n">key</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">pp_alias</span><span class="p">):</span>
                    <span class="n">ecp_as_pp</span><span class="p">[</span><span class="n">atom</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ecp_as_pp</span><span class="p">:</span>
                <span class="n">ecp_left</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">ecp</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">ecp_as_pp</span><span class="p">:</span>
                    <span class="n">ecp_left</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">ecp_left</span><span class="p">,</span> <span class="n">ecp_as_pp</span>
        <span class="k">return</span> <span class="n">ecp</span><span class="p">,</span> <span class="p">{}</span>
    <span class="n">ecp_left</span><span class="p">,</span> <span class="n">ecp_as_pp</span> <span class="o">=</span> <span class="n">classify</span><span class="p">(</span><span class="n">ecp</span><span class="p">,</span> <span class="n">pseudo</span><span class="o">.</span><span class="n">ALIAS</span><span class="p">)</span>
    <span class="n">pp_left</span> <span class="p">,</span> <span class="n">pp_as_ecp</span> <span class="o">=</span> <span class="n">classify</span><span class="p">(</span><span class="n">pp</span><span class="p">,</span> <span class="n">MOLE_ALIAS</span><span class="p">)</span>

    <span class="c1"># ecp = ecp_left + pp_as_ecp</span>
    <span class="c1"># pp = pp_left + ecp_as_pp</span>
    <span class="n">ecp</span> <span class="o">=</span> <span class="n">ecp_left</span>
    <span class="k">if</span> <span class="n">pp_as_ecp</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ecp_left</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">unicode</span><span class="p">)):</span>
        <span class="c1"># If ecp is a str, all atoms have ecp definition.  The misplaced ecp has no effects.</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;PBC pseudo-potentials keywords for </span><span class="si">%s</span><span class="s1"> found in .ecp&#39;</span><span class="p">,</span>
                    <span class="n">pp_as_ecp</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">ecp_left</span><span class="p">:</span>
            <span class="n">pp_as_ecp</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">ecp_left</span><span class="p">)</span>
        <span class="n">ecp</span> <span class="o">=</span> <span class="n">pp_as_ecp</span>
    <span class="n">pp</span> <span class="o">=</span> <span class="n">pp_left</span>
    <span class="k">if</span> <span class="n">ecp_as_pp</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pp_left</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">unicode</span><span class="p">)):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;ECP keywords for </span><span class="si">%s</span><span class="s1"> found in PBC .pseudo&#39;</span><span class="p">,</span>
                    <span class="n">ecp_as_pp</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">pp_left</span><span class="p">:</span>
            <span class="n">ecp_as_pp</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">pp_left</span><span class="p">)</span>
        <span class="n">pp</span> <span class="o">=</span> <span class="n">ecp_as_pp</span>
    <span class="k">return</span> <span class="n">ecp</span><span class="p">,</span> <span class="n">pp</span>

<span class="k">def</span> <span class="nf">_split_basis</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="n">EXP_DELIMITER</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Split the contracted basis to small segmant.  The new basis has more</span>
<span class="sd">    shells.  Each shell has less primitive basis and thus is more local.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="kn">import</span> <span class="nn">copy</span>
    <span class="n">_bas</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">_env</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">contr_coeff</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">nbas</span><span class="p">):</span>
        <span class="n">pexp</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">_bas</span><span class="p">[</span><span class="n">ib</span><span class="p">,</span><span class="n">mole</span><span class="o">.</span><span class="n">PTR_EXP</span><span class="p">]</span>
        <span class="n">pcoeff1</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">_bas</span><span class="p">[</span><span class="n">ib</span><span class="p">,</span><span class="n">mole</span><span class="o">.</span><span class="n">PTR_COEFF</span><span class="p">]</span>
        <span class="n">nc</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">bas_nctr</span><span class="p">(</span><span class="n">ib</span><span class="p">)</span>
        <span class="n">es</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">bas_exp</span><span class="p">(</span><span class="n">ib</span><span class="p">)</span>
        <span class="n">cs</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">_libcint_ctr_coeff</span><span class="p">(</span><span class="n">ib</span><span class="p">)</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">bas_angular</span><span class="p">(</span><span class="n">ib</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cell</span><span class="o">.</span><span class="n">cart</span><span class="p">:</span>
            <span class="n">degen</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">degen</span> <span class="o">=</span> <span class="n">l</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">es</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">thr</span> <span class="ow">in</span> <span class="n">delimiter</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">es</span> <span class="o">&gt;=</span> <span class="n">thr</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">np1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">pcoeff0</span><span class="p">,</span> <span class="n">pcoeff1</span> <span class="o">=</span> <span class="n">pcoeff1</span><span class="p">,</span> <span class="n">pcoeff1</span> <span class="o">+</span> <span class="n">np1</span> <span class="o">*</span> <span class="n">nc</span>
                <span class="n">cs1</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">_env</span><span class="p">[</span><span class="n">pcoeff0</span><span class="p">:</span><span class="n">pcoeff1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cs1</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
                <span class="n">btemp</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">_bas</span><span class="p">[</span><span class="n">ib</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">btemp</span><span class="p">[</span><span class="n">mole</span><span class="o">.</span><span class="n">NPRIM_OF</span><span class="p">]</span> <span class="o">=</span> <span class="n">np1</span>
                <span class="n">btemp</span><span class="p">[</span><span class="n">mole</span><span class="o">.</span><span class="n">PTR_COEFF</span><span class="p">]</span> <span class="o">=</span> <span class="n">pcoeff0</span>
                <span class="n">btemp</span><span class="p">[</span><span class="n">mole</span><span class="o">.</span><span class="n">PTR_EXP</span><span class="p">]</span> <span class="o">=</span> <span class="n">pexp</span>
                <span class="n">_bas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">btemp</span><span class="p">)</span>
                <span class="n">mask</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">pexp</span> <span class="o">+=</span> <span class="n">np1</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">contr_coeff</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">degen</span><span class="o">*</span><span class="n">nc</span><span class="p">)]</span> <span class="o">*</span> <span class="n">count</span><span class="p">))</span>

    <span class="n">pcell</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
    <span class="n">pcell</span><span class="o">.</span><span class="n">_bas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">_bas</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">pcell</span><span class="o">.</span><span class="n">_env</span> <span class="o">=</span> <span class="n">_env</span>
    <span class="k">return</span> <span class="n">pcell</span><span class="p">,</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">block_diag</span><span class="p">(</span><span class="o">*</span><span class="n">contr_coeff</span><span class="p">)</span>


<div class="viewcode-block" id="Cell"><a class="viewcode-back" href="../../../../pbc/gto.html#pyscf.pbc.gto.Cell">[docs]</a><span class="k">class</span> <span class="nc">Cell</span><span class="p">(</span><span class="n">mole</span><span class="o">.</span><span class="n">Mole</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;A Cell object holds the basic information of a crystal.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        a : (3,3) ndarray</span>
<span class="sd">            Lattice primitive vectors. Each row represents a lattice vector</span>
<span class="sd">            Reciprocal lattice vectors are given by  b1,b2,b3 = 2 pi inv(a).T</span>
<span class="sd">        mesh : (3,) list of ints</span>
<span class="sd">            The number G-vectors along each direction.</span>
<span class="sd">            The default value is estimated based on :attr:`precision`</span>
<span class="sd">        pseudo : dict or str</span>
<span class="sd">            To define pseudopotential.</span>
<span class="sd">        precision : float</span>
<span class="sd">            To control Ewald sums and lattice sums accuracy</span>
<span class="sd">        rcut : float</span>
<span class="sd">            Cutoff radius (unit Bohr) in lattice summation. The default value</span>
<span class="sd">            is estimated based on the required :attr:`precision`.</span>
<span class="sd">        ke_cutoff : float</span>
<span class="sd">            If set, defines a spherical cutoff of planewaves, with .5 * G**2 &lt; ke_cutoff</span>
<span class="sd">            The default value is estimated based on :attr:`precision`</span>
<span class="sd">        dimension : int</span>
<span class="sd">            Default is 3</span>

<span class="sd">        ** Following attributes (for experts) are automatically generated. **</span>

<span class="sd">        ew_eta, ew_cut : float</span>
<span class="sd">            The Ewald &#39;eta&#39; and &#39;cut&#39; parameters.  See :func:`get_ewald_params`</span>

<span class="sd">    (See other attributes in :class:`Mole`)</span>

<span class="sd">    Examples:</span>

<span class="sd">    &gt;&gt;&gt; mol = Mole(atom=&#39;H^2 0 0 0; H 0 0 1.1&#39;, basis=&#39;sto3g&#39;)</span>
<span class="sd">    &gt;&gt;&gt; cl = Cell()</span>
<span class="sd">    &gt;&gt;&gt; cl.build(a=&#39;3 0 0; 0 3 0; 0 0 3&#39;, atom=&#39;C 1 1 1&#39;, basis=&#39;sto3g&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(cl.atom_symbol(0))</span>
<span class="sd">    C</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">precision</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">__config__</span><span class="p">,</span> <span class="s1">&#39;pbc_gto_cell_Cell_precision&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">8</span><span class="p">)</span>
    <span class="n">exp_to_discard</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">__config__</span><span class="p">,</span> <span class="s1">&#39;pbc_gto_cell_Cell_exp_to_discard&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">mole</span><span class="o">.</span><span class="n">Mole</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># lattice vectors, (a1,a2,a3)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ke_cutoff</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># if set, defines a spherical cutoff</span>
                              <span class="c1"># of fourier components, with .5 * G**2 &lt; ke_cutoff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pseudo</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="c1"># TODO: Simple hack for now; the implementation of ewald depends on the</span>
        <span class="c1">#       density-fitting class.  This determines how the ewald produces</span>
        <span class="c1">#       its energy.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">low_dim_ft_type</span> <span class="o">=</span> <span class="kc">None</span>

<span class="c1">##################################################</span>
<span class="c1"># These attributes are initialized by build function if not given</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ew_eta</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ew_cut</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rcut</span> <span class="o">=</span> <span class="kc">None</span>

<span class="c1">##################################################</span>
<span class="c1"># don&#39;t modify the following variables, they are not input arguments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pseudo</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">((</span><span class="s1">&#39;precision&#39;</span><span class="p">,</span> <span class="s1">&#39;exp_to_discard&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">)</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">__config__</span><span class="p">,</span> <span class="s1">&#39;pbc_gto_cell_Cell_verify_nelec&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
<span class="c1"># nelec method defined in Mole class raises error when the attributes .spin</span>
<span class="c1"># and .nelectron are inconsistent.  In PBC, when the system has even number of</span>
<span class="c1"># k-points, it is valid that .spin is odd while .nelectron is even.</span>
<span class="c1"># Overwriting nelec method to avoid this check.</span>
        <span class="nd">@property</span>
        <span class="k">def</span> <span class="nf">nelec</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">ne</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nelectron</span>
            <span class="n">nalpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">ne</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">nbeta</span> <span class="o">=</span> <span class="n">nalpha</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin</span>
            <span class="k">if</span> <span class="n">nalpha</span> <span class="o">+</span> <span class="n">nbeta</span> <span class="o">!=</span> <span class="n">ne</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Electron number </span><span class="si">%d</span><span class="s1"> and spin </span><span class="si">%d</span><span class="s1"> are not consistent &#39;</span>
                              <span class="s1">&#39;in unit cell</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ne</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">nalpha</span><span class="p">,</span> <span class="n">nbeta</span>

<span class="c1">#Note: Exculde dump_input, parse_arg, basis from kwargs to avoid parsing twice</span>
<div class="viewcode-block" id="Cell.build"><a class="viewcode-back" href="../../../../pbc/gto.html#pyscf.pbc.gto.Cell.build">[docs]</a>    <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dump_input</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parse_arg</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
              <span class="n">a</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ke_cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nimgs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">ew_eta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ew_cut</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pseudo</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">dimension</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rcut</span><span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ecp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">low_dim_ft_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Setup Mole molecule and Cell and initialize some control parameters.</span>
<span class="sd">        Whenever you change the value of the attributes of :class:`Cell`,</span>
<span class="sd">        you need call this function to refresh the internal data of Cell.</span>

<span class="sd">        Kwargs:</span>
<span class="sd">            a : (3,3) ndarray</span>
<span class="sd">                The real-space unit cell lattice vectors. Each row represents</span>
<span class="sd">                a lattice vector.</span>
<span class="sd">            mesh : (3,) ndarray of ints</span>
<span class="sd">                The number of *positive* G-vectors along each direction.</span>
<span class="sd">            pseudo : dict or str</span>
<span class="sd">                To define pseudopotential.  If given, overwrite :attr:`Cell.pseudo`</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span> <span class="o">=</span> <span class="n">h</span>
        <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span>
        <span class="k">if</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span>
        <span class="k">if</span> <span class="n">nimgs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">nimgs</span> <span class="o">=</span> <span class="n">nimgs</span>
        <span class="k">if</span> <span class="n">ew_eta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">ew_eta</span> <span class="o">=</span> <span class="n">ew_eta</span>
        <span class="k">if</span> <span class="n">ew_cut</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">ew_cut</span> <span class="o">=</span> <span class="n">ew_cut</span>
        <span class="k">if</span> <span class="n">pseudo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudo</span> <span class="o">=</span> <span class="n">pseudo</span>
        <span class="k">if</span> <span class="n">basis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span> <span class="o">=</span> <span class="n">basis</span>
        <span class="k">if</span> <span class="n">dimension</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="n">dimension</span>
        <span class="k">if</span> <span class="n">precision</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">precision</span> <span class="o">=</span> <span class="n">precision</span>
        <span class="k">if</span> <span class="n">rcut</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">rcut</span> <span class="o">=</span> <span class="n">rcut</span>
        <span class="k">if</span> <span class="n">ecp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">ecp</span> <span class="o">=</span> <span class="n">ecp</span>
        <span class="k">if</span> <span class="n">ke_cutoff</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">ke_cutoff</span> <span class="o">=</span> <span class="n">ke_cutoff</span>
        <span class="k">if</span> <span class="n">low_dim_ft_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">low_dim_ft_type</span> <span class="o">=</span> <span class="n">low_dim_ft_type</span>

        <span class="k">assert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;unit&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;unit&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="s1">&#39;atom&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">atom</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;atom&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="s1">&#39;gs&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;gs&#39;</span><span class="p">]</span>

        <span class="c1"># Set-up pseudopotential if it exists</span>
        <span class="c1"># This must happen before build() because it affects</span>
        <span class="c1"># tot_electrons() via atom_charge()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ecp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudo</span> <span class="o">=</span> <span class="n">classify_ecp_pseudo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ecp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudo</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pseudo</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">unicode</span><span class="p">)):</span>
                <span class="c1"># specify global pseudo for whole molecule</span>
                <span class="n">_atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_atom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>
                <span class="n">uniq_atoms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">_atom</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_pseudo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_pseudo</span><span class="p">(</span><span class="nb">dict</span><span class="p">([(</span><span class="n">a</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pseudo</span><span class="p">))</span>
                                                      <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">uniq_atoms</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_pseudo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_pseudo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pseudo</span><span class="p">)</span>

        <span class="c1"># Do regular Mole.build with usual kwargs</span>
        <span class="n">_built</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_built</span>
        <span class="n">mole</span><span class="o">.</span><span class="n">Mole</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">parse_arg</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">exp_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">bas_exp</span><span class="p">(</span><span class="n">ib</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbas</span><span class="p">)])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exp_to_discard</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">exp_min</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.1</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;WARNING!</span>
<span class="s1">  Very diffused basis functions are found in the basis set. They may lead to severe</span>
<span class="s1">  linear dependence and numerical instability.  You can set  cell.exp_to_discard=0.1</span>
<span class="s1">  to remove the diffused Gaussians whose exponents are less than 0.1.</span><span class="se">\n\n</span><span class="s1">&#39;&#39;&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">exp_min</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">exp_to_discard</span><span class="p">):</span>
            <span class="c1"># Discard functions of small exponents in basis</span>
            <span class="n">_basis</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">symb</span><span class="p">,</span> <span class="n">basis_now</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_basis</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">basis_add</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">basis_now</span><span class="p">:</span>
                    <span class="n">l</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">int</span><span class="p">):</span>
                        <span class="n">kappa</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">b_coeff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">kappa</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">b_coeff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                    <span class="n">es</span> <span class="o">=</span> <span class="n">b_coeff</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">es</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">exp_to_discard</span><span class="p">):</span>
                        <span class="n">b_coeff</span> <span class="o">=</span> <span class="n">b_coeff</span><span class="p">[</span><span class="n">es</span><span class="o">&gt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">exp_to_discard</span><span class="p">]</span>
<span class="c1"># contraction coefficients may be completely zero after removing one primitive</span>
<span class="c1"># basis. Removing the zero-coefficient basis.</span>
                        <span class="n">b_coeff</span> <span class="o">=</span> <span class="n">b_coeff</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">b_coeff</span><span class="o">!=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)]</span>
                        <span class="k">if</span> <span class="n">b_coeff</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">kappa</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">basis_add</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">l</span><span class="p">]</span> <span class="o">+</span> <span class="n">b_coeff</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">basis_add</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">l</span><span class="p">,</span><span class="n">kappa</span><span class="p">]</span> <span class="o">+</span> <span class="n">b_coeff</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">basis_add</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                <span class="n">_basis</span><span class="p">[</span><span class="n">symb</span><span class="p">]</span> <span class="o">=</span> <span class="n">basis_add</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_basis</span> <span class="o">=</span> <span class="n">_basis</span>

            <span class="n">steep_shls</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">nprim_drop</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">nctr_drop</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bas</span><span class="p">)):</span>
                <span class="n">l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bas_angular</span><span class="p">(</span><span class="n">ib</span><span class="p">)</span>
                <span class="n">nprim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bas_nprim</span><span class="p">(</span><span class="n">ib</span><span class="p">)</span>
                <span class="n">nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bas_nctr</span><span class="p">(</span><span class="n">ib</span><span class="p">)</span>
                <span class="n">es</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bas_exp</span><span class="p">(</span><span class="n">ib</span><span class="p">)</span>
                <span class="n">ptr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bas</span><span class="p">[</span><span class="n">ib</span><span class="p">,</span><span class="n">mole</span><span class="o">.</span><span class="n">PTR_COEFF</span><span class="p">]</span>
                <span class="n">cs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="p">[</span><span class="n">ptr</span><span class="p">:</span><span class="n">ptr</span><span class="o">+</span><span class="n">nprim</span><span class="o">*</span><span class="n">nc</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span><span class="n">nprim</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">es</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">exp_to_discard</span><span class="p">):</span>
                    <span class="n">cs</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="n">es</span><span class="o">&gt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">exp_to_discard</span><span class="p">]</span>
                    <span class="n">es</span> <span class="o">=</span> <span class="n">es</span><span class="p">[</span><span class="n">es</span><span class="o">&gt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">exp_to_discard</span><span class="p">]</span>
                    <span class="n">nprim_old</span><span class="p">,</span> <span class="n">nc_old</span> <span class="o">=</span> <span class="n">nprim</span><span class="p">,</span> <span class="n">nc</span>

<span class="c1"># contraction coefficients may be completely zero after removing one primitive</span>
<span class="c1"># basis. Removing the zero-coefficient basis.</span>
                    <span class="n">cs</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">cs</span><span class="o">!=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)]</span>
                    <span class="n">nprim</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">cs</span><span class="o">.</span><span class="n">shape</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_bas</span><span class="p">[</span><span class="n">ib</span><span class="p">,</span><span class="n">mole</span><span class="o">.</span><span class="n">NPRIM_OF</span><span class="p">]</span> <span class="o">=</span> <span class="n">nprim</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_bas</span><span class="p">[</span><span class="n">ib</span><span class="p">,</span><span class="n">mole</span><span class="o">.</span><span class="n">NCTR_OF</span><span class="p">]</span> <span class="o">=</span> <span class="n">nc</span>

                    <span class="n">nprim_drop</span> <span class="o">=</span> <span class="n">nprim_old</span> <span class="o">-</span> <span class="n">nprim</span> <span class="o">+</span> <span class="n">nprim_drop</span>
                    <span class="n">nctr_drop</span> <span class="o">=</span> <span class="n">nc_old</span> <span class="o">-</span> <span class="n">nc</span> <span class="o">+</span> <span class="n">nctr_drop</span>
                    <span class="k">if</span> <span class="n">cs</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">pe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bas</span><span class="p">[</span><span class="n">ib</span><span class="p">,</span><span class="n">mole</span><span class="o">.</span><span class="n">PTR_EXP</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="p">[</span><span class="n">pe</span><span class="p">:</span><span class="n">pe</span><span class="o">+</span><span class="n">nprim</span><span class="p">]</span> <span class="o">=</span> <span class="n">es</span>
                        <span class="n">cs</span> <span class="o">=</span> <span class="n">mole</span><span class="o">.</span><span class="n">_nomalize_contracted_ao</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">es</span><span class="p">,</span> <span class="n">cs</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="p">[</span><span class="n">ptr</span><span class="p">:</span><span class="n">ptr</span><span class="o">+</span><span class="n">nprim</span><span class="o">*</span><span class="n">nc</span><span class="p">]</span> <span class="o">=</span> <span class="n">cs</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">nprim</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">steep_shls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ib</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bas</span><span class="p">[</span><span class="n">steep_shls</span><span class="p">],</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;Discarded </span><span class="si">%d</span><span class="s1"> diffused primitive functions, &#39;</span>
                        <span class="s1">&#39;</span><span class="si">%d</span><span class="s1"> contracted functions&#39;</span><span class="p">,</span> <span class="n">nprim_drop</span><span class="p">,</span> <span class="n">nctr_drop</span><span class="p">)</span>
            <span class="c1">#logger.debug1(self, &#39;Old shells %s&#39;, steep_shls)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rcut</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rcut</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">bas_rcut</span><span class="p">(</span><span class="n">ib</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">precision</span><span class="p">)</span>
                             <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbas</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_vectors</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">_a</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;WARNING!</span>
<span class="s1">  Lattice are not in right-handed coordinate system. This can cause wrong value for some integrals.</span>
<span class="s1">  It&#39;s recommended to resort the lattice vectors to</span><span class="se">\n</span><span class="s1">a = </span><span class="si">%s</span><span class="se">\n\n</span><span class="s1">&#39;&#39;&#39;</span> <span class="o">%</span> <span class="n">_a</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ke_cutoff</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ke_cutoff</span> <span class="o">=</span> <span class="n">estimate_ke_cutoff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">precision</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ke_cutoff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ke_cutoff</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">pbctools</span><span class="o">.</span><span class="n">cutoff_to_mesh</span><span class="p">(</span><span class="n">_a</span><span class="p">,</span> <span class="n">ke_cutoff</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">low_dim_ft_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1">#prec ~ exp(-0.436392335*mesh -2.99944305)*nelec</span>
                <span class="n">meshz</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nelectron</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">precision</span><span class="p">)</span><span class="o">-</span><span class="mf">2.99944305</span><span class="p">)</span><span class="o">/</span><span class="mf">0.436392335</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">:]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">meshz</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">low_dim_ft_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ew_eta</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">ew_cut</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ew_eta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ew_cut</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ewald_params</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">precision</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dump_input</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">_built</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="n">logger</span><span class="o">.</span><span class="n">NOTE</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dump_input</span><span class="p">()</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;lattice vectors  a1 [</span><span class="si">%.9f</span><span class="s1">, </span><span class="si">%.9f</span><span class="s1">, </span><span class="si">%.9f</span><span class="s1">]&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">_a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;                 a2 [</span><span class="si">%.9f</span><span class="s1">, </span><span class="si">%.9f</span><span class="s1">, </span><span class="si">%.9f</span><span class="s1">]&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">_a</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;                 a3 [</span><span class="si">%.9f</span><span class="s1">, </span><span class="si">%.9f</span><span class="s1">, </span><span class="si">%.9f</span><span class="s1">]&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">_a</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;dimension = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;Cell volume = </span><span class="si">%g</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exp_to_discard</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;exp_to_discard = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exp_to_discard</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;rcut = </span><span class="si">%s</span><span class="s1"> (nimgs = </span><span class="si">%s</span><span class="s1">)&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rcut</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nimgs</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;lattice sum = </span><span class="si">%d</span><span class="s1"> cells&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_lattice_Ls</span><span class="p">()))</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;precision = </span><span class="si">%g</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">precision</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;pseudo = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudo</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ke_cutoff</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ke_cutoff = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">ke_cutoff</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;    = </span><span class="si">%s</span><span class="s1"> mesh (</span><span class="si">%d</span><span class="s1"> PWs)&#39;</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;mesh = </span><span class="si">%s</span><span class="s1"> (</span><span class="si">%d</span><span class="s1"> PWs)&#39;</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">))</span>
                <span class="n">Ecut</span> <span class="o">=</span> <span class="n">pbctools</span><span class="o">.</span><span class="n">mesh_to_cutoff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice_vectors</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;    = ke_cutoff </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">Ecut</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">])</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ew_eta = </span><span class="si">%g</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ew_eta</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ew_cut = </span><span class="si">%s</span><span class="s1"> (nimgs = </span><span class="si">%s</span><span class="s1">)&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ew_cut</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">get_bounding_sphere</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ew_cut</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span></div>
    <span class="n">kernel</span> <span class="o">=</span> <span class="n">build</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">h</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="nd">@h</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">h</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;cell.h is deprecated.  It is replaced by the &#39;</span>
                      <span class="s1">&#39;(row-based) lattice vectors cell.a:  cell.a = cell.h.T</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">unicode</span><span class="p">)):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;;&#39;</span><span class="p">,</span><span class="s1">&#39; &#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">,</span><span class="s1">&#39; &#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">()])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_h</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_vectors</span><span class="p">()</span><span class="o">.</span><span class="n">T</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice_vectors</span><span class="p">()))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">Gv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_Gv</span><span class="p">()</span>

    <span class="nd">@lib</span><span class="o">.</span><span class="n">with_doc</span><span class="p">(</span><span class="n">format_pseudo</span><span class="o">.</span><span class="n">__doc__</span><span class="p">)</span>
<div class="viewcode-block" id="Cell.format_pseudo"><a class="viewcode-back" href="../../../../pbc/gto.html#pyscf.pbc.gto.Cell.format_pseudo">[docs]</a>    <span class="k">def</span> <span class="nf">format_pseudo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pseudo_tab</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">format_pseudo</span><span class="p">(</span><span class="n">pseudo_tab</span><span class="p">)</span></div>

    <span class="nd">@lib</span><span class="o">.</span><span class="n">with_doc</span><span class="p">(</span><span class="n">format_basis</span><span class="o">.</span><span class="n">__doc__</span><span class="p">)</span>
<div class="viewcode-block" id="Cell.format_basis"><a class="viewcode-back" href="../../../../pbc/gto.html#pyscf.pbc.gto.Cell.format_basis">[docs]</a>    <span class="k">def</span> <span class="nf">format_basis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">basis_tab</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">format_basis</span><span class="p">(</span><span class="n">basis_tab</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">n</span><span class="o">//</span><span class="mi">2</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">]</span>
    <span class="nd">@gs</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">gs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;cell.gs is deprecated.  It is replaced by cell.mesh,&#39;</span>
                      <span class="s1">&#39;the number of PWs (=2*gs+1) along each direction.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nimgs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bounding_sphere</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rcut</span><span class="p">)</span>
    <span class="nd">@nimgs</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">nimgs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reciprocal_vectors</span><span class="p">(</span><span class="n">norm_to</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">heights_inv</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rcut</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="n">heights_inv</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbas</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">rcut_guess</span> <span class="o">=</span> <span class="n">_estimate_rcut</span><span class="p">(</span><span class="o">.</span><span class="mi">05</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">8</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rcut_guess</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">bas_rcut</span><span class="p">(</span><span class="n">ib</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">precision</span><span class="p">)</span>
                              <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbas</span><span class="p">)])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rcut</span> <span class="o">&gt;</span> <span class="n">rcut_guess</span><span class="o">*</span><span class="mf">1.5</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;.nimgs is a deprecated attribute.  It is replaced by .rcut &#39;</span>
                   <span class="s1">&#39;attribute for lattic sum cutoff radius.  The given nimgs &#39;</span>
                   <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> is far over the estimated cutoff radius </span><span class="si">%s</span><span class="s1">. &#39;</span> <span class="o">%</span>
                   <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">rcut_guess</span><span class="p">))</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">make_ecp_env</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_atm</span><span class="p">,</span> <span class="n">_ecp</span><span class="p">,</span> <span class="n">pre_env</span><span class="o">=</span><span class="p">[]):</span>
        <span class="k">if</span> <span class="n">_ecp</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pseudo</span><span class="p">:</span>
            <span class="n">conflicts</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pseudo</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">_ecp</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
            <span class="k">if</span> <span class="n">conflicts</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Pseudo potential for atoms </span><span class="si">%s</span><span class="s1"> are defined &#39;</span>
                                   <span class="s1">&#39;in both .ecp and .pseudo.&#39;</span> <span class="o">%</span> <span class="nb">list</span><span class="p">(</span><span class="n">conflicts</span><span class="p">))</span>

        <span class="n">_ecpbas</span><span class="p">,</span> <span class="n">_env</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">8</span><span class="p">)),</span> <span class="n">pre_env</span>
        <span class="k">if</span> <span class="n">_ecp</span><span class="p">:</span>
            <span class="n">_atm</span><span class="p">,</span> <span class="n">_ecpbas</span><span class="p">,</span> <span class="n">_env</span> <span class="o">=</span> <span class="n">mole</span><span class="o">.</span><span class="n">make_ecp_env</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_atm</span><span class="p">,</span> <span class="n">_ecp</span><span class="p">,</span> <span class="n">_env</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pseudo</span><span class="p">:</span>
            <span class="n">_atm</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_env</span> <span class="o">=</span> <span class="n">make_pseudo_env</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_atm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pseudo</span><span class="p">,</span> <span class="n">_env</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_atm</span><span class="p">,</span> <span class="n">_ecpbas</span><span class="p">,</span> <span class="n">_env</span>

<div class="viewcode-block" id="Cell.lattice_vectors"><a class="viewcode-back" href="../../../../pbc/gto.html#pyscf.pbc.gto.Cell.lattice_vectors">[docs]</a>    <span class="k">def</span> <span class="nf">lattice_vectors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Convert the primitive lattice vectors.</span>

<span class="sd">        Return 3x3 array in which each row represents one direction of the</span>
<span class="sd">        lattice vectors (unit in Bohr)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">unicode</span><span class="p">)):</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;;&#39;</span><span class="p">,</span><span class="s1">&#39; &#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">,</span><span class="s1">&#39; &#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">split</span><span class="p">()])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">unicode</span><span class="p">)):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">startswith</span><span class="p">((</span><span class="s1">&#39;B&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;au&#39;</span><span class="p">,</span><span class="s1">&#39;AU&#39;</span><span class="p">)):</span>
                <span class="k">return</span> <span class="n">a</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">a</span><span class="o">/</span><span class="n">param</span><span class="o">.</span><span class="n">BOHR</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">a</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span></div>

<div class="viewcode-block" id="Cell.reciprocal_vectors"><a class="viewcode-back" href="../../../../pbc/gto.html#pyscf.pbc.gto.Cell.reciprocal_vectors">[docs]</a>    <span class="k">def</span> <span class="nf">reciprocal_vectors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">norm_to</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">):</span>
        <span class="sd">r&#39;&#39;&#39;</span>
<span class="sd">        .. math::</span>

<span class="sd">            \begin{align}</span>
<span class="sd">            \mathbf{b_1} &amp;= 2\pi \frac{\mathbf{a_2} \times \mathbf{a_3}}{\mathbf{a_1} \cdot (\mathbf{a_2} \times \mathbf{a_3})} \\</span>
<span class="sd">            \mathbf{b_2} &amp;= 2\pi \frac{\mathbf{a_3} \times \mathbf{a_1}}{\mathbf{a_2} \cdot (\mathbf{a_3} \times \mathbf{a_1})} \\</span>
<span class="sd">            \mathbf{b_3} &amp;= 2\pi \frac{\mathbf{a_1} \times \mathbf{a_2}}{\mathbf{a_3} \cdot (\mathbf{a_1} \times \mathbf{a_2})}</span>
<span class="sd">            \end{align}</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_vectors</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">assert</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">9</span> <span class="ow">and</span>
                   <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">9</span> <span class="ow">and</span>
                   <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">9</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">assert</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">9</span> <span class="ow">and</span>
                   <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">9</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">norm_to</span> <span class="o">*</span> <span class="n">b</span></div>

<div class="viewcode-block" id="Cell.get_abs_kpts"><a class="viewcode-back" href="../../../../pbc/gto.html#pyscf.pbc.gto.Cell.get_abs_kpts">[docs]</a>    <span class="k">def</span> <span class="nf">get_abs_kpts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scaled_kpts</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Get absolute k-points (in 1/Bohr), given &quot;scaled&quot; k-points in</span>
<span class="sd">        fractions of lattice vectors.</span>

<span class="sd">        Args:</span>
<span class="sd">            scaled_kpts : (nkpts, 3) ndarray of floats</span>

<span class="sd">        Returns:</span>
<span class="sd">            abs_kpts : (nkpts, 3) ndarray of floats </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">scaled_kpts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">reciprocal_vectors</span><span class="p">())</span></div>

<div class="viewcode-block" id="Cell.get_scaled_kpts"><a class="viewcode-back" href="../../../../pbc/gto.html#pyscf.pbc.gto.Cell.get_scaled_kpts">[docs]</a>    <span class="k">def</span> <span class="nf">get_scaled_kpts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">abs_kpts</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Get scaled k-points, given absolute k-points in 1/Bohr.</span>

<span class="sd">        Args:</span>
<span class="sd">            abs_kpts : (nkpts, 3) ndarray of floats </span>

<span class="sd">        Returns:</span>
<span class="sd">            scaled_kpts : (nkpts, 3) ndarray of floats</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">abs_kpts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_vectors</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="p">)</span></div>

    <span class="n">make_kpts</span> <span class="o">=</span> <span class="n">make_kpts</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="n">pack</span> <span class="o">=</span> <span class="n">pack</span>
    <span class="nd">@lib</span><span class="o">.</span><span class="n">with_doc</span><span class="p">(</span><span class="n">unpack</span><span class="o">.</span><span class="n">__doc__</span><span class="p">)</span>
<div class="viewcode-block" id="Cell.unpack"><a class="viewcode-back" href="../../../../pbc/gto.html#pyscf.pbc.gto.Cell.unpack">[docs]</a>    <span class="k">def</span> <span class="nf">unpack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">moldic</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">unpack</span><span class="p">(</span><span class="n">moldic</span><span class="p">)</span></div>
    <span class="k">def</span> <span class="nf">unpack_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">moldic</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">moldic</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="n">dumps</span> <span class="o">=</span> <span class="n">dumps</span>
    <span class="nd">@lib</span><span class="o">.</span><span class="n">with_doc</span><span class="p">(</span><span class="n">loads</span><span class="o">.</span><span class="n">__doc__</span><span class="p">)</span>
<div class="viewcode-block" id="Cell.loads"><a class="viewcode-back" href="../../../../pbc/gto.html#pyscf.pbc.gto.Cell.loads">[docs]</a>    <span class="k">def</span> <span class="nf">loads</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">molstr</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">loads</span><span class="p">(</span><span class="n">molstr</span><span class="p">)</span></div>
    <span class="k">def</span> <span class="nf">loads_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">molstr</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">loads</span><span class="p">(</span><span class="n">molstr</span><span class="p">)</span><span class="o">.</span><span class="n">__dict__</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="n">bas_rcut</span> <span class="o">=</span> <span class="n">bas_rcut</span>

    <span class="n">get_lattice_Ls</span> <span class="o">=</span> <span class="n">pbctools</span><span class="o">.</span><span class="n">get_lattice_Ls</span>

    <span class="n">get_nimgs</span> <span class="o">=</span> <span class="n">get_nimgs</span>

    <span class="n">get_ewald_params</span> <span class="o">=</span> <span class="n">get_ewald_params</span>

    <span class="n">get_bounding_sphere</span> <span class="o">=</span> <span class="n">get_bounding_sphere</span>

    <span class="n">get_Gv</span> <span class="o">=</span> <span class="n">get_Gv</span>
    <span class="n">get_Gv_weights</span> <span class="o">=</span> <span class="n">get_Gv_weights</span>

    <span class="n">get_SI</span> <span class="o">=</span> <span class="n">get_SI</span>

    <span class="n">ewald</span> <span class="o">=</span> <span class="n">ewald</span>
    <span class="n">energy_nuc</span> <span class="o">=</span> <span class="n">ewald</span>

    <span class="n">gen_uniform_grids</span> <span class="o">=</span> <span class="n">get_uniform_grids</span> <span class="o">=</span> <span class="n">get_uniform_grids</span>

    <span class="n">__add__</span> <span class="o">=</span> <span class="n">conc_cell</span>

<div class="viewcode-block" id="Cell.pbc_intor"><a class="viewcode-back" href="../../../../pbc/gto.html#pyscf.pbc.gto.Cell.pbc_intor">[docs]</a>    <span class="k">def</span> <span class="nf">pbc_intor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intor</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">kpts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kpt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">r&#39;&#39;&#39;One-electron integrals with PBC.</span>

<span class="sd">        .. math::</span>

<span class="sd">            \sum_T \int \mu(r) * [intor] * \nu (r-T) dr</span>

<span class="sd">        See also Mole.intor</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">intor_cross</span><span class="p">(</span><span class="n">intor</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">comp</span><span class="p">,</span> <span class="n">hermi</span><span class="p">,</span> <span class="n">kpts</span><span class="p">,</span> <span class="n">kpt</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="nd">@lib</span><span class="o">.</span><span class="n">with_doc</span><span class="p">(</span><span class="n">pbc_eval_gto</span><span class="o">.</span><span class="n">__doc__</span><span class="p">)</span>
<div class="viewcode-block" id="Cell.pbc_eval_gto"><a class="viewcode-back" href="../../../../pbc/gto.html#pyscf.pbc.gto.Cell.pbc_eval_gto">[docs]</a>    <span class="k">def</span> <span class="nf">pbc_eval_gto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eval_name</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kpts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kpt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">shls_slice</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">non0tab</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ao_loc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">pbc_eval_gto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eval_name</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">comp</span><span class="p">,</span> <span class="n">kpts</span><span class="p">,</span> <span class="n">kpt</span><span class="p">,</span>
                            <span class="n">shls_slice</span><span class="p">,</span> <span class="n">non0tab</span><span class="p">,</span> <span class="n">ao_loc</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span></div>

    <span class="nd">@lib</span><span class="o">.</span><span class="n">with_doc</span><span class="p">(</span><span class="n">pbc_eval_gto</span><span class="o">.</span><span class="n">__doc__</span><span class="p">)</span>
<div class="viewcode-block" id="Cell.eval_gto"><a class="viewcode-back" href="../../../../pbc/gto.html#pyscf.pbc.gto.Cell.eval_gto">[docs]</a>    <span class="k">def</span> <span class="nf">eval_gto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eval_name</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kpts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kpt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">shls_slice</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">non0tab</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ao_loc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">eval_name</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;PBC&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbc_eval_gto</span><span class="p">(</span><span class="n">eval_name</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">comp</span><span class="p">,</span> <span class="n">kpts</span><span class="p">,</span> <span class="n">kpt</span><span class="p">,</span>
                                     <span class="n">shls_slice</span><span class="p">,</span> <span class="n">non0tab</span><span class="p">,</span> <span class="n">ao_loc</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mole</span><span class="o">.</span><span class="n">eval_gto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eval_name</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">comp</span><span class="p">,</span>
                                 <span class="n">shls_slice</span><span class="p">,</span> <span class="n">non0tab</span><span class="p">,</span> <span class="n">ao_loc</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cell.from_ase"><a class="viewcode-back" href="../../../../pbc/gto.html#pyscf.pbc.gto.Cell.from_ase">[docs]</a>    <span class="k">def</span> <span class="nf">from_ase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ase_atom</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Update cell based on given ase atom object</span>

<span class="sd">        Examples:</span>

<span class="sd">        &gt;&gt;&gt; from ase.lattice import bulk</span>
<span class="sd">        &gt;&gt;&gt; cell.from_ase(bulk(&#39;C&#39;, &#39;diamond&#39;, a=LATTICE_CONST))</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">pyscf.pbc.tools</span> <span class="k">import</span> <span class="n">pyscf_ase</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">ase_atom</span><span class="o">.</span><span class="n">cell</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atom</span> <span class="o">=</span> <span class="n">pyscf_ase</span><span class="o">.</span><span class="n">ase_atoms_to_pyscf</span><span class="p">(</span><span class="n">ase_atom</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Cell.to_mol"><a class="viewcode-back" href="../../../../pbc/gto.html#pyscf.pbc.gto.Cell.to_mol">[docs]</a>    <span class="k">def</span> <span class="nf">to_mol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Return a Mole object using the same atoms and basis functions as</span>
<span class="sd">        the Cell object.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">mol</span> <span class="o">=</span> <span class="n">mole</span><span class="o">.</span><span class="n">Mole</span><span class="p">()</span>
        <span class="n">cell_dic</span> <span class="o">=</span> <span class="p">[(</span><span class="n">key</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>
        <span class="n">mol</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cell_dic</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mol</span></div>

<div class="viewcode-block" id="Cell.has_ecp"><a class="viewcode-back" href="../../../../pbc/gto.html#pyscf.pbc.gto.Cell.has_ecp">[docs]</a>    <span class="k">def</span> <span class="nf">has_ecp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Whether pesudo potential is used in the system.&#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudo</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pseudo</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ecpbas</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span></div></div>

<span class="k">del</span><span class="p">(</span><span class="n">INTEGRAL_PRECISION</span><span class="p">,</span> <span class="n">WRAP_AROUND</span><span class="p">,</span> <span class="n">WITH_GAMMA</span><span class="p">,</span> <span class="n">EXP_DELIMITER</span><span class="p">)</span>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015-, Qiming Sun &lt;osirpt.sun@gmail.com&gt;.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../../',
            VERSION:'1.5.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: ''
        };
    </script>
      <script type="text/javascript" src="../../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>