

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>lib — Helper functions, parameters, and C extensions &mdash; PySCF 1.4.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="PySCF 1.4.0 documentation" href="index.html"/>
        <link rel="next" title="scf — Mean-field methods" href="scf.html"/>
        <link rel="prev" title="gto — Molecular structure and GTO basis" href="gto.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> PySCF
          

          
          </a>

          
            
            
              <div class="version">
                1.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">An overview of PySCF</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="gto.html">gto &#8212; Molecular structure and GTO basis</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">lib &#8212; Helper functions, parameters, and C extensions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#parameters">parameters</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#scratch-directory">Scratch directory</a></li>
<li class="toctree-l3"><a class="reference internal" href="#maximum-memory">Maximum memory</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-pyscf.lib.logger">logger</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#logging-system">Logging system</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#log-level">Log level</a></li>
<li class="toctree-l4"><a class="reference internal" href="#timer">timer</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-pyscf.lib.numpy_helper">numpy helper</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-pyscf.lib.chkfile">chkfile</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#fast-load">Fast load</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="scf.html">scf &#8212; Mean-field methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="ao2mo.html">ao2mo &#8212; Integral transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="mcscf.html">mcscf &#8212; Multi-configurational self-consistent field</a></li>
<li class="toctree-l1"><a class="reference internal" href="fci.html">fci &#8212; Full configuration interaction</a></li>
<li class="toctree-l1"><a class="reference internal" href="symm.html">symm &#8211; Point group symmetry and spin symmetry</a></li>
<li class="toctree-l1"><a class="reference internal" href="df.html">df &#8212; Density fitting</a></li>
<li class="toctree-l1"><a class="reference internal" href="dft.html">dft &#8212; Density functional theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="tddft.html">tddft &#8212; Time dependent density functional theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="cc.html">cc &#8212; Coupled cluster</a></li>
<li class="toctree-l1"><a class="reference internal" href="ci.html">ci &#8212; Configuration interaction</a></li>
<li class="toctree-l1"><a class="reference internal" href="dmrgscf.html">dmrgscf</a></li>
<li class="toctree-l1"><a class="reference internal" href="fciqmcscf.html">fciqmcscf</a></li>
<li class="toctree-l1"><a class="reference internal" href="tools.html">tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="grad.html">grad &#8212; Analytical nuclear gradients</a></li>
<li class="toctree-l1"><a class="reference internal" href="hessian.html">hessian &#8212; Analytical nuclear Hessian</a></li>
<li class="toctree-l1"><a class="reference internal" href="pbc.html">pbc &#8212; Periodic boundary conditions</a></li>
<li class="toctree-l1"><a class="reference internal" href="lo.html">lo &#8212; Orbital localization</a></li>
<li class="toctree-l1"><a class="reference internal" href="advanced.html">Miscellaneous</a></li>
<li class="toctree-l1"><a class="reference internal" href="qmmm.html">qmmm &#8212; QM/MM interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="mrpt.html">mrpt &#8212; Multi-reference perturbation theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="benchmark.html">Benchmark</a></li>
<li class="toctree-l1"><a class="reference internal" href="code-rule.html">Code standard</a></li>
<li class="toctree-l1"><a class="reference internal" href="version.html">Version history</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">PySCF</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>lib &#8212; Helper functions, parameters, and C extensions</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/lib.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-pyscf.lib">
<span id="lib-helper-functions-parameters-and-c-extensions"></span><h1>lib &#8212; Helper functions, parameters, and C extensions<a class="headerlink" href="#module-pyscf.lib" title="Permalink to this headline">¶</a></h1>
<p>C code and some fundamental functions</p>
<div class="section" id="parameters">
<h2>parameters<a class="headerlink" href="#parameters" title="Permalink to this headline">¶</a></h2>
<p>Some PySCF environment parameters are defined in this module.</p>
<div class="section" id="scratch-directory">
<h3>Scratch directory<a class="headerlink" href="#scratch-directory" title="Permalink to this headline">¶</a></h3>
<p>The PySCF scratch directory is specified by <code class="xref py py-data docutils literal"><span class="pre">TMPDIR</span></code>.  Its default value
is the same to the system environment variable <code class="docutils literal"><span class="pre">TMPDIR</span></code>.  It can be
overwritten by the system environment variable <code class="docutils literal"><span class="pre">PYSCF_TMPDIR</span></code>.</p>
</div>
<div class="section" id="maximum-memory">
<span id="max-mem"></span><h3>Maximum memory<a class="headerlink" href="#maximum-memory" title="Permalink to this headline">¶</a></h3>
<p>The variable <code class="xref py py-data docutils literal"><span class="pre">MAX_MEMORY</span></code> defines the maximum memory that PySCF can be
used in the calculation.  Its unit is MB.  The default value is 4000 MB.  It can
be overwritten by the system environment variable <code class="docutils literal"><span class="pre">PYSCF_MAX_MEMORY</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Some calculations may exceed the max_memory limit, especially
when the attribute <code class="xref py py-attr docutils literal"><span class="pre">Mole.incore_anyway</span></code> was set.</p>
</div>
<span class="target" id="module-pyscf.lib.parameters"></span></div>
</div>
<div class="section" id="module-pyscf.lib.logger">
<span id="logger"></span><h2>logger<a class="headerlink" href="#module-pyscf.lib.logger" title="Permalink to this headline">¶</a></h2>
<div class="section" id="logging-system">
<h3>Logging system<a class="headerlink" href="#logging-system" title="Permalink to this headline">¶</a></h3>
<div class="section" id="log-level">
<h4>Log level<a class="headerlink" href="#log-level" title="Permalink to this headline">¶</a></h4>
<table border="1" class="docutils">
<colgroup>
<col width="54%" />
<col width="46%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Level</td>
<td>number</td>
</tr>
<tr class="row-even"><td>DEBUG4</td>
<td>9</td>
</tr>
<tr class="row-odd"><td>DEBUG3</td>
<td>8</td>
</tr>
<tr class="row-even"><td>DEBUG2</td>
<td>7</td>
</tr>
<tr class="row-odd"><td>DEBUG1</td>
<td>6</td>
</tr>
<tr class="row-even"><td>DEBUG</td>
<td>5</td>
</tr>
<tr class="row-odd"><td>INFO</td>
<td>4</td>
</tr>
<tr class="row-even"><td>NOTE</td>
<td>3</td>
</tr>
<tr class="row-odd"><td>WARN</td>
<td>2</td>
</tr>
<tr class="row-even"><td>ERROR</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>QUIET</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>Big <code class="docutils literal"><span class="pre">verbose</span></code> value means more noise in the output file.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">At log level 1 (ERROR) and 2 (WARN), the messages are also output to stderr.</p>
</div>
<p>Each Logger object has its own output destination and verbose level.  So
multiple Logger objects can be created to manage the message system without
affecting each other.
The methods provided by Logger class has the direct connection to the log level.
E.g.  <code class="xref py py-func docutils literal"><span class="pre">info()</span></code> print messages if the verbose level &gt;= 4 (INFO):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">lib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">log</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">Logger</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;info level&#39;</span><span class="p">)</span>
<span class="go">info level</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">log</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;info level&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">log</span><span class="o">.</span><span class="n">note</span><span class="p">(</span><span class="s1">&#39;note level&#39;</span><span class="p">)</span>
<span class="go">note level</span>
</pre></div>
</div>
</div>
<div class="section" id="timer">
<h4>timer<a class="headerlink" href="#timer" title="Permalink to this headline">¶</a></h4>
<p>Logger object provides timer method for timing.  Set <code class="xref py py-attr docutils literal"><span class="pre">TIMER_LEVEL</span></code> to
control which level to output the timing.  It is 5 (DEBUG) by default.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">time</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">lib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">log</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">Logger</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">log</span><span class="o">.</span><span class="n">timer</span><span class="p">(</span><span class="s1">&#39;test&#39;</span><span class="p">,</span> <span class="n">t0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lib</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">TIMER_LEVEL</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">log</span><span class="o">.</span><span class="n">timer</span><span class="p">(</span><span class="s1">&#39;test&#39;</span><span class="p">,</span> <span class="n">t0</span><span class="p">)</span>
<span class="go">    CPU time for test      0.00 sec</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="module-pyscf.lib.numpy_helper">
<span id="numpy-helper"></span><h2>numpy helper<a class="headerlink" href="#module-pyscf.lib.numpy_helper" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pyscf.lib.numpy_helper.asarray">
<code class="descclassname">pyscf.lib.numpy_helper.</code><code class="descname">asarray</code><span class="sig-paren">(</span><em>a</em>, <em>dtype=None</em>, <em>order=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/lib/numpy_helper.html#asarray"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.numpy_helper.asarray" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a list of N-dim arrays to a (N+1) dim array.  It is equivalent to
numpy.asarray function but more efficient.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.numpy_helper.cartesian_prod">
<code class="descclassname">pyscf.lib.numpy_helper.</code><code class="descname">cartesian_prod</code><span class="sig-paren">(</span><em>arrays</em>, <em>out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/lib/numpy_helper.html#cartesian_prod"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.numpy_helper.cartesian_prod" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a cartesian product of input arrays.
<a class="reference external" href="http://stackoverflow.com/questions/1208118/using-numpy-to-build-an-array-of-all-combinations-of-two-arrays">http://stackoverflow.com/questions/1208118/using-numpy-to-build-an-array-of-all-combinations-of-two-arrays</a></p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>arrays</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">list of array-like</span><dd>1-D arrays to form the cartesian product of.</dd>
<dt>out</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>Array to place the cartesian product in.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>out</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>2-D array of shape (M, len(arrays)) containing cartesian products
formed of input arrays.</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cartesian_prod</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]))</span>
<span class="go">array([[1, 4, 6],</span>
<span class="go">       [1, 4, 7],</span>
<span class="go">       [1, 5, 6],</span>
<span class="go">       [1, 5, 7],</span>
<span class="go">       [2, 4, 6],</span>
<span class="go">       [2, 4, 7],</span>
<span class="go">       [2, 5, 6],</span>
<span class="go">       [2, 5, 7],</span>
<span class="go">       [3, 4, 6],</span>
<span class="go">       [3, 4, 7],</span>
<span class="go">       [3, 5, 6],</span>
<span class="go">       [3, 5, 7]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.numpy_helper.cond">
<code class="descclassname">pyscf.lib.numpy_helper.</code><code class="descname">cond</code><span class="sig-paren">(</span><em>x</em>, <em>p=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/lib/numpy_helper.html#cond"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.numpy_helper.cond" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the condition number</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.numpy_helper.condense">
<code class="descclassname">pyscf.lib.numpy_helper.</code><code class="descname">condense</code><span class="sig-paren">(</span><em>opname</em>, <em>a</em>, <em>locs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/lib/numpy_helper.html#condense"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.numpy_helper.condense" title="Permalink to this definition">¶</a></dt>
<dd><div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">nd</span> <span class="o">=</span> <span class="n">loc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nd</span><span class="p">,</span><span class="n">nd</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">i0</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">loc</span><span class="p">):</span>
    <span class="n">i1</span> <span class="o">=</span> <span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">j0</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">loc</span><span class="p">):</span>
        <span class="n">j1</span> <span class="o">=</span> <span class="n">loc</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="n">i1</span><span class="p">,</span><span class="n">j0</span><span class="p">:</span><span class="n">j1</span><span class="p">])</span>
<span class="k">return</span> <span class="n">out</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.numpy_helper.ddot">
<code class="descclassname">pyscf.lib.numpy_helper.</code><code class="descname">ddot</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>alpha=1</em>, <em>c=None</em>, <em>beta=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/lib/numpy_helper.html#ddot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.numpy_helper.ddot" title="Permalink to this definition">¶</a></dt>
<dd><p>Matrix-matrix multiplication for double precision arrays</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.numpy_helper.direct_sum">
<code class="descclassname">pyscf.lib.numpy_helper.</code><code class="descname">direct_sum</code><span class="sig-paren">(</span><em>subscripts</em>, <em>*operands</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/lib/numpy_helper.html#direct_sum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.numpy_helper.direct_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the summation over many operands with the einsum fashion.</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">direct_sum</span><span class="p">(</span><span class="s1">&#39;ij,klm-&gt;ijklm&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(6, 5, 4, 3, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">direct_sum</span><span class="p">(</span><span class="s1">&#39;ij,klm&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(6, 5, 4, 3, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">direct_sum</span><span class="p">(</span><span class="s1">&#39;i,j,klm-&gt;mjlik&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 6, 3, 5, 4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">direct_sum</span><span class="p">(</span><span class="s1">&#39;ij-klm-&gt;ijklm&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(6, 5, 4, 3, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">direct_sum</span><span class="p">(</span><span class="s1">&#39;ij+klm&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(6, 5, 4, 3, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">direct_sum</span><span class="p">(</span><span class="s1">&#39;-i-j+klm-&gt;mjlik&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 6, 3, 5, 4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">direct_sum</span><span class="p">(</span><span class="s1">&#39;ik+jk-&gt;kij&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>  <span class="c1"># This is slow</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="go">0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.numpy_helper.einsum">
<code class="descclassname">pyscf.lib.numpy_helper.</code><code class="descname">einsum</code><span class="sig-paren">(</span><em>idx_str</em>, <em>*tensors</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/lib/numpy_helper.html#einsum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.numpy_helper.einsum" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a more efficient einsum via reshaping to a matrix multiply.</p>
<p>Current differences compared to numpy.einsum:
This assumes that each repeated index is actually summed (i.e. no &#8216;i,i-&gt;i&#8217;)
and appears only twice (i.e. no &#8216;ij,ik,il-&gt;jkl&#8217;). The output indices must
be explicitly specified (i.e. &#8216;ij,j-&gt;i&#8217; and not &#8216;ij,j&#8217;).</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.numpy_helper.hermi_sum">
<code class="descclassname">pyscf.lib.numpy_helper.</code><code class="descname">hermi_sum</code><span class="sig-paren">(</span><em>a</em>, <em>axes=None</em>, <em>hermi=1</em>, <em>inplace=False</em>, <em>out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/lib/numpy_helper.html#hermi_sum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.numpy_helper.hermi_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>a + a.T for better memory efficiency</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">transpose_sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">4.</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="go">[[ 0.  3.]</span>
<span class="go"> [ 3.  6.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.numpy_helper.hermi_triu">
<code class="descclassname">pyscf.lib.numpy_helper.</code><code class="descname">hermi_triu</code><span class="sig-paren">(</span><em>mat</em>, <em>hermi=1</em>, <em>inplace=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/lib/numpy_helper.html#hermi_triu"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.numpy_helper.hermi_triu" title="Permalink to this definition">¶</a></dt>
<dd><p>Use the elements of the lower triangular part to fill the upper triangular part.</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><p class="first">filltriu : int</p>
<blockquote class="last">
<div><div class="line-block">
<div class="line">1 (default) return a hermitian matrix</div>
<div class="line">2           return an anti-hermitian matrix</div>
</div>
</div></blockquote>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">unpack_row</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">9.</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">[[ 0.  3.  6.]</span>
<span class="go"> [ 3.  4.  7.]</span>
<span class="go"> [ 6.  7.  8.]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unpack_row</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">9.</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">[[ 0. -3. -6.]</span>
<span class="go"> [ 3.  4. -7.]</span>
<span class="go"> [ 6.  7.  8.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.numpy_helper.norm">
<code class="descclassname">pyscf.lib.numpy_helper.</code><code class="descname">norm</code><span class="sig-paren">(</span><em>x</em>, <em>ord=None</em>, <em>axis=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/lib/numpy_helper.html#norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.numpy_helper.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>numpy.linalg.norm for numpy 1.6.*</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.numpy_helper.pack_tril">
<code class="descclassname">pyscf.lib.numpy_helper.</code><code class="descname">pack_tril</code><span class="sig-paren">(</span><em>mat</em>, <em>axis=-1</em>, <em>out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/lib/numpy_helper.html#pack_tril"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.numpy_helper.pack_tril" title="Permalink to this definition">¶</a></dt>
<dd><p>flatten the lower triangular part of a matrix.
Given mat, it returns mat[...,numpy.tril_indices(mat.shape[0])]</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pack_tril</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="go">[0 3 4 6 7 8]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.numpy_helper.solve_lineq_by_SVD">
<code class="descclassname">pyscf.lib.numpy_helper.</code><code class="descname">solve_lineq_by_SVD</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/lib/numpy_helper.html#solve_lineq_by_SVD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.numpy_helper.solve_lineq_by_SVD" title="Permalink to this definition">¶</a></dt>
<dd><p>a * x = b</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.numpy_helper.take_2d">
<code class="descclassname">pyscf.lib.numpy_helper.</code><code class="descname">take_2d</code><span class="sig-paren">(</span><em>a</em>, <em>idx</em>, <em>idy</em>, <em>out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/lib/numpy_helper.html#take_2d"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.numpy_helper.take_2d" title="Permalink to this definition">¶</a></dt>
<dd><p>a(idx,idy)</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">9.</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">take_2d</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">[[ 0.  2.]</span>
<span class="go"> [ 6.  8.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.numpy_helper.takebak_2d">
<code class="descclassname">pyscf.lib.numpy_helper.</code><code class="descname">takebak_2d</code><span class="sig-paren">(</span><em>out</em>, <em>a</em>, <em>idx</em>, <em>idy</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/lib/numpy_helper.html#takebak_2d"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.numpy_helper.takebak_2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse operation of take_2d.  out(idx,idy) += a</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">takebak_2d</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)),</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">[[ 1.  0.  1.]</span>
<span class="go"> [ 0.  0.  0.]</span>
<span class="go"> [ 1.  0.  1.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.numpy_helper.transpose">
<code class="descclassname">pyscf.lib.numpy_helper.</code><code class="descname">transpose</code><span class="sig-paren">(</span><em>a</em>, <em>axes=None</em>, <em>inplace=False</em>, <em>out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/lib/numpy_helper.html#transpose"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.numpy_helper.transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Transpose array for better memory efficiency</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">transpose</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
<span class="go">[[ 1.  1.  1.]</span>
<span class="go"> [ 1.  1.  1.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.numpy_helper.transpose_sum">
<code class="descclassname">pyscf.lib.numpy_helper.</code><code class="descname">transpose_sum</code><span class="sig-paren">(</span><em>a</em>, <em>inplace=False</em>, <em>out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/lib/numpy_helper.html#transpose_sum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.numpy_helper.transpose_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>a + a.T for better memory efficiency</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">transpose_sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">4.</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="go">[[ 0.  3.]</span>
<span class="go"> [ 3.  6.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.numpy_helper.unpack_row">
<code class="descclassname">pyscf.lib.numpy_helper.</code><code class="descname">unpack_row</code><span class="sig-paren">(</span><em>tril</em>, <em>row_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/lib/numpy_helper.html#unpack_row"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.numpy_helper.unpack_row" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract one row of the lower triangular part of a matrix.
It is equivalent to unpack_tril(a)[row_id]</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">unpack_row</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">6.</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">[ 0. 1. 3.]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unpack_tril</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">6.</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[ 0. 1. 3.]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.numpy_helper.unpack_tril">
<code class="descclassname">pyscf.lib.numpy_helper.</code><code class="descname">unpack_tril</code><span class="sig-paren">(</span><em>tril</em>, <em>filltriu=1</em>, <em>axis=-1</em>, <em>out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/lib/numpy_helper.html#unpack_tril"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.numpy_helper.unpack_tril" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse operation of pack_tril.</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><p class="first">filltriu : int</p>
<blockquote class="last">
<div><div class="line-block">
<div class="line">0           Do not fill the upper triangular part, random number may appear
in the upper triangular part</div>
<div class="line">1 (default) Transpose the lower triangular part to fill the upper triangular part</div>
<div class="line">2           Similar to filltriu=1, negative of the lower triangular part is assign
to the upper triangular part to make the matrix anti-hermitian</div>
</div>
</div></blockquote>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">unpack_tril</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">6.</span><span class="p">))</span>
<span class="go">[[ 0. 1. 3.]</span>
<span class="go"> [ 1. 2. 4.]</span>
<span class="go"> [ 3. 4. 5.]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unpack_tril</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">6.</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">[[ 0. 0. 0.]</span>
<span class="go"> [ 1. 2. 0.]</span>
<span class="go"> [ 3. 4. 5.]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unpack_tril</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">6.</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">[[ 0. -1. -3.]</span>
<span class="go"> [ 1.  2. -4.]</span>
<span class="go"> [ 3.  4.  5.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.numpy_helper.zdot">
<code class="descclassname">pyscf.lib.numpy_helper.</code><code class="descname">zdot</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>alpha=1</em>, <em>c=None</em>, <em>beta=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/lib/numpy_helper.html#zdot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.numpy_helper.zdot" title="Permalink to this definition">¶</a></dt>
<dd><p>Matrix-matrix multiplication for double complex arrays using Gauss&#8217;s
complex multiplication algorithm</p>
</dd></dl>

<span class="target" id="module-pyscf.lib.linalg_helper"></span><p>Extension to scipy.linalg module</p>
<dl class="function">
<dt id="pyscf.lib.linalg_helper.cho_solve">
<code class="descclassname">pyscf.lib.linalg_helper.</code><code class="descname">cho_solve</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/lib/linalg_helper.html#cho_solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.linalg_helper.cho_solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve ax = b, where a is hermitian matrix</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.linalg_helper.davidson">
<code class="descclassname">pyscf.lib.linalg_helper.</code><code class="descname">davidson</code><span class="sig-paren">(</span><em>aop</em>, <em>x0</em>, <em>precond</em>, <em>tol=1e-12</em>, <em>max_cycle=50</em>, <em>max_space=12</em>, <em>lindep=1e-14</em>, <em>max_memory=2000</em>, <em>dot=&lt;built-in function dot&gt;</em>, <em>callback=None</em>, <em>nroots=1</em>, <em>lessio=False</em>, <em>verbose=2</em>, <em>follow_state=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/lib/linalg_helper.html#davidson"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.linalg_helper.davidson" title="Permalink to this definition">¶</a></dt>
<dd><p>Davidson diagonalization method to solve  a c = e c.  Ref
[1] E.R. Davidson, J. Comput. Phys. 17 (1), 87-94 (1975).
[2] <a class="reference external" href="http://people.inf.ethz.ch/arbenz/ewp/Lnotes/chapter11.pdf">http://people.inf.ethz.ch/arbenz/ewp/Lnotes/chapter11.pdf</a></p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>aop</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(x) =&gt; array_like_x</span><dd>aop(x) to mimic the matrix vector multiplication <span class="math">\(\sum_{j}a_{ij}*x_j\)</span>.
The argument is a 1D array.  The returned value is a 1D array.</dd>
<dt>x0</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">1D array or a list of 1D array</span><dd>Initial guess.  The initial guess vector(s) are just used as the
initial subspace bases.  If the subspace is smaller than &#8220;nroots&#8221;,
eg 10 roots and one initial guess, all eigenvectors are chosen as
the eigenvectors during the iterations.  The first iteration has
one eigenvector, the next iteration has two, the third iterastion
has 4, ..., until the subspace size &gt; nroots.</dd>
<dt>precond</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(dx, e, x0) =&gt; array_like_dx</span><dd>Preconditioner to generate new trial vector.
The argument dx is a residual vector <code class="docutils literal"><span class="pre">a*x0-e*x0</span></code>; e is the current
eigenvalue; x0 is the current eigenvector.</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Convergence tolerance.</dd>
<dt>max_cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>max number of iterations.</dd>
<dt>max_space</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>space size to hold trial vectors.</dd>
<dt>lindep</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Linear dependency threshold.  The function is terminated when the
smallest eigenvalue of the metric of the trial vectors is lower
than this threshold.</dd>
<dt>max_memory</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int or float</span><dd>Allowed memory in MB.</dd>
<dt>dot</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(x, y) =&gt; scalar</span><dd>Inner product</dd>
<dt>callback</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(envs_dict) =&gt; None</span><dd>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
envrionment.</dd>
<dt>nroots</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Number of eigenvalues to be computed.  When nroots &gt; 1, it affects
the shape of the return value</dd>
<dt>lessio</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>How to compute a*x0 for current eigenvector x0.  There are two
ways to compute a*x0.  One is to assemble the existed a*x.  The
other is to call aop(x0).  The default is the first method which
needs more IO and less computational cost.  When IO is slow, the
second method can be considered.</dd>
<dt>follow_state</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>If the solution dramatically changes in two iterations, clean the
subspace and restart the iteration with the old solution.  It can
help to improve numerical stability.  Default is False.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>e</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float or list of floats</span><dd>Eigenvalue.  By default it&#8217;s one float number.  If <code class="xref py py-attr docutils literal"><span class="pre">nroots</span></code> &gt; 1, it
is a list of floats for the lowest <code class="xref py py-attr docutils literal"><span class="pre">nroots</span></code> eigenvalues.</dd>
<dt>c</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">1D array or list of 1D arrays</span><dd>Eigenvector.  By default it&#8217;s a 1D array.  If <code class="xref py py-attr docutils literal"><span class="pre">nroots</span></code> &gt; 1, it
is a list of arrays for the lowest <code class="xref py py-attr docutils literal"><span class="pre">nroots</span></code> eigenvectors.</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">lib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">a</span><span class="o">.</span><span class="n">T</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aop</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">precond</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">dx</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">x0</span><span class="p">:</span> <span class="n">dx</span><span class="o">/</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span><span class="o">-</span><span class="n">e</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x0</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">davidson</span><span class="p">(</span><span class="n">aop</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">precond</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.linalg_helper.davidson1">
<code class="descclassname">pyscf.lib.linalg_helper.</code><code class="descname">davidson1</code><span class="sig-paren">(</span><em>aop</em>, <em>x0</em>, <em>precond</em>, <em>tol=1e-12</em>, <em>max_cycle=50</em>, <em>max_space=12</em>, <em>lindep=1e-14</em>, <em>max_memory=2000</em>, <em>dot=&lt;built-in function dot&gt;</em>, <em>callback=None</em>, <em>nroots=1</em>, <em>lessio=False</em>, <em>verbose=2</em>, <em>follow_state=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/lib/linalg_helper.html#davidson1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.linalg_helper.davidson1" title="Permalink to this definition">¶</a></dt>
<dd><p>Davidson diagonalization method to solve  a c = e c.  Ref
[1] E.R. Davidson, J. Comput. Phys. 17 (1), 87-94 (1975).
[2] <a class="reference external" href="http://people.inf.ethz.ch/arbenz/ewp/Lnotes/chapter11.pdf">http://people.inf.ethz.ch/arbenz/ewp/Lnotes/chapter11.pdf</a></p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>aop</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function([x]) =&gt; [array_like_x]</span><dd>Matrix vector multiplication <span class="math">\(y_{ki} = \sum_{j}a_{ij}*x_{jk}\)</span>.</dd>
<dt>x0</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">1D array or a list of 1D array</span><dd>Initial guess.  The initial guess vector(s) are just used as the
initial subspace bases.  If the subspace is smaller than &#8220;nroots&#8221;,
eg 10 roots and one initial guess, all eigenvectors are chosen as
the eigenvectors during the iterations.  The first iteration has
one eigenvector, the next iteration has two, the third iterastion
has 4, ..., until the subspace size &gt; nroots.</dd>
<dt>precond</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(dx, e, x0) =&gt; array_like_dx</span><dd>Preconditioner to generate new trial vector.
The argument dx is a residual vector <code class="docutils literal"><span class="pre">a*x0-e*x0</span></code>; e is the current
eigenvalue; x0 is the current eigenvector.</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Convergence tolerance.</dd>
<dt>max_cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>max number of iterations.</dd>
<dt>max_space</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>space size to hold trial vectors.</dd>
<dt>lindep</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Linear dependency threshold.  The function is terminated when the
smallest eigenvalue of the metric of the trial vectors is lower
than this threshold.</dd>
<dt>max_memory</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int or float</span><dd>Allowed memory in MB.</dd>
<dt>dot</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(x, y) =&gt; scalar</span><dd>Inner product</dd>
<dt>callback</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(envs_dict) =&gt; None</span><dd>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
envrionment.</dd>
<dt>nroots</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Number of eigenvalues to be computed.  When nroots &gt; 1, it affects
the shape of the return value</dd>
<dt>lessio</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>How to compute a*x0 for current eigenvector x0.  There are two
ways to compute a*x0.  One is to assemble the existed a*x.  The
other is to call aop(x0).  The default is the first method which
needs more IO and less computational cost.  When IO is slow, the
second method can be considered.</dd>
<dt>follow_state</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>If the solution dramatically changes in two iterations, clean the
subspace and restart the iteration with the old solution.  It can
help to improve numerical stability.  Default is False.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>conv</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Converged or not</dd>
<dt>e</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">list of floats</span><dd>The lowest <code class="xref py py-attr docutils literal"><span class="pre">nroots</span></code> eigenvalues.</dd>
<dt>c</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">list of 1D arrays</span><dd>The lowest <code class="xref py py-attr docutils literal"><span class="pre">nroots</span></code> eigenvectors.</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">lib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">a</span><span class="o">.</span><span class="n">T</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aop</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">xs</span><span class="p">:</span> <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xs</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">precond</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">dx</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">x0</span><span class="p">:</span> <span class="n">dx</span><span class="o">/</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span><span class="o">-</span><span class="n">e</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x0</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">davidson</span><span class="p">(</span><span class="n">aop</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">precond</span><span class="p">,</span> <span class="n">nroots</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.linalg_helper.davidson_nosym">
<code class="descclassname">pyscf.lib.linalg_helper.</code><code class="descname">davidson_nosym</code><span class="sig-paren">(</span><em>aop</em>, <em>x0</em>, <em>precond</em>, <em>tol=1e-12</em>, <em>max_cycle=50</em>, <em>max_space=12</em>, <em>lindep=1e-14</em>, <em>max_memory=2000</em>, <em>dot=&lt;built-in function dot&gt;</em>, <em>callback=None</em>, <em>nroots=1</em>, <em>lessio=False</em>, <em>left=False</em>, <em>pick=&lt;function pick_real_eigs&gt;</em>, <em>verbose=2</em>, <em>follow_state=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.lib.linalg_helper.davidson_nosym" title="Permalink to this definition">¶</a></dt>
<dd><p>Davidson diagonalization to solve the non-symmetric eigenvalue problem</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>aop</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function([x]) =&gt; [array_like_x]</span><dd>Matrix vector multiplication <span class="math">\(y_{ki} = \sum_{j}a_{ij}*x_{jk}\)</span>.</dd>
<dt>x0</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">1D array or a list of 1D array</span><dd>Initial guess.  The initial guess vector(s) are just used as the
initial subspace bases.  If the subspace is smaller than &#8220;nroots&#8221;,
eg 10 roots and one initial guess, all eigenvectors are chosen as
the eigenvectors during the iterations.  The first iteration has
one eigenvector, the next iteration has two, the third iterastion
has 4, ..., until the subspace size &gt; nroots.</dd>
<dt>precond</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(dx, e, x0) =&gt; array_like_dx</span><dd>Preconditioner to generate new trial vector.
The argument dx is a residual vector <code class="docutils literal"><span class="pre">a*x0-e*x0</span></code>; e is the current
eigenvalue; x0 is the current eigenvector.</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Convergence tolerance.</dd>
<dt>max_cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>max number of iterations.</dd>
<dt>max_space</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>space size to hold trial vectors.</dd>
<dt>lindep</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Linear dependency threshold.  The function is terminated when the
smallest eigenvalue of the metric of the trial vectors is lower
than this threshold.</dd>
<dt>max_memory</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int or float</span><dd>Allowed memory in MB.</dd>
<dt>dot</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(x, y) =&gt; scalar</span><dd>Inner product</dd>
<dt>callback</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(envs_dict) =&gt; None</span><dd>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
envrionment.</dd>
<dt>nroots</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Number of eigenvalues to be computed.  When nroots &gt; 1, it affects
the shape of the return value</dd>
<dt>lessio</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>How to compute a*x0 for current eigenvector x0.  There are two
ways to compute a*x0.  One is to assemble the existed a*x.  The
other is to call aop(x0).  The default is the first method which
needs more IO and less computational cost.  When IO is slow, the
second method can be considered.</dd>
<dt>left</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Whether to calculate and return left eigenvectors.  Default is False.</dd>
<dt>pick</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(w,v,nroots) =&gt; (e[idx], w[:,idx], idx)</span><dd>Function to filter eigenvalues and eigenvectors.</dd>
<dt>follow_state</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>If the solution dramatically changes in two iterations, clean the
subspace and restart the iteration with the old solution.  It can
help to improve numerical stability.  Default is False.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>conv</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Converged or not</dd>
<dt>e</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">list of eigenvalues</span><dd>The eigenvalues can be sorted real or complex, depending on the
return value of <code class="docutils literal"><span class="pre">pick</span></code> function.</dd>
<dt>vl</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">list of 1D arrays</span><dd>Left eigenvectors. Only returned if <code class="docutils literal"><span class="pre">left=True</span></code>.</dd>
<dt>c</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">list of 1D arrays</span><dd>Right eigenvectors.</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">lib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aop</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">xs</span><span class="p">:</span> <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xs</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">precond</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">dx</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">x0</span><span class="p">:</span> <span class="n">dx</span><span class="o">/</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span><span class="o">-</span><span class="n">e</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x0</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="p">,</span> <span class="n">vl</span><span class="p">,</span> <span class="n">vr</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">davidson</span><span class="p">(</span><span class="n">aop</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">precond</span><span class="p">,</span> <span class="n">nroots</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.linalg_helper.dgeev">
<code class="descclassname">pyscf.lib.linalg_helper.</code><code class="descname">dgeev</code><span class="sig-paren">(</span><em>abop</em>, <em>x0</em>, <em>precond</em>, <em>type=1</em>, <em>tol=1e-12</em>, <em>max_cycle=50</em>, <em>max_space=12</em>, <em>lindep=1e-14</em>, <em>max_memory=2000</em>, <em>dot=&lt;built-in function dot&gt;</em>, <em>callback=None</em>, <em>nroots=1</em>, <em>lessio=False</em>, <em>verbose=2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/lib/linalg_helper.html#dgeev"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.linalg_helper.dgeev" title="Permalink to this definition">¶</a></dt>
<dd><p>Davidson diagonalization method to solve  A c = e B c.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>abop</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(x) =&gt; (array_like_x, array_like_x)</span><dd>abop applies two matrix vector multiplications and returns tuple (Ax, Bx)</dd>
<dt>x0</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span><dd>Initial guess</dd>
<dt>precond</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(dx, e, x0) =&gt; array_like_dx</span><dd>Preconditioner to generate new trial vector.
The argument dx is a residual vector <code class="docutils literal"><span class="pre">a*x0-e*x0</span></code>; e is the current
eigenvalue; x0 is the current eigenvector.</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Convergence tolerance.</dd>
<dt>max_cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>max number of iterations.</dd>
<dt>max_space</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>space size to hold trial vectors.</dd>
<dt>lindep</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Linear dependency threshold.  The function is terminated when the
smallest eigenvalue of the metric of the trial vectors is lower
than this threshold.</dd>
<dt>max_memory</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int or float</span><dd>Allowed memory in MB.</dd>
<dt>dot</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(x, y) =&gt; scalar</span><dd>Inner product</dd>
<dt>callback</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(envs_dict) =&gt; None</span><dd>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
envrionment.</dd>
<dt>nroots</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Number of eigenvalues to be computed.  When nroots &gt; 1, it affects
the shape of the return value</dd>
<dt>lessio</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>How to compute a*x0 for current eigenvector x0.  There are two
ways to compute a*x0.  One is to assemble the existed a*x.  The
other is to call aop(x0).  The default is the first method which
needs more IO and less computational cost.  When IO is slow, the
second method can be considered.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>e</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">list of floats</span><dd>The lowest <code class="xref py py-attr docutils literal"><span class="pre">nroots</span></code> eigenvalues.</dd>
<dt>c</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">list of 1D arrays</span><dd>The lowest <code class="xref py py-attr docutils literal"><span class="pre">nroots</span></code> eigenvectors.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.linalg_helper.dgeev1">
<code class="descclassname">pyscf.lib.linalg_helper.</code><code class="descname">dgeev1</code><span class="sig-paren">(</span><em>abop</em>, <em>x0</em>, <em>precond</em>, <em>type=1</em>, <em>tol=1e-12</em>, <em>max_cycle=50</em>, <em>max_space=12</em>, <em>lindep=1e-14</em>, <em>max_memory=2000</em>, <em>dot=&lt;built-in function dot&gt;</em>, <em>callback=None</em>, <em>nroots=1</em>, <em>lessio=False</em>, <em>verbose=2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/lib/linalg_helper.html#dgeev1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.linalg_helper.dgeev1" title="Permalink to this definition">¶</a></dt>
<dd><p>Davidson diagonalization method to solve  A c = e B c.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>abop</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function([x]) =&gt; ([array_like_x], [array_like_x])</span><dd>abop applies two matrix vector multiplications and returns tuple (Ax, Bx)</dd>
<dt>x0</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span><dd>Initial guess</dd>
<dt>precond</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(dx, e, x0) =&gt; array_like_dx</span><dd>Preconditioner to generate new trial vector.
The argument dx is a residual vector <code class="docutils literal"><span class="pre">a*x0-e*x0</span></code>; e is the current
eigenvalue; x0 is the current eigenvector.</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Convergence tolerance.</dd>
<dt>max_cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>max number of iterations.</dd>
<dt>max_space</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>space size to hold trial vectors.</dd>
<dt>lindep</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Linear dependency threshold.  The function is terminated when the
smallest eigenvalue of the metric of the trial vectors is lower
than this threshold.</dd>
<dt>max_memory</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int or float</span><dd>Allowed memory in MB.</dd>
<dt>dot</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(x, y) =&gt; scalar</span><dd>Inner product</dd>
<dt>callback</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(envs_dict) =&gt; None</span><dd>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
envrionment.</dd>
<dt>nroots</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Number of eigenvalues to be computed.  When nroots &gt; 1, it affects
the shape of the return value</dd>
<dt>lessio</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>How to compute a*x0 for current eigenvector x0.  There are two
ways to compute a*x0.  One is to assemble the existed a*x.  The
other is to call aop(x0).  The default is the first method which
needs more IO and less computational cost.  When IO is slow, the
second method can be considered.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>conv</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Converged or not</dd>
<dt>e</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">list of floats</span><dd>The lowest <code class="xref py py-attr docutils literal"><span class="pre">nroots</span></code> eigenvalues.</dd>
<dt>c</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">list of 1D arrays</span><dd>The lowest <code class="xref py py-attr docutils literal"><span class="pre">nroots</span></code> eigenvectors.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.linalg_helper.dsolve">
<code class="descclassname">pyscf.lib.linalg_helper.</code><code class="descname">dsolve</code><span class="sig-paren">(</span><em>aop</em>, <em>b</em>, <em>precond</em>, <em>tol=1e-12</em>, <em>max_cycle=30</em>, <em>dot=&lt;built-in function dot&gt;</em>, <em>lindep=1e-16</em>, <em>verbose=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/lib/linalg_helper.html#dsolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.linalg_helper.dsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Davidson iteration to solve linear equation.  It works bad.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.linalg_helper.eig">
<code class="descclassname">pyscf.lib.linalg_helper.</code><code class="descname">eig</code><span class="sig-paren">(</span><em>aop</em>, <em>x0</em>, <em>precond</em>, <em>tol=1e-12</em>, <em>max_cycle=50</em>, <em>max_space=12</em>, <em>lindep=1e-14</em>, <em>max_memory=2000</em>, <em>dot=&lt;built-in function dot&gt;</em>, <em>callback=None</em>, <em>nroots=1</em>, <em>lessio=False</em>, <em>left=False</em>, <em>pick=&lt;function pick_real_eigs&gt;</em>, <em>verbose=2</em>, <em>follow_state=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/lib/linalg_helper.html#eig"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.linalg_helper.eig" title="Permalink to this definition">¶</a></dt>
<dd><p>Davidson diagonalization to solve the non-symmetric eigenvalue problem</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>aop</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function([x]) =&gt; [array_like_x]</span><dd>Matrix vector multiplication <span class="math">\(y_{ki} = \sum_{j}a_{ij}*x_{jk}\)</span>.</dd>
<dt>x0</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">1D array or a list of 1D array</span><dd>Initial guess.  The initial guess vector(s) are just used as the
initial subspace bases.  If the subspace is smaller than &#8220;nroots&#8221;,
eg 10 roots and one initial guess, all eigenvectors are chosen as
the eigenvectors during the iterations.  The first iteration has
one eigenvector, the next iteration has two, the third iterastion
has 4, ..., until the subspace size &gt; nroots.</dd>
<dt>precond</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(dx, e, x0) =&gt; array_like_dx</span><dd>Preconditioner to generate new trial vector.
The argument dx is a residual vector <code class="docutils literal"><span class="pre">a*x0-e*x0</span></code>; e is the current
eigenvalue; x0 is the current eigenvector.</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Convergence tolerance.</dd>
<dt>max_cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>max number of iterations.</dd>
<dt>max_space</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>space size to hold trial vectors.</dd>
<dt>lindep</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Linear dependency threshold.  The function is terminated when the
smallest eigenvalue of the metric of the trial vectors is lower
than this threshold.</dd>
<dt>max_memory</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int or float</span><dd>Allowed memory in MB.</dd>
<dt>dot</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(x, y) =&gt; scalar</span><dd>Inner product</dd>
<dt>callback</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(envs_dict) =&gt; None</span><dd>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
envrionment.</dd>
<dt>nroots</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Number of eigenvalues to be computed.  When nroots &gt; 1, it affects
the shape of the return value</dd>
<dt>lessio</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>How to compute a*x0 for current eigenvector x0.  There are two
ways to compute a*x0.  One is to assemble the existed a*x.  The
other is to call aop(x0).  The default is the first method which
needs more IO and less computational cost.  When IO is slow, the
second method can be considered.</dd>
<dt>left</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Whether to calculate and return left eigenvectors.  Default is False.</dd>
<dt>pick</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(w,v,nroots) =&gt; (e[idx], w[:,idx], idx)</span><dd>Function to filter eigenvalues and eigenvectors.</dd>
<dt>follow_state</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>If the solution dramatically changes in two iterations, clean the
subspace and restart the iteration with the old solution.  It can
help to improve numerical stability.  Default is False.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>conv</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Converged or not</dd>
<dt>e</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">list of eigenvalues</span><dd>The eigenvalues can be sorted real or complex, depending on the
return value of <code class="docutils literal"><span class="pre">pick</span></code> function.</dd>
<dt>vl</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">list of 1D arrays</span><dd>Left eigenvectors. Only returned if <code class="docutils literal"><span class="pre">left=True</span></code>.</dd>
<dt>c</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">list of 1D arrays</span><dd>Right eigenvectors.</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">lib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aop</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">xs</span><span class="p">:</span> <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xs</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">precond</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">dx</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">x0</span><span class="p">:</span> <span class="n">dx</span><span class="o">/</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span><span class="o">-</span><span class="n">e</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x0</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="p">,</span> <span class="n">vl</span><span class="p">,</span> <span class="n">vr</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">davidson</span><span class="p">(</span><span class="n">aop</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">precond</span><span class="p">,</span> <span class="n">nroots</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.linalg_helper.eigh_by_blocks">
<code class="descclassname">pyscf.lib.linalg_helper.</code><code class="descname">eigh_by_blocks</code><span class="sig-paren">(</span><em>h</em>, <em>s=None</em>, <em>labels=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/lib/linalg_helper.html#eigh_by_blocks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.linalg_helper.eigh_by_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve an ordinary or generalized eigenvalue problem for diagonal blocks.
The diagonal blocks are extracted based on the given basis &#8220;labels&#8221;.  The
rows and columns which have the same labels are put in the same block.
One common scenario one needs the block-wise diagonalization is to
diagonalize the matrix in symmetry adapted basis, in which &#8220;labels&#8221; is the
irreps of each basis.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>h, s</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D array</span><dd>Complex Hermitian or real symmetric matrix.</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd>labels : list</dd>
<dt>Returns:</dt>
<dd>w, v.  w is the eigenvalue vector; v is the eigenfunction array;
seig is the eigenvalue vector of the metric s.</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">lib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">::</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">::</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">::</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">::</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lib</span><span class="o">.</span><span class="n">eigh_by_blocks</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
<span class="go">(array([ 0.,  0.,  2.,  4.]),</span>
<span class="go"> array([[ 1.,  0.,  0.,  0.],</span>
<span class="go">        [ 0.,  0.,  1.,  0.],</span>
<span class="go">        [ 0.,  0.,  0.,  1.],</span>
<span class="go">        [ 0.,  1.,  0.,  0.]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">(array([ -8.82020545e-01,  -1.81556477e-16,   1.77653793e+00,   5.10548262e+00]),</span>
<span class="go"> array([[  6.40734630e-01,  -7.07106781e-01,   1.68598330e-01,   -2.47050070e-01],</span>
<span class="go">        [ -3.80616542e-01,   9.40505244e-17,   8.19944479e-01,   -4.27577008e-01],</span>
<span class="go">        [ -1.84524565e-01,   9.40505244e-17,  -5.20423152e-01,   -8.33732828e-01],</span>
<span class="go">        [  6.40734630e-01,   7.07106781e-01,   1.68598330e-01,   -2.47050070e-01]]))</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">lib</span><span class="p">,</span> <span class="n">symm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">symm_orb</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vnuc_so</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">,</span> <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_nuc_sph&#39;</span><span class="p">),</span> <span class="n">c</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">orbsym</span> <span class="o">=</span> <span class="n">symm</span><span class="o">.</span><span class="n">label_orb_symm</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">irrep_name</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">symm_orb</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lib</span><span class="o">.</span><span class="n">eigh_by_blocks</span><span class="p">(</span><span class="n">vnuc_so</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">orbsym</span><span class="p">)</span>
<span class="go">(array([-4.50766885, -1.80666351, -1.7808565 , -1.7808565 , -1.74189134,</span>
<span class="go">        -0.98998583, -0.98998583, -0.40322226, -0.30242374, -0.07608981]),</span>
<span class="go"> ...)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.linalg_helper.krylov">
<code class="descclassname">pyscf.lib.linalg_helper.</code><code class="descname">krylov</code><span class="sig-paren">(</span><em>aop</em>, <em>b</em>, <em>x0=None</em>, <em>tol=1e-10</em>, <em>max_cycle=30</em>, <em>dot=&lt;built-in function dot&gt;</em>, <em>lindep=1e-15</em>, <em>callback=None</em>, <em>hermi=False</em>, <em>verbose=2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/lib/linalg_helper.html#krylov"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.linalg_helper.krylov" title="Permalink to this definition">¶</a></dt>
<dd><p>Krylov subspace method to solve  (1+a) x = b.  Ref:
J. A. Pople et al, Int. J.  Quantum. Chem.  Symp. 13, 225 (1979).</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>aop</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(x) =&gt; array_like_x</span><dd>aop(x) to mimic the matrix vector multiplication <span class="math">\(\sum_{j}a_{ij} x_j\)</span>.
The argument is a 1D array.  The returned value is a 1D array.</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>x0</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span><dd>Initial guess</dd>
<dt>tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Tolerance to terminate the operation aop(x).</dd>
<dt>max_cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>max number of iterations.</dd>
<dt>lindep</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Linear dependency threshold.  The function is terminated when the
smallest eigenvalue of the metric of the trial vectors is lower
than this threshold.</dd>
<dt>dot</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(x, y) =&gt; scalar</span><dd>Inner product</dd>
<dt>callback</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(envs_dict) =&gt; None</span><dd>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
envrionment.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>x : 1D array like b</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">lib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span> <span class="o">*</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aop</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">krylov</span><span class="p">(</span><span class="n">aop</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">x</span><span class="p">)</span><span class="o">+</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.linalg_helper.safe_eigh">
<code class="descclassname">pyscf.lib.linalg_helper.</code><code class="descname">safe_eigh</code><span class="sig-paren">(</span><em>h</em>, <em>s</em>, <em>lindep=1e-15</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/lib/linalg_helper.html#safe_eigh"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.linalg_helper.safe_eigh" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve generalized eigenvalue problem  h v = w s v.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The number of eigenvalues and eigenvectors might be less than the
matrix dimension if linear dependency is found in metric s.</p>
</div>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>h, s</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D array</span><dd>Complex Hermitian or real symmetric matrix.</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>lindep</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Linear dependency threshold.  By diagonalizing the metric s, we
consider the eigenvectors are linearly dependent subsets if their
eigenvalues are smaller than this threshold.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>w, v, seig.  w is the eigenvalue vector; v is the eigenfunction array;
seig is the eigenvalue vector of the metric s.</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-pyscf.lib.chkfile">
<span id="chkfile"></span><h2>chkfile<a class="headerlink" href="#module-pyscf.lib.chkfile" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pyscf.lib.chkfile.dump">
<code class="descclassname">pyscf.lib.chkfile.</code><code class="descname">dump</code><span class="sig-paren">(</span><em>chkfile</em>, <em>key</em>, <em>value</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/lib/chkfile.html#dump"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.chkfile.dump" title="Permalink to this definition">¶</a></dt>
<dd><p>Save array(s) in chkfile</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first docutils">
<dt>chkfile</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>Name of chkfile.</dd>
</dl>
<p>key : str</p>
<dl class="last docutils">
<dt>value</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">array, vector ... or dict</span><dd>If value is a python dict, the key/value of the dict will be saved
recursively as the HDF5 group/dataset</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>No return value</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">h5py</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">lib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ci</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Ci&#39;</span> <span class="p">:</span> <span class="p">{</span><span class="s1">&#39;op&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">),</span> <span class="s1">&#39;irrep&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;Ag&#39;</span><span class="p">,</span> <span class="s1">&#39;Au&#39;</span><span class="p">)}}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lib</span><span class="o">.</span><span class="n">chkfile</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;symm.chk&#39;</span><span class="p">,</span> <span class="s1">&#39;symm&#39;</span><span class="p">,</span> <span class="n">ci</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="s1">&#39;symm.chk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="go">[&#39;symm&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">[</span><span class="s1">&#39;symm&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="go">[&#39;Ci&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">[</span><span class="s1">&#39;symm/Ci&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="go">[&#39;op&#39;, &#39;irrep&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">[</span><span class="s1">&#39;symm/Ci/op&#39;</span><span class="p">]</span>
<span class="go">&lt;HDF5 dataset &quot;op&quot;: shape (2,), type &quot;|S1&quot;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.chkfile.dump_mol">
<code class="descclassname">pyscf.lib.chkfile.</code><code class="descname">dump_mol</code><span class="sig-paren">(</span><em>mol</em>, <em>chkfile</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.lib.chkfile.dump_mol" title="Permalink to this definition">¶</a></dt>
<dd><p>Save Mole object in chkfile</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">mol : an instance of <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code>.</p>
<dl class="last docutils">
<dt>chkfile</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>Name of chkfile.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>No return value</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.chkfile.load">
<code class="descclassname">pyscf.lib.chkfile.</code><code class="descname">load</code><span class="sig-paren">(</span><em>chkfile</em>, <em>key</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/lib/chkfile.html#load"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.chkfile.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Load array(s) from chkfile</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>chkfile</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>Name of chkfile. The chkfile needs to be saved in HDF5 format.</dd>
<dt>key</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>HDF5.dataset name or group name.  If key is the HDF5 group name,
the group will be loaded into an Python dict, recursively</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>whatever read from chkfile</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">lib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;He 0 0 0&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">chkfile</span> <span class="o">=</span> <span class="s1">&#39;He.chk&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mo_coeff</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">chkfile</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;He.chk&#39;</span><span class="p">,</span> <span class="s1">&#39;scf/mo_coeff&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mo_coeff</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scfdat</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">chkfile</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;He.chk&#39;</span><span class="p">,</span> <span class="s1">&#39;scf&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scfdat</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="go">[&#39;e_tot&#39;, &#39;mo_occ&#39;, &#39;mo_energy&#39;, &#39;mo_coeff&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.chkfile.load_mol">
<code class="descclassname">pyscf.lib.chkfile.</code><code class="descname">load_mol</code><span class="sig-paren">(</span><em>chkfile</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/lib/chkfile.html#load_mol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.chkfile.load_mol" title="Permalink to this definition">¶</a></dt>
<dd><p>Load Mole object from chkfile.
The save_mol/load_mol operation can be used a serialization method for Mole object.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>chkfile</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>Name of chkfile.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>A (initialized/built) Mole object</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">lib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;He 0 0 0&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lib</span><span class="o">.</span><span class="n">chkfile</span><span class="o">.</span><span class="n">save_mol</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="s1">&#39;He.chk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lib</span><span class="o">.</span><span class="n">chkfile</span><span class="o">.</span><span class="n">load_mol</span><span class="p">(</span><span class="s1">&#39;He.chk&#39;</span><span class="p">)</span>
<span class="go">&lt;pyscf.gto.mole.Mole object at 0x7fdcd94d7f50&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.chkfile.save_mol">
<code class="descclassname">pyscf.lib.chkfile.</code><code class="descname">save_mol</code><span class="sig-paren">(</span><em>mol</em>, <em>chkfile</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/lib/chkfile.html#save_mol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.chkfile.save_mol" title="Permalink to this definition">¶</a></dt>
<dd><p>Save Mole object in chkfile</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">mol : an instance of <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code>.</p>
<dl class="last docutils">
<dt>chkfile</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>Name of chkfile.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>No return value</dd>
</dl>
</dd></dl>

<div class="section" id="fast-load">
<h3>Fast load<a class="headerlink" href="#fast-load" title="Permalink to this headline">¶</a></h3>
<p>The results of SCF and MCSCF methods are saved as a Python dictionary in
the chkfile.  One can fast load the results and update the SCF and MCSCF
objects using the python built in methods <code class="docutils literal"><span class="pre">.__dict__.update</span></code>, eg:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span><span class="p">,</span> <span class="n">lib</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 1 1 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">)</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">chkfile</span><span class="o">=</span><span class="s1">&#39;n2.chk).run()</span>
<span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">chkfile</span><span class="o">=</span><span class="s1">&#39;n2.chk&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

<span class="c1"># load SCF results</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="n">mf</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">lib</span><span class="o">.</span><span class="n">chkfile</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;n2.chk&#39;</span><span class="p">,</span> <span class="s1">&#39;scf&#39;</span><span class="p">))</span>

<span class="c1"># load MCSCF results</span>
<span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASCI</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="n">mc</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">lib</span><span class="o">.</span><span class="n">chkfile</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;n2.chk&#39;</span><span class="p">,</span> <span class="s1">&#39;mcscf&#39;</span><span class="p">))</span>
<span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="scf.html" class="btn btn-neutral float-right" title="scf — Mean-field methods" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="gto.html" class="btn btn-neutral" title="gto — Molecular structure and GTO basis" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015-, Qiming Sun &lt;osirpt.sun@gmail.com&gt;.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.4.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: ''
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>