

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>dft — Density functional theory &mdash; PySCF 1.4.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="PySCF 1.4.0 documentation" href="index.html"/>
        <link rel="next" title="tddft — Time dependent density functional theory" href="tddft.html"/>
        <link rel="prev" title="df — Density fitting" href="df.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> PySCF
          

          
          </a>

          
            
            
              <div class="version">
                1.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">An overview of PySCF</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="gto.html">gto &#8212; Molecular structure and GTO basis</a></li>
<li class="toctree-l1"><a class="reference internal" href="lib.html">lib &#8212; Helper functions, parameters, and C extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="scf.html">scf &#8212; Mean-field methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="ao2mo.html">ao2mo &#8212; Integral transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="mcscf.html">mcscf &#8212; Multi-configurational self-consistent field</a></li>
<li class="toctree-l1"><a class="reference internal" href="fci.html">fci &#8212; Full configuration interaction</a></li>
<li class="toctree-l1"><a class="reference internal" href="symm.html">symm &#8211; Point group symmetry and spin symmetry</a></li>
<li class="toctree-l1"><a class="reference internal" href="df.html">df &#8212; Density fitting</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">dft &#8212; Density functional theory</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#customizing-xc-functional">Customizing XC functional</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-pyscf.dft.rks">Program reference</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="tddft.html">tddft &#8212; Time dependent density functional theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="cc.html">cc &#8212; Coupled cluster</a></li>
<li class="toctree-l1"><a class="reference internal" href="ci.html">ci &#8212; Configuration interaction</a></li>
<li class="toctree-l1"><a class="reference internal" href="dmrgscf.html">dmrgscf</a></li>
<li class="toctree-l1"><a class="reference internal" href="fciqmcscf.html">fciqmcscf</a></li>
<li class="toctree-l1"><a class="reference internal" href="tools.html">tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="grad.html">grad &#8212; Analytical nuclear gradients</a></li>
<li class="toctree-l1"><a class="reference internal" href="hessian.html">hessian &#8212; Analytical nuclear Hessian</a></li>
<li class="toctree-l1"><a class="reference internal" href="pbc.html">pbc &#8212; Periodic boundary conditions</a></li>
<li class="toctree-l1"><a class="reference internal" href="lo.html">lo &#8212; Orbital localization</a></li>
<li class="toctree-l1"><a class="reference internal" href="advanced.html">Miscellaneous</a></li>
<li class="toctree-l1"><a class="reference internal" href="qmmm.html">qmmm &#8212; QM/MM interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="mrpt.html">mrpt &#8212; Multi-reference perturbation theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="benchmark.html">Benchmark</a></li>
<li class="toctree-l1"><a class="reference internal" href="code-rule.html">Code standard</a></li>
<li class="toctree-l1"><a class="reference internal" href="version.html">Version history</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">PySCF</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>dft &#8212; Density functional theory</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/dft.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="dft-density-functional-theory">
<h1>dft &#8212; Density functional theory<a class="headerlink" href="#dft-density-functional-theory" title="Permalink to this headline">¶</a></h1>
<div class="section" id="customizing-xc-functional">
<h2>Customizing XC functional<a class="headerlink" href="#customizing-xc-functional" title="Permalink to this headline">¶</a></h2>
<p>XC functional of DFT methods can be customized.  The simplest way to customize
XC functional is to assigned a string expression to <code class="xref py py-attr docutils literal"><span class="pre">mf.xc</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">dft</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H  0  0  0; F  0.9  0  0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">dft</span><span class="o">.</span><span class="n">RKS</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="n">mf</span><span class="o">.</span><span class="n">xc</span> <span class="o">=</span> <span class="s1">&#39;HF*0.2 + .08*LDA + .72*B88, .81*LYP + .19*VWN&#39;</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="n">mf</span><span class="o">.</span><span class="n">xc</span> <span class="o">=</span> <span class="s1">&#39;HF*0.5 + .08*LDA + .42*B88, .81*LYP + .19*VWN&#39;</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="n">mf</span><span class="o">.</span><span class="n">xc</span> <span class="o">=</span> <span class="s1">&#39;HF*0.8 + .08*LDA + .12*B88, .81*LYP + .19*VWN&#39;</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="n">mf</span><span class="o">.</span><span class="n">xc</span> <span class="o">=</span> <span class="s1">&#39;HF&#39;</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>
<p>The XC functional string is parsed against the following rules.</p>
<ul>
<li><p class="first">The given functional description must be a one-line string.</p>
</li>
<li><p class="first">The functional description is case-insensitive.</p>
</li>
<li><p class="first">The functional description string has two parts, separated by <code class="docutils literal"><span class="pre">,</span></code>.  The
first part describes the exchange functional, the second is the correlation
functional.
- If <code class="docutils literal"><span class="pre">,</span></code> was not appeared in string, the entire string is considered as</p>
<blockquote>
<div><p>X functional.</p>
</div></blockquote>
<ul class="simple">
<li>To neglect X functional (just apply C functional), leave blank in the
first part, eg <code class="docutils literal"><span class="pre">mf.xc=',vwn'</span></code> for pure VWN functional</li>
</ul>
</li>
<li><p class="first">The functional name can be placed in arbitrary order.  Two names needs to
be separated by operators <code class="docutils literal"><span class="pre">+</span></code> or <code class="docutils literal"><span class="pre">-</span></code>.  Blank spaces are ignored.
NOTE the parser only reads operators <code class="docutils literal"><span class="pre">+</span> <span class="pre">-</span> <span class="pre">*</span></code>.  <code class="docutils literal"><span class="pre">/</span></code> is not supported.</p>
</li>
<li><p class="first">A functional name is associated with one factor.  If the factor is not
given, it is assumed equaling 1.</p>
</li>
<li><p class="first">String <code class="docutils literal"><span class="pre">'HF'</span></code> stands for exact exchange (HF K matrix).  It is allowed to
put <code class="docutils literal"><span class="pre">'HF'</span></code> in C (correlation) functional part.</p>
</li>
<li><p class="first">Be careful with the libxc convention on GGA functional, in which the LDA
contribution is included.</p>
</li>
</ul>
<p>Another way to customize XC functional is to redefine the <code class="xref py py-meth docutils literal"><span class="pre">eval_xc()</span></code>
method of numerical integral class:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0.9 0 0&#39;</span><span class="p">,</span> <span class="n">basis</span> <span class="o">=</span> <span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">dft</span><span class="o">.</span><span class="n">RKS</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">eval_xc</span><span class="p">(</span><span class="n">xc_code</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">relativity</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">deriv</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="c1"># A fictitious XC functional to demonstrate the usage</span>
    <span class="n">rho0</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">dz</span> <span class="o">=</span> <span class="n">rho</span>
    <span class="n">gamma</span> <span class="o">=</span> <span class="p">(</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">dy</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">dz</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">exc</span> <span class="o">=</span> <span class="o">.</span><span class="mi">01</span> <span class="o">*</span> <span class="n">rho0</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="o">.</span><span class="mi">02</span> <span class="o">*</span> <span class="p">(</span><span class="n">gamma</span><span class="o">+.</span><span class="mi">001</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
    <span class="n">vrho</span> <span class="o">=</span> <span class="o">.</span><span class="mi">01</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">rho0</span>
    <span class="n">vgamma</span> <span class="o">=</span> <span class="o">.</span><span class="mi">02</span> <span class="o">*</span> <span class="o">.</span><span class="mi">5</span> <span class="o">*</span> <span class="p">(</span><span class="n">gamma</span><span class="o">+.</span><span class="mi">001</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-.</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">vlapl</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">vtau</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">vxc</span> <span class="o">=</span> <span class="p">(</span><span class="n">vrho</span><span class="p">,</span> <span class="n">vgamma</span><span class="p">,</span> <span class="n">vlapl</span><span class="p">,</span> <span class="n">vtau</span><span class="p">)</span>
    <span class="n">fxc</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># 2nd order functional derivative</span>
    <span class="n">kxc</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># 3rd order functional derivative</span>
    <span class="k">return</span> <span class="n">exc</span><span class="p">,</span> <span class="n">vxc</span><span class="p">,</span> <span class="n">fxc</span><span class="p">,</span> <span class="n">kxc</span>
<span class="n">dft</span><span class="o">.</span><span class="n">libxc</span><span class="o">.</span><span class="n">define_xc_</span><span class="p">(</span><span class="n">mf</span><span class="o">.</span><span class="n">_numint</span><span class="p">,</span> <span class="n">eval_xc</span><span class="p">,</span> <span class="n">xctype</span><span class="o">=</span><span class="s1">&#39;GGA&#39;</span><span class="p">)</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>
<p>By calling <code class="xref py py-func docutils literal"><span class="pre">dft.libxc.define_xc_()</span></code> function, the customized <code class="xref py py-func docutils literal"><span class="pre">eval_xc()</span></code>
function is patched to the numerical integration class <code class="xref py py-attr docutils literal"><span class="pre">mf._numint</span></code>
dynamically.</p>
<p>More examples of customizing DFT XC functional can be found in
<code class="file docutils literal"><span class="pre">examples/dft/24-custom_xc_functional.py</span></code> and
<code class="file docutils literal"><span class="pre">examples/dft/24-define_xc_functional.py</span></code>.</p>
</div>
<div class="section" id="module-pyscf.dft.rks">
<span id="program-reference"></span><h2>Program reference<a class="headerlink" href="#module-pyscf.dft.rks" title="Permalink to this headline">¶</a></h2>
<p>Non-relativistic restricted Kohn-Sham</p>
<dl class="class">
<dt id="pyscf.dft.rks.RKS">
<em class="property">class </em><code class="descclassname">pyscf.dft.rks.</code><code class="descname">RKS</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/dft/rks.html#RKS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.dft.rks.RKS" title="Permalink to this definition">¶</a></dt>
<dd><p>Restricted Kohn-Sham
SCF base class.   non-relativistic RHF.</p>
<blockquote>
<div><dl class="docutils">
<dt>Attributes:</dt>
<dd><dl class="first last docutils">
<dt>verbose</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Print level.  Default value equals to <code class="xref py py-class docutils literal"><span class="pre">Mole.verbose</span></code></dd>
<dt>max_memory</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float or int</span><dd>Allowed memory in MB.  Default equals to <code class="xref py py-class docutils literal"><span class="pre">Mole.max_memory</span></code></dd>
<dt>chkfile</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>checkpoint file to save MOs, orbital energies etc.</dd>
<dt>conv_tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>converge threshold.  Default is 1e-10</dd>
<dt>conv_tol_grad</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>gradients converge threshold.  Default is sqrt(conv_tol)</dd>
<dt>max_cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>max number of iterations.  Default is 50</dd>
<dt>init_guess</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>initial guess method.  It can be one of &#8216;minao&#8217;, &#8216;atom&#8217;, &#8216;1e&#8217;, &#8216;chkfile&#8217;.
Default is &#8216;minao&#8217;</dd>
<dt>diis</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">boolean or object of DIIS class listed in <code class="xref py py-mod docutils literal"><span class="pre">scf.diis</span></code></span><dd>Default is <code class="xref py py-class docutils literal"><span class="pre">diis.SCF_DIIS</span></code>. Set it to None to turn off DIIS.</dd>
<dt>diis_space</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>DIIS space size.  By default, 8 Fock matrices and errors vector are stored.</dd>
<dt>diis_start_cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>The step to start DIIS.  Default is 1.</dd>
<dt>diis_file: &#8216;str&#8217;</dt>
<dd>File to store DIIS vectors and error vectors.</dd>
<dt>level_shift</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float or int</span><dd>Level shift (in AU) for virtual space.  Default is 0.</dd>
<dt>direct_scf</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Direct SCF is used by default.</dd>
<dt>direct_scf_tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Direct SCF cutoff threshold.  Default is 1e-13.</dd>
<dt>callback</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(envs_dict) =&gt; None</span><dd>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
envrionment.</dd>
<dt>conv_check</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>An extra cycle to check convergence after SCF iterations.</dd>
</dl>
</dd>
</dl>
<p>Saved results</p>
<blockquote>
<div><dl class="docutils">
<dt>converged</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>SCF converged or not</dd>
<dt>e_tot</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Total HF energy (electronic energy plus nuclear repulsion)</dd>
<dt>mo_energy :</dt>
<dd>Orbital energies</dd>
<dt>mo_occ</dt>
<dd>Orbital occupancy</dd>
<dt>mo_coeff</dt>
<dd>Orbital coefficients</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">level_shift</span> <span class="o">=</span> <span class="o">.</span><span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-1.0811707843775884</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Attributes for RKS:</dt>
<dd><dl class="first last docutils">
<dt>xc</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>&#8216;X_name,C_name&#8217; for the XC functional.  Default is &#8216;lda,vwn&#8217;</dd>
<dt>grids</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">Grids object</span><dd><p class="first">grids.level (0 - 9)  big number for large mesh grids. Default is 3</p>
<dl class="docutils">
<dt>radii_adjust</dt>
<dd><div class="first last line-block">
<div class="line">radi.treutler_atomic_radii_adjust (default)</div>
<div class="line">radi.becke_atomic_radii_adjust</div>
<div class="line">None : to switch off atomic radii adjustment</div>
</div>
</dd>
<dt>grids.atomic_radii</dt>
<dd><div class="first last line-block">
<div class="line">radi.BRAGG_RADII  (default)</div>
<div class="line">radi.COVALENT_RADII</div>
<div class="line">None : to switch off atomic radii adjustment</div>
</div>
</dd>
<dt>grids.radi_method  scheme for radial grids</dt>
<dd><div class="first last line-block">
<div class="line">radi.treutler  (default)</div>
<div class="line">radi.delley</div>
<div class="line">radi.mura_knowles</div>
<div class="line">radi.gauss_chebyshev</div>
</div>
</dd>
<dt>grids.becke_scheme  weight partition function</dt>
<dd><div class="first last line-block">
<div class="line">gen_grid.original_becke  (default)</div>
<div class="line">gen_grid.stratmann</div>
</div>
</dd>
<dt>grids.prune  scheme to reduce number of grids</dt>
<dd><div class="first last line-block">
<div class="line">gen_grid.nwchem_prune  (default)</div>
<div class="line">gen_grid.sg1_prune</div>
<div class="line">gen_grid.treutler_prune</div>
<div class="line">None : to switch off grids pruning</div>
</div>
</dd>
</dl>
<p>grids.symmetry  True/False  to symmetrize mesh grids (TODO)</p>
<p class="last">grids.atom_grid  Set (radial, angular) grids for particular atoms.
Eg, grids.atom_grid = {&#8216;H&#8217;: (20,110)} will generate 20 radial
grids and 110 angular grids for H atom.</p>
</dd>
<dt>small_rho_cutoff</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Drop grids if their contribution to total electrons smaller than
this cutoff value.  Default is 1e-7.</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; H 0 0 1; H 0 1 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">dft</span><span class="o">.</span><span class="n">RKS</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">xc</span> <span class="o">=</span> <span class="s1">&#39;b3lyp&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="go">-76.415443079840458</span>
</pre></div>
</div>
</div></blockquote>
<dl class="method">
<dt id="pyscf.dft.rks.RKS.energy_elec">
<code class="descname">energy_elec</code><span class="sig-paren">(</span><em>ks</em>, <em>dm</em>, <em>h1e=None</em>, <em>vhf=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.dft.rks.RKS.energy_elec" title="Permalink to this definition">¶</a></dt>
<dd><p>Electronic part of RKS energy.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">ks : an instance of DFT class</p>
<dl class="last docutils">
<dt>dm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarray</span><dd>one-partical density matrix</dd>
<dt>h1e</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarray</span><dd>Core hamiltonian</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>RKS electronic energy and the 2-electron part contribution</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.dft.rks.RKS.get_veff">
<code class="descname">get_veff</code><span class="sig-paren">(</span><em>ks</em>, <em>mol=None</em>, <em>dm=None</em>, <em>dm_last=0</em>, <em>vhf_last=0</em>, <em>hermi=1</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.dft.rks.RKS.get_veff" title="Permalink to this definition">¶</a></dt>
<dd><p>Coulomb + XC functional</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This function will change the ks object.</p>
</div>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>ks</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">an instance of <a class="reference internal" href="#pyscf.dft.rks.RKS" title="pyscf.dft.rks.RKS"><code class="xref py py-class docutils literal"><span class="pre">RKS</span></code></a></span><dd>XC functional are controlled by ks.xc attribute.  Attribute
ks.grids might be initialized.</dd>
<dt>dm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or list of ndarrays</span><dd>A density matrix or a list of density matrices</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>dm_last</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or a list of ndarrays or 0</span><dd>The density matrix baseline.  If not 0, this function computes the
increment of HF potential w.r.t. the reference HF potential matrix.</dd>
<dt>vhf_last</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or a list of ndarrays or 0</span><dd>The reference Vxc potential matrix.</dd>
<dt>hermi</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd><p class="first">Whether J, K matrix is hermitian</p>
<div class="last line-block">
<div class="line">0 : no hermitian or symmetric</div>
<div class="line">1 : hermitian</div>
<div class="line">2 : anti-hermitian</div>
</div>
</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>matrix Veff = J + Vxc.  Veff can be a list matrices, if the input
dm is a list of density matrices.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyscf.dft.rks.energy_elec">
<code class="descclassname">pyscf.dft.rks.</code><code class="descname">energy_elec</code><span class="sig-paren">(</span><em>ks</em>, <em>dm</em>, <em>h1e=None</em>, <em>vhf=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/dft/rks.html#energy_elec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.dft.rks.energy_elec" title="Permalink to this definition">¶</a></dt>
<dd><p>Electronic part of RKS energy.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">ks : an instance of DFT class</p>
<dl class="last docutils">
<dt>dm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarray</span><dd>one-partical density matrix</dd>
<dt>h1e</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarray</span><dd>Core hamiltonian</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>RKS electronic energy and the 2-electron part contribution</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.dft.rks.get_veff">
<code class="descclassname">pyscf.dft.rks.</code><code class="descname">get_veff</code><span class="sig-paren">(</span><em>ks</em>, <em>mol=None</em>, <em>dm=None</em>, <em>dm_last=0</em>, <em>vhf_last=0</em>, <em>hermi=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/dft/rks.html#get_veff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.dft.rks.get_veff" title="Permalink to this definition">¶</a></dt>
<dd><p>Coulomb + XC functional</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This function will change the ks object.</p>
</div>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>ks</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">an instance of <a class="reference internal" href="#pyscf.dft.rks.RKS" title="pyscf.dft.rks.RKS"><code class="xref py py-class docutils literal"><span class="pre">RKS</span></code></a></span><dd>XC functional are controlled by ks.xc attribute.  Attribute
ks.grids might be initialized.</dd>
<dt>dm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or list of ndarrays</span><dd>A density matrix or a list of density matrices</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>dm_last</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or a list of ndarrays or 0</span><dd>The density matrix baseline.  If not 0, this function computes the
increment of HF potential w.r.t. the reference HF potential matrix.</dd>
<dt>vhf_last</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or a list of ndarrays or 0</span><dd>The reference Vxc potential matrix.</dd>
<dt>hermi</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd><p class="first">Whether J, K matrix is hermitian</p>
<div class="last line-block">
<div class="line">0 : no hermitian or symmetric</div>
<div class="line">1 : hermitian</div>
<div class="line">2 : anti-hermitian</div>
</div>
</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>matrix Veff = J + Vxc.  Veff can be a list matrices, if the input
dm is a list of density matrices.</dd>
</dl>
</dd></dl>

<span class="target" id="module-pyscf.dft.uks"></span><p>Non-relativistic Unrestricted Kohn-Sham</p>
<dl class="class">
<dt id="pyscf.dft.uks.UKS">
<em class="property">class </em><code class="descclassname">pyscf.dft.uks.</code><code class="descname">UKS</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/dft/uks.html#UKS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.dft.uks.UKS" title="Permalink to this definition">¶</a></dt>
<dd><p>Unrestricted Kohn-Sham
See pyscf/dft/rks.py RKS class for the usage of the attributes</p>
<dl class="method">
<dt id="pyscf.dft.uks.UKS.get_veff">
<code class="descname">get_veff</code><span class="sig-paren">(</span><em>ks</em>, <em>mol=None</em>, <em>dm=None</em>, <em>dm_last=0</em>, <em>vhf_last=0</em>, <em>hermi=1</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.dft.uks.UKS.get_veff" title="Permalink to this definition">¶</a></dt>
<dd><p>Coulomb + XC functional for UKS.  See pyscf/dft/rks.py
<a class="reference internal" href="#pyscf.dft.uks.get_veff" title="pyscf.dft.uks.get_veff"><code class="xref py py-func docutils literal"><span class="pre">get_veff()</span></code></a> fore more details.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyscf.dft.uks.get_veff">
<code class="descclassname">pyscf.dft.uks.</code><code class="descname">get_veff</code><span class="sig-paren">(</span><em>ks</em>, <em>mol=None</em>, <em>dm=None</em>, <em>dm_last=0</em>, <em>vhf_last=0</em>, <em>hermi=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/dft/uks.html#get_veff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.dft.uks.get_veff" title="Permalink to this definition">¶</a></dt>
<dd><p>Coulomb + XC functional for UKS.  See pyscf/dft/rks.py
<a class="reference internal" href="#pyscf.dft.uks.get_veff" title="pyscf.dft.uks.get_veff"><code class="xref py py-func docutils literal"><span class="pre">get_veff()</span></code></a> fore more details.</p>
</dd></dl>

<span class="target" id="module-pyscf.dft.gen_grid"></span><p>Generate DFT grids and weights, based on the code provided by Gerald Knizia &lt;&gt;</p>
<dl class="docutils">
<dt>Reference for Lebedev-Laikov grid:</dt>
<dd>V. I. Lebedev, and D. N. Laikov &#8220;A quadrature formula for the sphere of the
131st algebraic order of accuracy&#8221;, Doklady Mathematics, 59, 477-481 (1999)</dd>
</dl>
<dl class="class">
<dt id="pyscf.dft.gen_grid.Grids">
<em class="property">class </em><code class="descclassname">pyscf.dft.gen_grid.</code><code class="descname">Grids</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/dft/gen_grid.html#Grids"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.dft.gen_grid.Grids" title="Permalink to this definition">¶</a></dt>
<dd><p>DFT mesh grids</p>
<dl class="docutils">
<dt>Attributes for Grids:</dt>
<dd><dl class="first docutils">
<dt>level</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int (0 - 9)</span><dd>big number for large mesh grids, default is 3</dd>
<dt>atomic_radii</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span><dd><div class="first last line-block">
<div class="line">radi.BRAGG_RADII  (default)</div>
<div class="line">radi.COVALENT_RADII</div>
<div class="line">None : to switch off atomic radii adjustment</div>
</div>
</dd>
<dt>radii_adjust</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(mol, atomic_radii) =&gt; (function(atom_id, atom_id, g) =&gt; array_like_g)</span><dd>Function to adjust atomic radii, can be one of
| radi.treutler_atomic_radii_adjust
| radi.becke_atomic_radii_adjust
| None : to switch off atomic radii adjustment</dd>
<dt>radi_method</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(n) =&gt; (rad_grids, rad_weights)</span><dd>scheme for radial grids, can be one of
| radi.treutler  (default)
| radi.delley
| radi.mura_knowles
| radi.gauss_chebyshev</dd>
<dt>becke_scheme</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(v) =&gt; array_like_v</span><dd>weight partition function, can be one of
| gen_grid.original_becke  (default)
| gen_grid.stratmann</dd>
<dt>prune</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(nuc, rad_grids, n_ang) =&gt; list_n_ang_for_each_rad_grid</span><dd>scheme to reduce number of grids, can be one of
| gen_grid.nwchem_prune  (default)
| gen_grid.sg1_prune
| gen_grid.treutler_prune
| None : to switch off grid pruning</dd>
<dt>symmetry</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>whether to symmetrize mesh grids (TODO)</dd>
<dt>atom_grid</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">dict</span><dd>Set (radial, angular) grids for particular atoms.
Eg, grids.atom_grid = {&#8216;H&#8217;: (20,110)} will generate 20 radial
grids and 110 angular grids for H atom.</dd>
<dt>level</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>To control the number of radial and angular grids.  The default
level 3 corresponds to
(50,302) for H, He;
(75,302) for second row;
(80~105,434) for rest.</dd>
</dl>
<p>Examples:</p>
<div class="last highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grids</span> <span class="o">=</span> <span class="n">dft</span><span class="o">.</span><span class="n">gen_grid</span><span class="o">.</span><span class="n">Grids</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grids</span><span class="o">.</span><span class="n">level</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grids</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>
</pre></div>
</div>
</dd>
</dl>
<dl class="method">
<dt id="pyscf.dft.gen_grid.Grids.gen_atomic_grids">
<code class="descname">gen_atomic_grids</code><span class="sig-paren">(</span><em>mol</em>, <em>atom_grid=None</em>, <em>radi_method=None</em>, <em>level=None</em>, <em>prune=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/dft/gen_grid.html#Grids.gen_atomic_grids"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.dft.gen_grid.Grids.gen_atomic_grids" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate number of radial grids and angular grids for the given molecule.</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>A dict, with the atom symbol for the dict key.  For each atom type,
the dict value has two items: one is the meshgrid coordinates wrt the
atom center; the second is the volume of that grid.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.dft.gen_grid.Grids.gen_partition">
<code class="descname">gen_partition</code><span class="sig-paren">(</span><em>mol</em>, <em>atom_grids_tab</em>, <em>radii_adjust=None</em>, <em>atomic_radii=array([ 0.</em>, <em>0.66140414</em>, <em>2.64561657</em>, <em>2.74010288</em>, <em>1.98421243</em>, <em>1.60626721</em>, <em>1.32280829</em>, <em>1.22832198</em>, <em>1.13383567</em>, <em>0.94486306</em>, <em>2.83458919</em>, <em>3.40150702</em>, <em>2.83458919</em>, <em>2.36215766</em>, <em>2.07869874</em>, <em>1.88972612</em>, <em>1.88972612</em>, <em>1.88972612</em>, <em>3.40150702</em>, <em>4.15739747</em>, <em>3.40150702</em>, <em>3.0235618</em>, <em>2.64561657</em>, <em>2.55113027</em>, <em>2.64561657</em>, <em>2.64561657</em>, <em>2.64561657</em>, <em>2.55113027</em>, <em>2.55113027</em>, <em>2.55113027</em>, <em>2.55113027</em>, <em>2.45664396</em>, <em>2.36215766</em>, <em>2.17318504</em>, <em>2.17318504</em>, <em>2.17318504</em>, <em>3.59047964</em>, <em>4.44085639</em>, <em>3.77945225</em>, <em>3.40150702</em>, <em>2.92907549</em>, <em>2.74010288</em>, <em>2.74010288</em>, <em>2.55113027</em>, <em>2.45664396</em>, <em>2.55113027</em>, <em>2.64561657</em>, <em>3.0235618</em>, <em>2.92907549</em>, <em>2.92907549</em>, <em>2.74010288</em>, <em>2.74010288</em>, <em>2.64561657</em>, <em>2.64561657</em>, <em>3.96842486</em>, <em>4.91328792</em>, <em>4.06291117</em>, <em>3.68496594</em>, <em>3.49599333</em>, <em>3.49599333</em>, <em>3.49599333</em>, <em>3.49599333</em>, <em>3.49599333</em>, <em>3.49599333</em>, <em>3.40150702</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>2.92907549</em>, <em>2.74010288</em>, <em>2.55113027</em>, <em>2.55113027</em>, <em>2.45664396</em>, <em>2.55113027</em>, <em>2.55113027</em>, <em>2.55113027</em>, <em>2.83458919</em>, <em>3.59047964</em>, <em>3.40150702</em>, <em>3.0235618</em>, <em>3.59047964</em>, <em>2.74010288</em>, <em>3.96842486</em>, <em>3.40150702</em>, <em>4.06291117</em>, <em>3.68496594</em>, <em>3.40150702</em>, <em>3.40150702</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072])</em>, <em>becke_scheme=&lt;function original_becke&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/dft/gen_grid.html#Grids.gen_partition"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.dft.gen_grid.Grids.gen_partition" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the mesh grid coordinates and weights for DFT numerical integration.
We can change radii_adjust, becke_scheme functions to generate different meshgrid.</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>grid_coord and grid_weight arrays.  grid_coord array has shape (N,3);
weight 1D array has N elements.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.dft.gen_grid.Grids.make_mask">
<code class="descname">make_mask</code><span class="sig-paren">(</span><em>mol=None</em>, <em>coords=None</em>, <em>relativity=0</em>, <em>shls_slice=None</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/dft/gen_grid.html#Grids.make_mask"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.dft.gen_grid.Grids.make_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Mask to indicate whether a shell is zero on grid</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">mol : an instance of <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></p>
<dl class="last docutils">
<dt>coords</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D array, shape (N,3)</span><dd>The coordinates of grids.</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>relativity</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>No effects.</dd>
<dt>shls_slice</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2-element list</span><dd>(shl_start, shl_end).
If given, only part of AOs (shl_start &lt;= shell_id &lt; shl_end) are
evaluated.  By default, all shells defined in mol will be evaluated.</dd>
<dt>verbose</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int or object of <code class="xref py py-class docutils literal"><span class="pre">Logger</span></code></span><dd>No effects.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>2D mask array of shape (N,nbas), where N is the number of grids, nbas
is the number of shells.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyscf.dft.gen_grid.gen_atomic_grids">
<code class="descclassname">pyscf.dft.gen_grid.</code><code class="descname">gen_atomic_grids</code><span class="sig-paren">(</span><em>mol</em>, <em>atom_grid={}</em>, <em>radi_method=&lt;function gauss_chebyshev&gt;</em>, <em>level=3</em>, <em>prune=&lt;function nwchem_prune&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/dft/gen_grid.html#gen_atomic_grids"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.dft.gen_grid.gen_atomic_grids" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate number of radial grids and angular grids for the given molecule.</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>A dict, with the atom symbol for the dict key.  For each atom type,
the dict value has two items: one is the meshgrid coordinates wrt the
atom center; the second is the volume of that grid.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.dft.gen_grid.gen_partition">
<code class="descclassname">pyscf.dft.gen_grid.</code><code class="descname">gen_partition</code><span class="sig-paren">(</span><em>mol</em>, <em>atom_grids_tab</em>, <em>radii_adjust=None</em>, <em>atomic_radii=array([ 0.</em>, <em>0.66140414</em>, <em>2.64561657</em>, <em>2.74010288</em>, <em>1.98421243</em>, <em>1.60626721</em>, <em>1.32280829</em>, <em>1.22832198</em>, <em>1.13383567</em>, <em>0.94486306</em>, <em>2.83458919</em>, <em>3.40150702</em>, <em>2.83458919</em>, <em>2.36215766</em>, <em>2.07869874</em>, <em>1.88972612</em>, <em>1.88972612</em>, <em>1.88972612</em>, <em>3.40150702</em>, <em>4.15739747</em>, <em>3.40150702</em>, <em>3.0235618</em>, <em>2.64561657</em>, <em>2.55113027</em>, <em>2.64561657</em>, <em>2.64561657</em>, <em>2.64561657</em>, <em>2.55113027</em>, <em>2.55113027</em>, <em>2.55113027</em>, <em>2.55113027</em>, <em>2.45664396</em>, <em>2.36215766</em>, <em>2.17318504</em>, <em>2.17318504</em>, <em>2.17318504</em>, <em>3.59047964</em>, <em>4.44085639</em>, <em>3.77945225</em>, <em>3.40150702</em>, <em>2.92907549</em>, <em>2.74010288</em>, <em>2.74010288</em>, <em>2.55113027</em>, <em>2.45664396</em>, <em>2.55113027</em>, <em>2.64561657</em>, <em>3.0235618</em>, <em>2.92907549</em>, <em>2.92907549</em>, <em>2.74010288</em>, <em>2.74010288</em>, <em>2.64561657</em>, <em>2.64561657</em>, <em>3.96842486</em>, <em>4.91328792</em>, <em>4.06291117</em>, <em>3.68496594</em>, <em>3.49599333</em>, <em>3.49599333</em>, <em>3.49599333</em>, <em>3.49599333</em>, <em>3.49599333</em>, <em>3.49599333</em>, <em>3.40150702</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>2.92907549</em>, <em>2.74010288</em>, <em>2.55113027</em>, <em>2.55113027</em>, <em>2.45664396</em>, <em>2.55113027</em>, <em>2.55113027</em>, <em>2.55113027</em>, <em>2.83458919</em>, <em>3.59047964</em>, <em>3.40150702</em>, <em>3.0235618</em>, <em>3.59047964</em>, <em>2.74010288</em>, <em>3.96842486</em>, <em>3.40150702</em>, <em>4.06291117</em>, <em>3.68496594</em>, <em>3.40150702</em>, <em>3.40150702</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072])</em>, <em>becke_scheme=&lt;function original_becke&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/dft/gen_grid.html#gen_partition"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.dft.gen_grid.gen_partition" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the mesh grid coordinates and weights for DFT numerical integration.
We can change radii_adjust, becke_scheme functions to generate different meshgrid.</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>grid_coord and grid_weight arrays.  grid_coord array has shape (N,3);
weight 1D array has N elements.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.dft.gen_grid.make_mask">
<code class="descclassname">pyscf.dft.gen_grid.</code><code class="descname">make_mask</code><span class="sig-paren">(</span><em>mol</em>, <em>coords</em>, <em>relativity=0</em>, <em>shls_slice=None</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/dft/gen_grid.html#make_mask"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.dft.gen_grid.make_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Mask to indicate whether a shell is zero on grid</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">mol : an instance of <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></p>
<dl class="last docutils">
<dt>coords</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D array, shape (N,3)</span><dd>The coordinates of grids.</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>relativity</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>No effects.</dd>
<dt>shls_slice</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2-element list</span><dd>(shl_start, shl_end).
If given, only part of AOs (shl_start &lt;= shell_id &lt; shl_end) are
evaluated.  By default, all shells defined in mol will be evaluated.</dd>
<dt>verbose</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int or object of <code class="xref py py-class docutils literal"><span class="pre">Logger</span></code></span><dd>No effects.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>2D mask array of shape (N,nbas), where N is the number of grids, nbas
is the number of shells.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.dft.gen_grid.nwchem_prune">
<code class="descclassname">pyscf.dft.gen_grid.</code><code class="descname">nwchem_prune</code><span class="sig-paren">(</span><em>nuc</em>, <em>rads</em>, <em>n_ang</em>, <em>radii=array([ 0.</em>, <em>0.66140414</em>, <em>2.64561657</em>, <em>2.74010288</em>, <em>1.98421243</em>, <em>1.60626721</em>, <em>1.32280829</em>, <em>1.22832198</em>, <em>1.13383567</em>, <em>0.94486306</em>, <em>2.83458919</em>, <em>3.40150702</em>, <em>2.83458919</em>, <em>2.36215766</em>, <em>2.07869874</em>, <em>1.88972612</em>, <em>1.88972612</em>, <em>1.88972612</em>, <em>3.40150702</em>, <em>4.15739747</em>, <em>3.40150702</em>, <em>3.0235618</em>, <em>2.64561657</em>, <em>2.55113027</em>, <em>2.64561657</em>, <em>2.64561657</em>, <em>2.64561657</em>, <em>2.55113027</em>, <em>2.55113027</em>, <em>2.55113027</em>, <em>2.55113027</em>, <em>2.45664396</em>, <em>2.36215766</em>, <em>2.17318504</em>, <em>2.17318504</em>, <em>2.17318504</em>, <em>3.59047964</em>, <em>4.44085639</em>, <em>3.77945225</em>, <em>3.40150702</em>, <em>2.92907549</em>, <em>2.74010288</em>, <em>2.74010288</em>, <em>2.55113027</em>, <em>2.45664396</em>, <em>2.55113027</em>, <em>2.64561657</em>, <em>3.0235618</em>, <em>2.92907549</em>, <em>2.92907549</em>, <em>2.74010288</em>, <em>2.74010288</em>, <em>2.64561657</em>, <em>2.64561657</em>, <em>3.96842486</em>, <em>4.91328792</em>, <em>4.06291117</em>, <em>3.68496594</em>, <em>3.49599333</em>, <em>3.49599333</em>, <em>3.49599333</em>, <em>3.49599333</em>, <em>3.49599333</em>, <em>3.49599333</em>, <em>3.40150702</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>2.92907549</em>, <em>2.74010288</em>, <em>2.55113027</em>, <em>2.55113027</em>, <em>2.45664396</em>, <em>2.55113027</em>, <em>2.55113027</em>, <em>2.55113027</em>, <em>2.83458919</em>, <em>3.59047964</em>, <em>3.40150702</em>, <em>3.0235618</em>, <em>3.59047964</em>, <em>2.74010288</em>, <em>3.96842486</em>, <em>3.40150702</em>, <em>4.06291117</em>, <em>3.68496594</em>, <em>3.40150702</em>, <em>3.40150702</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072</em>, <em>3.30702072])</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/dft/gen_grid.html#nwchem_prune"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.dft.gen_grid.nwchem_prune" title="Permalink to this definition">¶</a></dt>
<dd><p>NWChem</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>nuc</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Nuclear charge.</dd>
<dt>rads</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span><dd>Grid coordinates on radical axis.</dd>
<dt>n_ang</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Max number of grids over angular part.</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>radii</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span><dd>radii (in Bohr) for atoms in periodic table</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>A list has the same length as rads. The list element is the number of
grids over angular part for each radial grid.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.dft.gen_grid.original_becke">
<code class="descclassname">pyscf.dft.gen_grid.</code><code class="descname">original_becke</code><span class="sig-paren">(</span><em>g</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/dft/gen_grid.html#original_becke"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.dft.gen_grid.original_becke" title="Permalink to this definition">¶</a></dt>
<dd><p>Becke, JCP, 88, 2547 (1988)</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.dft.gen_grid.sg1_prune">
<code class="descclassname">pyscf.dft.gen_grid.</code><code class="descname">sg1_prune</code><span class="sig-paren">(</span><em>nuc</em>, <em>rads</em>, <em>n_ang</em>, <em>radii=array([ 0.</em>, <em>1.</em>, <em>0.5882</em>, <em>3.0769</em>, <em>2.0513</em>, <em>1.5385</em>, <em>1.2308</em>, <em>1.0256</em>, <em>0.8791</em>, <em>0.7692</em>, <em>0.6838</em>, <em>4.0909</em>, <em>3.1579</em>, <em>2.5714</em>, <em>2.1687</em>, <em>1.875</em>, <em>1.6514</em>, <em>1.4754</em>, <em>1.3333])</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/dft/gen_grid.html#sg1_prune"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.dft.gen_grid.sg1_prune" title="Permalink to this definition">¶</a></dt>
<dd><p>SG1, CPL, 209, 506</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>nuc</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Nuclear charge.</dd>
<dt>rads</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span><dd>Grid coordinates on radical axis.</dd>
<dt>n_ang</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Max number of grids over angular part.</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>radii</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span><dd>radii (in Bohr) for atoms in periodic table</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>A list has the same length as rads. The list element is the number of
grids over angular part for each radial grid.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.dft.gen_grid.stratmann">
<code class="descclassname">pyscf.dft.gen_grid.</code><code class="descname">stratmann</code><span class="sig-paren">(</span><em>g</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/dft/gen_grid.html#stratmann"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.dft.gen_grid.stratmann" title="Permalink to this definition">¶</a></dt>
<dd><p>Stratmann, Scuseria, Frisch. CPL, 257, 213 (1996)</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.dft.gen_grid.treutler_prune">
<code class="descclassname">pyscf.dft.gen_grid.</code><code class="descname">treutler_prune</code><span class="sig-paren">(</span><em>nuc</em>, <em>rads</em>, <em>n_ang</em>, <em>radii=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/dft/gen_grid.html#treutler_prune"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.dft.gen_grid.treutler_prune" title="Permalink to this definition">¶</a></dt>
<dd><p>Treutler-Ahlrichs</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>nuc</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Nuclear charge.</dd>
<dt>rads</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span><dd>Grid coordinates on radical axis.</dd>
<dt>n_ang</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Max number of grids over angular part.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>A list has the same length as rads. The list element is the number of
grids over angular part for each radial grid.</dd>
</dl>
</dd></dl>

<span class="target" id="module-pyscf.dft.numint"></span><dl class="function">
<dt id="pyscf.dft.numint.cache_xc_kernel">
<code class="descclassname">pyscf.dft.numint.</code><code class="descname">cache_xc_kernel</code><span class="sig-paren">(</span><em>ni</em>, <em>mol</em>, <em>grids</em>, <em>xc_code</em>, <em>mo_coeff</em>, <em>mo_occ</em>, <em>spin=0</em>, <em>max_memory=2000</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/dft/numint.html#cache_xc_kernel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.dft.numint.cache_xc_kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the 0th order density, Vxc and fxc.  They can be used in TDDFT,
DFT hessian module etc.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.dft.numint.eval_ao">
<code class="descclassname">pyscf.dft.numint.</code><code class="descname">eval_ao</code><span class="sig-paren">(</span><em>mol</em>, <em>coords</em>, <em>deriv=0</em>, <em>shls_slice=None</em>, <em>non0tab=None</em>, <em>out=None</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/dft/numint.html#eval_ao"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.dft.numint.eval_ao" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate AO function value on the given grids.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">mol : an instance of <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></p>
<dl class="last docutils">
<dt>coords</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D array, shape (N,3)</span><dd>The coordinates of the grids.</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>deriv</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>AO derivative order.  It affects the shape of the return array.
If deriv=0, the returned AO values are stored in a (N,nao) array.
Otherwise the AO values are stored in an array of shape (M,N,nao).
Here N is the number of grids, nao is the number of AO functions,
M is the size associated to the derivative deriv.</dd>
<dt>relativity</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>No effects.</dd>
<dt>shls_slice</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2-element list</span><dd>(shl_start, shl_end).
If given, only part of AOs (shl_start &lt;= shell_id &lt; shl_end) are
evaluated.  By default, all shells defined in mol will be evaluated.</dd>
<dt>non0tab</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D bool array</span><dd>mask array to indicate whether the AO values are zero.  The mask
array can be obtained by calling <code class="xref py py-func docutils literal"><span class="pre">make_mask()</span></code></dd>
<dt>out</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>If provided, results are written into this array.</dd>
<dt>verbose</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int or object of <code class="xref py py-class docutils literal"><span class="pre">Logger</span></code></span><dd>No effects.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>2D array of shape (N,nao) for AO values if deriv = 0.
Or 3D array of shape (:,N,nao) for AO values and AO derivatives if deriv &gt; 0.
In the 3D array, the first (N,nao) elements are the AO values,
followed by (3,N,nao) for x,y,z compoents;
Then 2nd derivatives (6,N,nao) for xx, xy, xz, yy, yz, zz;
Then 3rd derivatives (10,N,nao) for xxx, xxy, xxz, xyy, xyz, xzz, yyy, yyz, yzz, zzz;
...</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; H 0 0 1; H 0 1 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>  <span class="c1"># 100 random points</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">eval_ao</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ao_value</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(100, 24)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">eval_ao</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">deriv</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">shls_slice</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ao_value</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(4, 100, 7)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">eval_ao</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">deriv</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">shls_slice</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ao_value</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(10, 100, 7)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.dft.numint.eval_mat">
<code class="descclassname">pyscf.dft.numint.</code><code class="descname">eval_mat</code><span class="sig-paren">(</span><em>mol</em>, <em>ao</em>, <em>weight</em>, <em>rho</em>, <em>vxc</em>, <em>non0tab=None</em>, <em>xctype='LDA'</em>, <em>spin=0</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/dft/numint.html#eval_mat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.dft.numint.eval_mat" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate XC potential matrix.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">mol : an instance of <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></p>
<dl class="last docutils">
<dt>ao</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">([4/10,] ngrids, nao) ndarray</span><dd>2D array of shape (N,nao) for LDA,
3D array of shape (4,N,nao) for GGA
or (10,N,nao) for meta-GGA.
N is the number of grids, nao is the number of AO functions.
If xctype is GGA, ao[0] is AO value and ao[1:3] are the real space
gradients.  If xctype is meta-GGA, ao[4:10] are second derivatives
of ao values.</dd>
<dt>weight</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span><dd>Integral weights on grids.</dd>
<dt>rho</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">([4/6,] ngrids) ndarray</span><dd><p class="first">Shape of ((<em>,N)) for electron density (and derivatives) if spin = 0;
Shape of ((</em>,N),(<em>,N)) for alpha/beta electron density (and derivatives) if spin &gt; 0;
where N is number of grids.
rho (</em>,N) are ordered as (den,grad_x,grad_y,grad_z,laplacian,tau)
where grad_x = d/dx den, laplacian = nabla^2 den, tau = 1/2(nabla f)^2
In spin unrestricted case,
rho is ((den_u,grad_xu,grad_yu,grad_zu,laplacian_u,tau_u)</p>
<blockquote class="last">
<div>(den_d,grad_xd,grad_yd,grad_zd,laplacian_d,tau_d))</div></blockquote>
</dd>
<dt>vxc</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">([4,] ngrids) ndarray</span><dd>XC potential value on each grid = (vrho, vsigma, vlapl, vtau)
vsigma is GGA potential value on each grid.
If the kwarg spin is not 0, a list [vsigma_uu,vsigma_ud] is required.</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>xctype</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>LDA/GGA/mGGA.  It affects the shape of <cite>ao</cite> and <cite>rho</cite></dd>
<dt>non0tab</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D bool array</span><dd>mask array to indicate whether the AO values are zero.  The mask
array can be obtained by calling <code class="xref py py-func docutils literal"><span class="pre">make_mask()</span></code></dd>
<dt>spin</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>If not 0, the matrix is contracted with the spin non-degenerated
UKS formula</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>XC potential matrix in 2D array of shape (nao,nao) where nao is the
number of AO functions.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.dft.numint.eval_rho">
<code class="descclassname">pyscf.dft.numint.</code><code class="descname">eval_rho</code><span class="sig-paren">(</span><em>mol</em>, <em>ao</em>, <em>dm</em>, <em>non0tab=None</em>, <em>xctype='LDA'</em>, <em>hermi=0</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/dft/numint.html#eval_rho"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.dft.numint.eval_rho" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the electron density for LDA functional, and the density
derivatives for GGA functional.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">mol : an instance of <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></p>
<dl class="last docutils">
<dt>ao</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D array of shape (N,nao) for LDA, 3D array of shape (4,N,nao) for GGA</span><dd>or (5,N,nao) for meta-GGA.  N is the number of grids, nao is the
number of AO functions.  If xctype is GGA, ao[0] is AO value
and ao[1:3] are the AO gradients.  If xctype is meta-GGA, ao[4:10]
are second derivatives of ao values.</dd>
<dt>dm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D array</span><dd>Density matrix</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>non0tab</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D bool array</span><dd>mask array to indicate whether the AO values are zero.  The mask
array can be obtained by calling <code class="xref py py-func docutils literal"><span class="pre">make_mask()</span></code></dd>
<dt>xctype</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>LDA/GGA/mGGA.  It affects the shape of the return density.</dd>
<dt>hermi</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>dm is hermitian or not</dd>
<dt>verbose</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int or object of <code class="xref py py-class docutils literal"><span class="pre">Logger</span></code></span><dd>No effects.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>1D array of size N to store electron density if xctype = LDA;  2D array
of (4,N) to store density and &#8220;density derivatives&#8221; for x,y,z components
if xctype = GGA;  (6,N) array for meta-GGA, where last two rows are
nabla^2 rho and tau = 1/2(nabla f)^2</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; H 0 0 1; H 0 1 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>  <span class="c1"># 100 random points</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">eval_ao</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">deriv</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm</span> <span class="o">=</span> <span class="n">dm</span> <span class="o">+</span> <span class="n">dm</span><span class="o">.</span><span class="n">T</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span><span class="p">,</span> <span class="n">dx_rho</span><span class="p">,</span> <span class="n">dy_rho</span><span class="p">,</span> <span class="n">dz_rho</span> <span class="o">=</span> <span class="n">eval_rho</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">ao</span><span class="p">,</span> <span class="n">dm</span><span class="p">,</span> <span class="n">xctype</span><span class="o">=</span><span class="s1">&#39;LDA&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.dft.numint.eval_rho2">
<code class="descclassname">pyscf.dft.numint.</code><code class="descname">eval_rho2</code><span class="sig-paren">(</span><em>mol</em>, <em>ao</em>, <em>mo_coeff</em>, <em>mo_occ</em>, <em>non0tab=None</em>, <em>xctype='LDA'</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/dft/numint.html#eval_rho2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.dft.numint.eval_rho2" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the electron density for LDA functional, and the density
derivatives for GGA functional.  This function has the same functionality
as <a class="reference internal" href="#pyscf.dft.numint.eval_rho" title="pyscf.dft.numint.eval_rho"><code class="xref py py-func docutils literal"><span class="pre">eval_rho()</span></code></a> except that the density are evaluated based on orbital
coefficients and orbital occupancy.  It is more efficient than
<a class="reference internal" href="#pyscf.dft.numint.eval_rho" title="pyscf.dft.numint.eval_rho"><code class="xref py py-func docutils literal"><span class="pre">eval_rho()</span></code></a> in most scenario.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">mol : an instance of <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></p>
<dl class="last docutils">
<dt>ao</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D array of shape (N,nao) for LDA, 3D array of shape (4,N,nao) for GGA</span><dd>or (5,N,nao) for meta-GGA.  N is the number of grids, nao is the
number of AO functions.  If xctype is GGA, ao[0] is AO value
and ao[1:3] are the AO gradients.  If xctype is meta-GGA, ao[4:10]
are second derivatives of ao values.</dd>
<dt>dm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D array</span><dd>Density matrix</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>non0tab</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D bool array</span><dd>mask array to indicate whether the AO values are zero.  The mask
array can be obtained by calling <code class="xref py py-func docutils literal"><span class="pre">make_mask()</span></code></dd>
<dt>xctype</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>LDA/GGA/mGGA.  It affects the shape of the return density.</dd>
<dt>verbose</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int or object of <code class="xref py py-class docutils literal"><span class="pre">Logger</span></code></span><dd>No effects.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>1D array of size N to store electron density if xctype = LDA;  2D array
of (4,N) to store density and &#8220;density derivatives&#8221; for x,y,z components
if xctype = GGA;  (6,N) array for meta-GGA, where last two rows are
nabla^2 rho and tau = 1/2(nabla f)^2</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.dft.numint.large_rho_indices">
<code class="descclassname">pyscf.dft.numint.</code><code class="descname">large_rho_indices</code><span class="sig-paren">(</span><em>ni</em>, <em>mol</em>, <em>dm</em>, <em>grids</em>, <em>cutoff=1e-10</em>, <em>max_memory=2000</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/dft/numint.html#large_rho_indices"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.dft.numint.large_rho_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Indices of density which are larger than given cutoff</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.dft.numint.nr_fxc">
<code class="descclassname">pyscf.dft.numint.</code><code class="descname">nr_fxc</code><span class="sig-paren">(</span><em>mol</em>, <em>grids</em>, <em>xc_code</em>, <em>dm0</em>, <em>dms</em>, <em>spin=0</em>, <em>relativity=0</em>, <em>hermi=0</em>, <em>rho0=None</em>, <em>vxc=None</em>, <em>fxc=None</em>, <em>max_memory=2000</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/dft/numint.html#nr_fxc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.dft.numint.nr_fxc" title="Permalink to this definition">¶</a></dt>
<dd><p>Contract XC kernel matrix with given density matrices</p>
<p>... math:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">a_</span><span class="p">{</span><span class="n">pq</span><span class="p">}</span> <span class="o">=</span> <span class="n">f_</span><span class="p">{</span><span class="n">pq</span><span class="p">,</span><span class="n">rs</span><span class="p">}</span> <span class="o">*</span> <span class="n">x_</span><span class="p">{</span><span class="n">rs</span><span class="p">}</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.dft.numint.nr_rks">
<code class="descclassname">pyscf.dft.numint.</code><code class="descname">nr_rks</code><span class="sig-paren">(</span><em>ni</em>, <em>mol</em>, <em>grids</em>, <em>xc_code</em>, <em>dms</em>, <em>relativity=0</em>, <em>hermi=0</em>, <em>max_memory=2000</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/dft/numint.html#nr_rks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.dft.numint.nr_rks" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate RKS XC functional and potential matrix on given meshgrids
for a set of density matrices</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">ni : an instance of <code class="xref py py-class docutils literal"><span class="pre">_NumInt</span></code></p>
<p>mol : an instance of <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></p>
<dl class="last docutils">
<dt>grids</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">an instance of <code class="xref py py-class docutils literal"><span class="pre">Grids</span></code></span><dd>grids.coords and grids.weights are needed for coordinates and weights of meshgrids.</dd>
<dt>xc_code</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>XC functional description.
See <code class="xref py py-func docutils literal"><span class="pre">parse_xc()</span></code> of pyscf/dft/libxc.py for more details.</dd>
<dt>dms</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D array a list of 2D arrays</span><dd>Density matrix or multiple density matrices</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>hermi</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Input density matrices symmetric or not</dd>
<dt>max_memory</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int or float</span><dd>The maximum size of cache to use (in MB).</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>nelec, excsum, vmat.
nelec is the number of electrons generated by numerical integration.
excsum is the XC functional value.  vmat is the XC potential matrix in
2D array of shape (nao,nao) where nao is the number of AO functions.</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">dft</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grids</span> <span class="o">=</span> <span class="n">dft</span><span class="o">.</span><span class="n">gen_grid</span><span class="o">.</span><span class="n">Grids</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grids</span><span class="o">.</span><span class="n">coords</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>  <span class="c1"># 100 random points</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grids</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nelec</span><span class="p">,</span> <span class="n">exc</span><span class="p">,</span> <span class="n">vxc</span> <span class="o">=</span> <span class="n">dft</span><span class="o">.</span><span class="n">numint</span><span class="o">.</span><span class="n">nr_vxc</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">grids</span><span class="p">,</span> <span class="s1">&#39;lda,vwn&#39;</span><span class="p">,</span> <span class="n">dm</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.dft.numint.nr_rks_fxc">
<code class="descclassname">pyscf.dft.numint.</code><code class="descname">nr_rks_fxc</code><span class="sig-paren">(</span><em>ni</em>, <em>mol</em>, <em>grids</em>, <em>xc_code</em>, <em>dm0</em>, <em>dms</em>, <em>relativity=0</em>, <em>hermi=0</em>, <em>rho0=None</em>, <em>vxc=None</em>, <em>fxc=None</em>, <em>max_memory=2000</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/dft/numint.html#nr_rks_fxc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.dft.numint.nr_rks_fxc" title="Permalink to this definition">¶</a></dt>
<dd><p>Contract RKS XC (singlet hessian) kernel matrix with given density matrices</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">ni : an instance of <code class="xref py py-class docutils literal"><span class="pre">_NumInt</span></code></p>
<p>mol : an instance of <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></p>
<dl class="last docutils">
<dt>grids</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">an instance of <code class="xref py py-class docutils literal"><span class="pre">Grids</span></code></span><dd>grids.coords and grids.weights are needed for coordinates and weights of meshgrids.</dd>
<dt>xc_code</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>XC functional description.
See <code class="xref py py-func docutils literal"><span class="pre">parse_xc()</span></code> of pyscf/dft/libxc.py for more details.</dd>
<dt>dms</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D array a list of 2D arrays</span><dd>Density matrix or multiple density matrices</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>hermi</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Input density matrices symmetric or not</dd>
<dt>max_memory</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int or float</span><dd>The maximum size of cache to use (in MB).</dd>
<dt>rho0</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float array</span><dd>Zero-order density (and density derivative for GGA).  Giving kwargs rho0,
vxc and fxc to improve better performance.</dd>
<dt>vxc</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float array</span><dd>First order XC derivatives</dd>
<dt>fxc</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float array</span><dd>Second order XC derivatives</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>nelec, excsum, vmat.
nelec is the number of electrons generated by numerical integration.
excsum is the XC functional value.  vmat is the XC potential matrix in
2D array of shape (nao,nao) where nao is the number of AO functions.</dd>
</dl>
<p>Examples:</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.dft.numint.nr_rks_fxc_st">
<code class="descclassname">pyscf.dft.numint.</code><code class="descname">nr_rks_fxc_st</code><span class="sig-paren">(</span><em>ni</em>, <em>mol</em>, <em>grids</em>, <em>xc_code</em>, <em>dm0</em>, <em>dms_alpha</em>, <em>relativity=0</em>, <em>singlet=True</em>, <em>rho0=None</em>, <em>vxc=None</em>, <em>fxc=None</em>, <em>max_memory=2000</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/dft/numint.html#nr_rks_fxc_st"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.dft.numint.nr_rks_fxc_st" title="Permalink to this definition">¶</a></dt>
<dd><p>Associated to singlet or triplet Hessian
Note the difference to nr_rks_fxc, dms_alpha is the response density
matrices of alpha spin, alpha+/-beta DM is applied due to singlet/triplet
coupling</p>
<p>Ref. CPL, 256, 454</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.dft.numint.nr_rks_vxc">
<code class="descclassname">pyscf.dft.numint.</code><code class="descname">nr_rks_vxc</code><span class="sig-paren">(</span><em>ni</em>, <em>mol</em>, <em>grids</em>, <em>xc_code</em>, <em>dms</em>, <em>relativity=0</em>, <em>hermi=0</em>, <em>max_memory=2000</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.dft.numint.nr_rks_vxc" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate RKS XC functional and potential matrix on given meshgrids
for a set of density matrices</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">ni : an instance of <code class="xref py py-class docutils literal"><span class="pre">_NumInt</span></code></p>
<p>mol : an instance of <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></p>
<dl class="last docutils">
<dt>grids</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">an instance of <code class="xref py py-class docutils literal"><span class="pre">Grids</span></code></span><dd>grids.coords and grids.weights are needed for coordinates and weights of meshgrids.</dd>
<dt>xc_code</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>XC functional description.
See <code class="xref py py-func docutils literal"><span class="pre">parse_xc()</span></code> of pyscf/dft/libxc.py for more details.</dd>
<dt>dms</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D array a list of 2D arrays</span><dd>Density matrix or multiple density matrices</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>hermi</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Input density matrices symmetric or not</dd>
<dt>max_memory</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int or float</span><dd>The maximum size of cache to use (in MB).</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>nelec, excsum, vmat.
nelec is the number of electrons generated by numerical integration.
excsum is the XC functional value.  vmat is the XC potential matrix in
2D array of shape (nao,nao) where nao is the number of AO functions.</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">dft</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grids</span> <span class="o">=</span> <span class="n">dft</span><span class="o">.</span><span class="n">gen_grid</span><span class="o">.</span><span class="n">Grids</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grids</span><span class="o">.</span><span class="n">coords</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>  <span class="c1"># 100 random points</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grids</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nelec</span><span class="p">,</span> <span class="n">exc</span><span class="p">,</span> <span class="n">vxc</span> <span class="o">=</span> <span class="n">dft</span><span class="o">.</span><span class="n">numint</span><span class="o">.</span><span class="n">nr_vxc</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">grids</span><span class="p">,</span> <span class="s1">&#39;lda,vwn&#39;</span><span class="p">,</span> <span class="n">dm</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.dft.numint.nr_uks">
<code class="descclassname">pyscf.dft.numint.</code><code class="descname">nr_uks</code><span class="sig-paren">(</span><em>ni</em>, <em>mol</em>, <em>grids</em>, <em>xc_code</em>, <em>dms</em>, <em>relativity=0</em>, <em>hermi=0</em>, <em>max_memory=2000</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/dft/numint.html#nr_uks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.dft.numint.nr_uks" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate UKS XC functional and potential matrix on given meshgrids
for a set of density matrices</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">mol : an instance of <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></p>
<dl class="last docutils">
<dt>grids</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">an instance of <code class="xref py py-class docutils literal"><span class="pre">Grids</span></code></span><dd>grids.coords and grids.weights are needed for coordinates and weights of meshgrids.</dd>
<dt>xc_code</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>XC functional description.
See <code class="xref py py-func docutils literal"><span class="pre">parse_xc()</span></code> of pyscf/dft/libxc.py for more details.</dd>
<dt>dms</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">a list of 2D arrays</span><dd>A list of density matrices, stored as (alpha,alpha,...,beta,beta,...)</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>hermi</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Input density matrices symmetric or not</dd>
<dt>max_memory</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int or float</span><dd>The maximum size of cache to use (in MB).</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>nelec, excsum, vmat.
nelec is the number of (alpha,beta) electrons generated by numerical integration.
excsum is the XC functional value.
vmat is the XC potential matrix for (alpha,beta) spin.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.dft.numint.nr_uks_fxc">
<code class="descclassname">pyscf.dft.numint.</code><code class="descname">nr_uks_fxc</code><span class="sig-paren">(</span><em>ni</em>, <em>mol</em>, <em>grids</em>, <em>xc_code</em>, <em>dm0</em>, <em>dms</em>, <em>relativity=0</em>, <em>hermi=0</em>, <em>rho0=None</em>, <em>vxc=None</em>, <em>fxc=None</em>, <em>max_memory=2000</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/dft/numint.html#nr_uks_fxc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.dft.numint.nr_uks_fxc" title="Permalink to this definition">¶</a></dt>
<dd><p>Contract UKS XC kernel matrix with given density matrices</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">ni : an instance of <code class="xref py py-class docutils literal"><span class="pre">_NumInt</span></code></p>
<p>mol : an instance of <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></p>
<dl class="last docutils">
<dt>grids</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">an instance of <code class="xref py py-class docutils literal"><span class="pre">Grids</span></code></span><dd>grids.coords and grids.weights are needed for coordinates and weights of meshgrids.</dd>
<dt>xc_code</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>XC functional description.
See <code class="xref py py-func docutils literal"><span class="pre">parse_xc()</span></code> of pyscf/dft/libxc.py for more details.</dd>
<dt>dms</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D array a list of 2D arrays</span><dd>Density matrix or multiple density matrices</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>hermi</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Input density matrices symmetric or not</dd>
<dt>max_memory</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int or float</span><dd>The maximum size of cache to use (in MB).</dd>
<dt>rho0</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float array</span><dd>Zero-order density (and density derivative for GGA).  Giving kwargs rho0,
vxc and fxc to improve better performance.</dd>
<dt>vxc</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float array</span><dd>First order XC derivatives</dd>
<dt>fxc</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float array</span><dd>Second order XC derivatives</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>nelec, excsum, vmat.
nelec is the number of electrons generated by numerical integration.
excsum is the XC functional value.  vmat is the XC potential matrix in
2D array of shape (nao,nao) where nao is the number of AO functions.</dd>
</dl>
<p>Examples:</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.dft.numint.nr_uks_vxc">
<code class="descclassname">pyscf.dft.numint.</code><code class="descname">nr_uks_vxc</code><span class="sig-paren">(</span><em>ni</em>, <em>mol</em>, <em>grids</em>, <em>xc_code</em>, <em>dms</em>, <em>relativity=0</em>, <em>hermi=0</em>, <em>max_memory=2000</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.dft.numint.nr_uks_vxc" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate UKS XC functional and potential matrix on given meshgrids
for a set of density matrices</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">mol : an instance of <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></p>
<dl class="last docutils">
<dt>grids</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">an instance of <code class="xref py py-class docutils literal"><span class="pre">Grids</span></code></span><dd>grids.coords and grids.weights are needed for coordinates and weights of meshgrids.</dd>
<dt>xc_code</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>XC functional description.
See <code class="xref py py-func docutils literal"><span class="pre">parse_xc()</span></code> of pyscf/dft/libxc.py for more details.</dd>
<dt>dms</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">a list of 2D arrays</span><dd>A list of density matrices, stored as (alpha,alpha,...,beta,beta,...)</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>hermi</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Input density matrices symmetric or not</dd>
<dt>max_memory</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int or float</span><dd>The maximum size of cache to use (in MB).</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>nelec, excsum, vmat.
nelec is the number of (alpha,beta) electrons generated by numerical integration.
excsum is the XC functional value.
vmat is the XC potential matrix for (alpha,beta) spin.</dd>
</dl>
</dd></dl>

<span class="target" id="module-pyscf.dft.libxc"></span><p>XC functional, the interface to libxc
(<a class="reference external" href="http://www.tddft.org/programs/octopus/wiki/index.php/Libxc">http://www.tddft.org/programs/octopus/wiki/index.php/Libxc</a>)</p>
<dl class="function">
<dt id="pyscf.dft.libxc.define_xc">
<code class="descclassname">pyscf.dft.libxc.</code><code class="descname">define_xc</code><span class="sig-paren">(</span><em>ni</em>, <em>description</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/dft/libxc.html#define_xc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.dft.libxc.define_xc" title="Permalink to this definition">¶</a></dt>
<dd><p>Define XC functional.  See also <a class="reference internal" href="#pyscf.dft.libxc.eval_xc" title="pyscf.dft.libxc.eval_xc"><code class="xref py py-func docutils literal"><span class="pre">eval_xc()</span></code></a> for the rules of input description.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">ni : an instance of <code class="xref py py-class docutils literal"><span class="pre">_NumInt</span></code></p>
<dl class="last docutils">
<dt>description</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>A string to describe the linear combination of different XC functionals.
The X and C functional are separated by comma like &#8216;.8*LDA+.2*B86,VWN&#8217;.
If &#8220;HF&#8221; was appeared in the string, it stands for the exact exchange.</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; H 0 0 1; H 0 1 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">dft</span><span class="o">.</span><span class="n">RKS</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">define_xc_</span><span class="p">(</span><span class="n">mf</span><span class="o">.</span><span class="n">_numint</span><span class="p">,</span> <span class="s1">&#39;.2*HF + .08*LDA + .72*B88, .81*LYP + .19*VWN&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="go">-76.3783361189611</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">define_xc_</span><span class="p">(</span><span class="n">mf</span><span class="o">.</span><span class="n">_numint</span><span class="p">,</span> <span class="s1">&#39;LDA*.08 + .72*B88 + .2*HF, .81*LYP + .19*VWN&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="go">-76.3783361189611</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">eval_xc</span><span class="p">(</span><span class="n">xc_code</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">exc</span> <span class="o">=</span> <span class="mf">0.01</span> <span class="o">*</span> <span class="n">rho</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">... </span>    <span class="n">vrho</span> <span class="o">=</span> <span class="mf">0.01</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">rho</span>
<span class="gp">... </span>    <span class="n">vxc</span> <span class="o">=</span> <span class="p">(</span><span class="n">vrho</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">fxc</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># 2nd order functional derivative</span>
<span class="gp">... </span>    <span class="n">kxc</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># 3rd order functional derivative</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">exc</span><span class="p">,</span> <span class="n">vxc</span><span class="p">,</span> <span class="n">fxc</span><span class="p">,</span> <span class="n">kxc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">define_xc_</span><span class="p">(</span><span class="n">mf</span><span class="o">.</span><span class="n">_numint</span><span class="p">,</span> <span class="n">eval_xc</span><span class="p">,</span> <span class="n">xctype</span><span class="o">=</span><span class="s1">&#39;LDA&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="go">48.8525211046668</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.dft.libxc.define_xc_">
<code class="descclassname">pyscf.dft.libxc.</code><code class="descname">define_xc_</code><span class="sig-paren">(</span><em>ni</em>, <em>description</em>, <em>xctype='LDA'</em>, <em>hyb=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/dft/libxc.html#define_xc_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.dft.libxc.define_xc_" title="Permalink to this definition">¶</a></dt>
<dd><p>Define XC functional.  See also <a class="reference internal" href="#pyscf.dft.libxc.eval_xc" title="pyscf.dft.libxc.eval_xc"><code class="xref py py-func docutils literal"><span class="pre">eval_xc()</span></code></a> for the rules of input description.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">ni : an instance of <code class="xref py py-class docutils literal"><span class="pre">_NumInt</span></code></p>
<dl class="last docutils">
<dt>description</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>A string to describe the linear combination of different XC functionals.
The X and C functional are separated by comma like &#8216;.8*LDA+.2*B86,VWN&#8217;.
If &#8220;HF&#8221; was appeared in the string, it stands for the exact exchange.</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; H 0 0 1; H 0 1 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">dft</span><span class="o">.</span><span class="n">RKS</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">define_xc_</span><span class="p">(</span><span class="n">mf</span><span class="o">.</span><span class="n">_numint</span><span class="p">,</span> <span class="s1">&#39;.2*HF + .08*LDA + .72*B88, .81*LYP + .19*VWN&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="go">-76.3783361189611</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">define_xc_</span><span class="p">(</span><span class="n">mf</span><span class="o">.</span><span class="n">_numint</span><span class="p">,</span> <span class="s1">&#39;LDA*.08 + .72*B88 + .2*HF, .81*LYP + .19*VWN&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="go">-76.3783361189611</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">eval_xc</span><span class="p">(</span><span class="n">xc_code</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">exc</span> <span class="o">=</span> <span class="mf">0.01</span> <span class="o">*</span> <span class="n">rho</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">... </span>    <span class="n">vrho</span> <span class="o">=</span> <span class="mf">0.01</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">rho</span>
<span class="gp">... </span>    <span class="n">vxc</span> <span class="o">=</span> <span class="p">(</span><span class="n">vrho</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">fxc</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># 2nd order functional derivative</span>
<span class="gp">... </span>    <span class="n">kxc</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># 3rd order functional derivative</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">exc</span><span class="p">,</span> <span class="n">vxc</span><span class="p">,</span> <span class="n">fxc</span><span class="p">,</span> <span class="n">kxc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">define_xc_</span><span class="p">(</span><span class="n">mf</span><span class="o">.</span><span class="n">_numint</span><span class="p">,</span> <span class="n">eval_xc</span><span class="p">,</span> <span class="n">xctype</span><span class="o">=</span><span class="s1">&#39;LDA&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="go">48.8525211046668</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.dft.libxc.eval_xc">
<code class="descclassname">pyscf.dft.libxc.</code><code class="descname">eval_xc</code><span class="sig-paren">(</span><em>xc_code</em>, <em>rho</em>, <em>spin=0</em>, <em>relativity=0</em>, <em>deriv=1</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/dft/libxc.html#eval_xc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.dft.libxc.eval_xc" title="Permalink to this definition">¶</a></dt>
<dd><p>Interface to call libxc library to evaluate XC functional, potential
and functional derivatives.</p>
<ul class="simple">
<li>The given functional xc_code must be a one-line string.</li>
<li>The functional xc_code is case-insensitive.</li>
<li>The functional xc_code string has two parts, separated by &#8221;,&#8221;.  The
first part describes the exchange functional, the second is the correlation
functional.<ul>
<li>If &#8221;,&#8221; not appeared in string, the entire string is considered as X functional.</li>
<li>To neglect X functional (just apply C functional), leave blank in the
first part, eg description=&#8217;,vwn&#8217; for pure VWN functional</li>
</ul>
</li>
<li>The functional name can be placed in arbitrary order.  Two name needs to
be separated by operators &#8220;+&#8221; or &#8220;-&#8221;.  Blank spaces are ignored.
NOTE the parser only reads operators &#8220;+&#8221; &#8220;-&#8221; &#8220;*&#8221;.  / is not in support.</li>
<li>A functional name is associated with one factor.  If the factor is not
given, it is assumed equaling 1.</li>
<li>String &#8220;HF&#8221; stands for exact exchange (HF K matrix).  It is allowed to
put in C functional part.</li>
<li>Be careful with the libxc convention on GGA functional, in which the LDA
contribution is included.</li>
</ul>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>xc_code</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>A string to describe the linear combination of different XC functionals.
The X and C functional are separated by comma like &#8216;.8*LDA+.2*B86,VWN&#8217;.
If &#8220;HF&#8221; was appeared in the string, it stands for the exact exchange.</dd>
<dt>rho</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd><p class="first">Shape of ((<em>,N)) for electron density (and derivatives) if spin = 0;
Shape of ((</em>,N),(<em>,N)) for alpha/beta electron density (and derivatives) if spin &gt; 0;
where N is number of grids.
rho (</em>,N) are ordered as (den,grad_x,grad_y,grad_z,laplacian,tau)
where grad_x = d/dx den, laplacian = nabla^2 den, tau = 1/2(nabla f)^2
In spin unrestricted case,
rho is ((den_u,grad_xu,grad_yu,grad_zu,laplacian_u,tau_u)</p>
<blockquote class="last">
<div>(den_d,grad_xd,grad_yd,grad_zd,laplacian_d,tau_d))</div></blockquote>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>spin</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>spin polarized if spin &gt; 0</dd>
<dt>relativity</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>No effects.</dd>
<dt>verbose</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int or object of <code class="xref py py-class docutils literal"><span class="pre">Logger</span></code></span><dd>No effects.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><p class="first">ex, vxc, fxc, kxc</p>
<p>where</p>
<ul class="simple">
<li>vxc = (vrho, vsigma, vlapl, vtau) for restricted case</li>
<li>vxc for unrestricted case
| vrho[:,2]   = (u, d)
| vsigma[:,3] = (uu, ud, dd)
| vlapl[:,2]  = (u, d)
| vtau[:,2]   = (u, d)</li>
<li>fxc for restricted case:
(v2rho2, v2rhosigma, v2sigma2, v2lapl2, vtau2, v2rholapl, v2rhotau, v2lapltau, v2sigmalapl, v2sigmatau)</li>
<li>fxc for unrestricted case:
| v2rho2[:,3]     = (u_u, u_d, d_d)
| v2rhosigma[:,6] = (u_uu, u_ud, u_dd, d_uu, d_ud, d_dd)
| v2sigma2[:,6]   = (uu_uu, uu_ud, uu_dd, ud_ud, ud_dd, dd_dd)
| v2lapl2[:,3]
| vtau2[:,3]
| v2rholapl[:,4]
| v2rhotau[:,4]
| v2lapltau[:,4]
| v2sigmalapl[:,6]
| v2sigmatau[:,6]</li>
<li>kxc for restricted case:
(v3rho3, v3rho2sigma, v3rhosigma2, v3sigma3)</li>
<li>kxc for unrestricted case:
| v3rho3[:,4]       = (u_u_u, u_u_d, u_d_d, d_d_d)
| v3rho2sigma[:,9]  = (u_u_uu, u_u_ud, u_u_dd, u_d_uu, u_d_ud, u_d_dd, d_d_uu, d_d_ud, d_d_dd)
| v3rhosigma2[:,12] = (u_uu_uu, u_uu_ud, u_uu_dd, u_ud_ud, u_ud_dd, u_dd_dd, d_uu_uu, d_uu_ud, d_uu_dd, d_ud_ud, d_ud_dd, d_dd_dd)
| v3sigma3[:,10]    = (uu_uu_uu, uu_uu_ud, uu_uu_dd, uu_ud_ud, uu_ud_dd, uu_dd_dd, ud_ud_ud, ud_ud_dd, ud_dd_dd, dd_dd_dd)</li>
</ul>
<p class="last">see also libxc_itrf.c</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.dft.libxc.hybrid_coeff">
<code class="descclassname">pyscf.dft.libxc.</code><code class="descname">hybrid_coeff</code><span class="sig-paren">(</span><em>xc_code</em>, <em>spin=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/dft/libxc.html#hybrid_coeff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.dft.libxc.hybrid_coeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Support recursively defining hybrid functional</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.dft.libxc.parse_xc">
<code class="descclassname">pyscf.dft.libxc.</code><code class="descname">parse_xc</code><span class="sig-paren">(</span><em>description</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/dft/libxc.html#parse_xc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.dft.libxc.parse_xc" title="Permalink to this definition">¶</a></dt>
<dd><p>Rules to input functional description:</p>
<ul class="simple">
<li>The given functional description must be a one-line string.</li>
<li>The functional description is case-insensitive.</li>
<li>The functional description string has two parts, separated by &#8221;,&#8221;.  The
first part describes the exchange functional, the second is the correlation
functional.<ul>
<li>If &#8221;,&#8221; was not appeared in string, the entire string is considered as
X functional.</li>
<li>To neglect X functional (just apply C functional), leave blank in the
first part, eg description=&#8217;,vwn&#8217; for pure VWN functional</li>
</ul>
</li>
<li>The functional name can be placed in arbitrary order.  Two names need to
be separated by operators &#8220;+&#8221; or &#8220;-&#8221;.  Blank spaces are ignored.
NOTE the parser only reads operators &#8220;+&#8221; &#8220;-&#8221; &#8220;*&#8221;.  &#8220;/&#8221; is not supported.</li>
<li>A functional name is associated with one factor.  If the factor is not
given, it is assumed to equal 1.</li>
<li>String &#8220;HF&#8221; stands for exact exchange (HF K matrix).  It is allowed to
in the C functional part.</li>
<li>Be careful with the libxc convention on GGA functional, in which the LDA
contribution is included.</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="pyscf.dft.libxc.parse_xc_name">
<code class="descclassname">pyscf.dft.libxc.</code><code class="descname">parse_xc_name</code><span class="sig-paren">(</span><em>xc_name='LDA</em>, <em>VWN'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/dft/libxc.html#parse_xc_name"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.dft.libxc.parse_xc_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the XC functional name to libxc library internal ID.</p>
</dd></dl>

</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="tddft.html" class="btn btn-neutral float-right" title="tddft — Time dependent density functional theory" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="df.html" class="btn btn-neutral" title="df — Density fitting" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015-, Qiming Sun &lt;osirpt.sun@gmail.com&gt;.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.4.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: ''
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>