

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>9. fci — Full configuration interaction &mdash; PySCF 1.5.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="PySCF 1.5.0 documentation" href="index.html"/>
        <link rel="next" title="10. symm – Point group symmetry and spin symmetry" href="symm.html"/>
        <link rel="prev" title="8. mcscf — Multi-configurational self-consistent field" href="mcscf.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> PySCF
          

          
          </a>

          
            
            
              <div class="version">
                1.5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">1. An overview of PySCF</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">2. Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="install.html">3. Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="gto.html">4. gto &#8212; Molecular structure and GTO basis</a></li>
<li class="toctree-l1"><a class="reference internal" href="lib.html">5. <code class="docutils literal"><span class="pre">lib</span></code> &#8212; Helper functions, parameters, and C extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="scf.html">6. scf &#8212; Mean-field methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="ao2mo.html">7. ao2mo &#8212; Integral transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="mcscf.html">8. mcscf &#8212; Multi-configurational self-consistent field</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">9. fci &#8212; Full configuration interaction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-pyscf.fci.direct_spin1">9.1. direct CI</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-pyscf.fci.cistring">9.2. cistring</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-pyscf.fci.spin_op">9.3. spin operator</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-pyscf.fci.rdm">9.4. rdm</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-pyscf.fci.addons">9.5. addons</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="symm.html">10. symm &#8211; Point group symmetry and spin symmetry</a></li>
<li class="toctree-l1"><a class="reference internal" href="df.html">11. df &#8212; Density fitting</a></li>
<li class="toctree-l1"><a class="reference internal" href="dft.html">12. dft &#8212; Density functional theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="tddft.html">13. tddft &#8212; Time dependent density functional theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="cc.html">14. cc &#8212; Coupled cluster</a></li>
<li class="toctree-l1"><a class="reference internal" href="ci.html">15. ci &#8212; Configuration interaction</a></li>
<li class="toctree-l1"><a class="reference internal" href="dmrgscf.html">16. dmrgscf</a></li>
<li class="toctree-l1"><a class="reference internal" href="fciqmcscf.html">17. fciqmcscf</a></li>
<li class="toctree-l1"><a class="reference internal" href="tools.html">18. tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="grad.html">19. grad &#8212; Analytical nuclear gradients</a></li>
<li class="toctree-l1"><a class="reference internal" href="hessian.html">20. hessian &#8212; Analytical nuclear Hessian</a></li>
<li class="toctree-l1"><a class="reference internal" href="pbc.html">21. pbc &#8212; Periodic boundary conditions</a></li>
<li class="toctree-l1"><a class="reference internal" href="lo.html">22. lo &#8212; Orbital localization</a></li>
<li class="toctree-l1"><a class="reference internal" href="advanced.html">23. Miscellaneous</a></li>
<li class="toctree-l1"><a class="reference internal" href="qmmm.html">24. qmmm &#8212; QM/MM interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="mrpt.html">25. mrpt &#8212; Multi-reference perturbation theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="benchmark.html">26. Benchmark</a></li>
<li class="toctree-l1"><a class="reference internal" href="code-rule.html">27. Code standard</a></li>
<li class="toctree-l1"><a class="reference internal" href="version.html">28. Version history</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">PySCF</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>9. fci &#8212; Full configuration interaction</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/fci.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-pyscf.fci">
<span id="fci-full-configuration-interaction"></span><h1>9. fci &#8212; Full configuration interaction<a class="headerlink" href="#module-pyscf.fci" title="Permalink to this headline">¶</a></h1>
<dl class="docutils">
<dt>Different FCI solvers are implemented to support different type of symmetry.</dt>
<dd>Symmetry</dd>
</dl>
<p>File                Point group   Spin singlet   Real hermitian*    Alpha/beta degeneracy
direct_spin0_symm   Yes           Yes            Yes                Yes
direct_spin1_symm   Yes           No             Yes                Yes
direct_spin0        No            Yes            Yes                Yes
direct_spin1        No            No             Yes                Yes
direct_uhf          No            No             Yes                No
direct_nosym        No            No             No**               Yes</p>
<ul class="simple">
<li>Real hermitian Hamiltonian implies (ij|kl) = (ji|kl) = (ij|lk) = (ji|lk)</li>
</ul>
<p>** Hamiltonian is real but not hermitian, (ij|kl) != (ji|kl) ...</p>
<div class="section" id="module-pyscf.fci.direct_spin1">
<span id="direct-ci"></span><h2>9.1. direct CI<a class="headerlink" href="#module-pyscf.fci.direct_spin1" title="Permalink to this headline">¶</a></h2>
<p>Full CI solver for spin-free Hamiltonian.  This solver can be used to compute
doublet, triplet,...</p>
<p>The CI wfn are stored as a 2D array [alpha,beta], where each row corresponds
to an alpha string.  For each row (alpha string), there are
total-num-beta-strings of columns.  Each column corresponds to a beta string.</p>
<dl class="docutils">
<dt>Different FCI solvers are implemented to support different type of symmetry.</dt>
<dd>Symmetry</dd>
</dl>
<p>File                Point group   Spin singlet   Real hermitian*    Alpha/beta degeneracy
direct_spin0_symm   Yes           Yes            Yes                Yes
direct_spin1_symm   Yes           No             Yes                Yes
direct_spin0        No            Yes            Yes                Yes
direct_spin1        No            No             Yes                Yes
direct_uhf          No            No             Yes                No
direct_nosym        No            No             No**               Yes</p>
<ul class="simple">
<li>Real hermitian Hamiltonian implies (ij|kl) = (ji|kl) = (ij|lk) = (ji|lk)</li>
</ul>
<p>** Hamiltonian is real but not hermitian, (ij|kl) != (ji|kl) ...</p>
<dl class="attribute">
<dt id="pyscf.fci.direct_spin1.FCI">
<code class="descclassname">pyscf.fci.direct_spin1.</code><code class="descname">FCI</code><a class="headerlink" href="#pyscf.fci.direct_spin1.FCI" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pyscf.fci.direct_spin1.FCISolver" title="pyscf.fci.direct_spin1.FCISolver"><code class="xref py py-class docutils literal"><span class="pre">FCISolver</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="pyscf.fci.direct_spin1.FCISolver">
<em class="property">class </em><code class="descclassname">pyscf.fci.direct_spin1.</code><code class="descname">FCISolver</code><span class="sig-paren">(</span><em>mol=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/direct_spin1.html#FCISolver"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.FCISolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Full CI solver</p>
<dl class="docutils">
<dt>Attributes:</dt>
<dd><dl class="first last docutils">
<dt>verbose</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Print level.  Default value equals to <code class="xref py py-class docutils literal"><span class="pre">Mole.verbose</span></code>.</dd>
<dt>max_cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Total number of iterations. Default is 100</dd>
<dt>max_space</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">tuple of int</span><dd>Davidson iteration space size. Default is 14.</dd>
<dt>conv_tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Energy convergence tolerance. Default is 1e-10.</dd>
<dt>level_shift</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Level shift applied in the preconditioner to avoid singularity.
Default is 1e-3</dd>
<dt>davidson_only</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>By default, the entire Hamiltonian matrix will be constructed and
diagonalized if the system is small (see attribute pspace_size).
Setting this parameter to True will enforce the eigenvalue
problems being solved by Davidson subspace algorithm.  This flag
should be enabled when initial guess is given or particular spin
symmetry or point-group symmetry is required because the initial
guess or symmetry are completely ignored in the direct diagonlization.</dd>
<dt>pspace_size</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>The dimension of Hamiltonian matrix over which Davidson iteration
algorithm will be used for the eigenvalue problem.  Default is 400.
This is roughly corresponding to a (6e,6o) system.</dd>
<dt>nroots</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Number of states to be solved.  Default is 1, the ground state.</dd>
<dt>spin</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int or None</span><dd>Spin (2S = nalpha-nbeta) of the system.  If this attribute is None,
spin will be determined by the argument nelec (number of electrons)
of the kernel function.</dd>
<dt>wfnsym</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str or int</span><dd>Symmetry of wavefunction.  It is used only in direct_spin1_symm
and direct_spin0_symm solver.</dd>
</dl>
</dd>
</dl>
<p>Saved results</p>
<blockquote>
<div><dl class="docutils">
<dt>eci</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float or a list of float</span><dd>FCI energy(ies)</dd>
<dt>ci</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">nparray</span><dd>FCI wfn vector(s)</dd>
<dt>converged</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool (or a list of bool for multiple roots)</span><dd>Whether davidson iteration is converged</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">ao2mo</span><span class="p">,</span> <span class="n">fci</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;Li 0 0 0; Li 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h1</span> <span class="o">=</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mf</span><span class="o">.</span><span class="n">get_hcore</span><span class="p">())</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eri</span> <span class="o">=</span> <span class="n">ao2mo</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cisolver</span> <span class="o">=</span> <span class="n">fci</span><span class="o">.</span><span class="n">direct_spin1</span><span class="o">.</span><span class="n">FCI</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="p">,</span> <span class="n">ci</span> <span class="o">=</span> <span class="n">cisolver</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">h1</span><span class="p">,</span> <span class="n">eri</span><span class="p">,</span> <span class="n">h1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">mol</span><span class="o">.</span><span class="n">nelec</span><span class="p">,</span> <span class="n">ecore</span><span class="o">=</span><span class="n">mol</span><span class="o">.</span><span class="n">energy_nuc</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="go">-14.4197890826</span>
</pre></div>
</div>
<dl class="method">
<dt id="pyscf.fci.direct_spin1.FCISolver.absorb_h1e">
<code class="descname">absorb_h1e</code><span class="sig-paren">(</span><em>h1e</em>, <em>eri</em>, <em>norb</em>, <em>nelec</em>, <em>fac=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/direct_spin1.html#FCISolver.absorb_h1e"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.FCISolver.absorb_h1e" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify 2e Hamiltonian to include 1e Hamiltonian contribution.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.fci.direct_spin1.FCISolver.contract_1e">
<code class="descname">contract_1e</code><span class="sig-paren">(</span><em>f1e</em>, <em>fcivec</em>, <em>norb</em>, <em>nelec</em>, <em>link_index=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/direct_spin1.html#FCISolver.contract_1e"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.FCISolver.contract_1e" title="Permalink to this definition">¶</a></dt>
<dd><p>Contract the 1-electron Hamiltonian with a FCI vector to get a new FCI
vector.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.fci.direct_spin1.FCISolver.contract_2e">
<code class="descname">contract_2e</code><span class="sig-paren">(</span><em>eri</em>, <em>fcivec</em>, <em>norb</em>, <em>nelec</em>, <em>link_index=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/direct_spin1.html#FCISolver.contract_2e"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.FCISolver.contract_2e" title="Permalink to this definition">¶</a></dt>
<dd><p>Contract the 2-electron Hamiltonian with a FCI vector to get a new FCI
vector.</p>
<p>Note the input arg eri is NOT the 2e hamiltonian matrix, the 2e hamiltonian is</p>
<div class="math">
\[\begin{split}h2e &amp;= eri_{pq,rs} p^+ q r^+ s \\
    &amp;= (pq|rs) p^+ r^+ s q - (pq|rs) \delta_{qr} p^+ s\end{split}\]</div>
<p>So eri is defined as</p>
<div class="math">
\[eri_{pq,rs} = (pq|rs) - (1/Nelec) \sum_q (pq|qs)\]</div>
<p>to restore the symmetry between pq and rs,</p>
<div class="math">
\[eri_{pq,rs} = (pq|rs) - (.5/Nelec) [\sum_q (pq|qs) + \sum_p (pq|rp)]\]</div>
<p>See also <code class="xref py py-func docutils literal"><span class="pre">direct_spin1.absorb_h1e()</span></code></p>
</dd></dl>

<dl class="method">
<dt id="pyscf.fci.direct_spin1.FCISolver.energy">
<code class="descname">energy</code><span class="sig-paren">(</span><em>h1e</em>, <em>eri</em>, <em>fcivec</em>, <em>norb</em>, <em>nelec</em>, <em>link_index=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/direct_spin1.html#FCISolver.energy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.FCISolver.energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the FCI electronic energy for given Hamiltonian and FCI vector.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.fci.direct_spin1.FCISolver.get_init_guess">
<code class="descname">get_init_guess</code><span class="sig-paren">(</span><em>norb</em>, <em>nelec</em>, <em>nroots</em>, <em>hdiag</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/direct_spin1.html#FCISolver.get_init_guess"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.FCISolver.get_init_guess" title="Permalink to this definition">¶</a></dt>
<dd><p>Initial guess is the single Slater determinant</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.fci.direct_spin1.FCISolver.make_hdiag">
<code class="descname">make_hdiag</code><span class="sig-paren">(</span><em>h1e</em>, <em>eri</em>, <em>norb</em>, <em>nelec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/direct_spin1.html#FCISolver.make_hdiag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.FCISolver.make_hdiag" title="Permalink to this definition">¶</a></dt>
<dd><p>Diagonal Hamiltonian for Davidson preconditioner</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.fci.direct_spin1.FCISolver.make_rdm1">
<code class="descname">make_rdm1</code><span class="sig-paren">(</span><em>fcivec</em>, <em>norb</em>, <em>nelec</em>, <em>link_index=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/direct_spin1.html#FCISolver.make_rdm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.FCISolver.make_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin-traced one-particle density matrix</p>
<p>dm1[p,q] = &lt;q_alpha^dagger p_alpha&gt; + &lt;q_beta^dagger p_beta&gt;</p>
<p>The convention is based on McWeeney&#8217;s book, Eq (5.4.20)
The contraction between 1-particle Hamiltonian and rdm1 is
E = einsum(&#8216;pq,qp&#8217;, h1, rdm1)</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.fci.direct_spin1.FCISolver.make_rdm12">
<code class="descname">make_rdm12</code><span class="sig-paren">(</span><em>fcivec</em>, <em>norb</em>, <em>nelec</em>, <em>link_index=None</em>, <em>reorder=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/direct_spin1.html#FCISolver.make_rdm12"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.FCISolver.make_rdm12" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin traced 1- and 2-particle density matrices.</p>
<dl class="docutils">
<dt>1pdm[p,q] = :math:<a href="#id1"><span class="problematic" id="id2">`</span></a>langle <a href="#id19"><span class="problematic" id="id20">q_</span></a>alpha^dagger <a href="#id21"><span class="problematic" id="id22">p_</span></a>alpha rangle +</dt>
<dd>langle <a href="#id23"><span class="problematic" id="id24">q_</span></a>beta^dagger  <a href="#id25"><span class="problematic" id="id26">p_</span></a>beta rangle`;</dd>
<dt>2pdm[p,q,r,s] = :math:<a href="#id3"><span class="problematic" id="id4">`</span></a>langle <a href="#id27"><span class="problematic" id="id28">p_</span></a>alpha^dagger <a href="#id29"><span class="problematic" id="id30">r_</span></a>alpha^dagger <a href="#id31"><span class="problematic" id="id32">s_</span></a>alpha <a href="#id33"><span class="problematic" id="id34">q_</span></a>alpharangle +</dt>
<dd>langle <a href="#id35"><span class="problematic" id="id36">p_</span></a>beta^dagger  <a href="#id37"><span class="problematic" id="id38">r_</span></a>alpha^dagger <a href="#id39"><span class="problematic" id="id40">s_</span></a>alpha <a href="#id41"><span class="problematic" id="id42">q_</span></a>betarangle +
langle <a href="#id43"><span class="problematic" id="id44">p_</span></a>alpha^dagger <a href="#id45"><span class="problematic" id="id46">r_</span></a>beta^dagger  <a href="#id47"><span class="problematic" id="id48">s_</span></a>beta  <a href="#id49"><span class="problematic" id="id50">q_</span></a>alpharangle +
langle <a href="#id51"><span class="problematic" id="id52">p_</span></a>beta^dagger  <a href="#id53"><span class="problematic" id="id54">r_</span></a>beta^dagger  <a href="#id55"><span class="problematic" id="id56">s_</span></a>beta  <a href="#id57"><span class="problematic" id="id58">q_</span></a>betarangle`.</dd>
</dl>
<p>Energy should be computed as
E = einsum(&#8216;pq,qp&#8217;, h1, 1pdm) + 1/2 * einsum(&#8216;pqrs,pqrs&#8217;, eri, 2pdm)
where h1[p,q] = &lt;p|h|q&gt; and eri[p,q,r,s] = (pq|rs)</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.fci.direct_spin1.FCISolver.make_rdm12s">
<code class="descname">make_rdm12s</code><span class="sig-paren">(</span><em>fcivec</em>, <em>norb</em>, <em>nelec</em>, <em>link_index=None</em>, <em>reorder=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/direct_spin1.html#FCISolver.make_rdm12s"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.FCISolver.make_rdm12s" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin separated 1- and 2-particle density matrices.
The return values include two lists, a list of 1-particle density matrices
and a list of 2-particle density matrices.  The density matrices are:
(alpha,alpha), (beta,beta) for 1-particle density matrices;
(alpha,alpha,alpha,alpha), (alpha,alpha,beta,beta),
(beta,beta,beta,beta) for 2-particle density matrices.</p>
<p>1pdm[p,q] = <span class="math">\(\langle q^\dagger p\rangle\)</span>;
2pdm[p,q,r,s] = <span class="math">\(\langle p^\dagger r^\dagger s q\rangle\)</span>.</p>
<p>Energy should be computed as
E = einsum(&#8216;pq,qp&#8217;, h1, 1pdm) + 1/2 * einsum(&#8216;pqrs,pqrs&#8217;, eri, 2pdm)
where h1[p,q] = &lt;p|h|q&gt; and eri[p,q,r,s] = (pq|rs)</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.fci.direct_spin1.FCISolver.make_rdm1s">
<code class="descname">make_rdm1s</code><span class="sig-paren">(</span><em>fcivec</em>, <em>norb</em>, <em>nelec</em>, <em>link_index=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/direct_spin1.html#FCISolver.make_rdm1s"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.FCISolver.make_rdm1s" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin separated 1-particle density matrices.
The return values include two density matrices: (alpha,alpha), (beta,beta)</p>
<p>dm1[p,q] = &lt;q^dagger p&gt;</p>
<p>The convention is based on McWeeney&#8217;s book, Eq (5.4.20).
The contraction between 1-particle Hamiltonian and rdm1 is
E = einsum(&#8216;pq,qp&#8217;, h1, rdm1)</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.fci.direct_spin1.FCISolver.make_rdm2">
<code class="descname">make_rdm2</code><span class="sig-paren">(</span><em>fcivec</em>, <em>norb</em>, <em>nelec</em>, <em>link_index=None</em>, <em>reorder=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/direct_spin1.html#FCISolver.make_rdm2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.FCISolver.make_rdm2" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin traced 2-particle density matrice</p>
<p>NOTE the 2pdm is <span class="math">\(\langle p^\dagger q^\dagger s r\rangle\)</span> but
stored as [p,r,q,s]</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.fci.direct_spin1.FCISolver.pspace">
<code class="descname">pspace</code><span class="sig-paren">(</span><em>h1e</em>, <em>eri</em>, <em>norb</em>, <em>nelec</em>, <em>hdiag=None</em>, <em>np=400</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/direct_spin1.html#FCISolver.pspace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.FCISolver.pspace" title="Permalink to this definition">¶</a></dt>
<dd><p>pspace Hamiltonian to improve Davidson preconditioner. See, CPL, 169, 463</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.fci.direct_spin1.FCISolver.spin_square">
<code class="descname">spin_square</code><span class="sig-paren">(</span><em>fcivec</em>, <em>norb</em>, <em>nelec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/direct_spin1.html#FCISolver.spin_square"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.FCISolver.spin_square" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin square for RHF-FCI CI wfn only (obtained from spin-degenerated
Hamiltonian)</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.fci.direct_spin1.FCISolver.trans_rdm1">
<code class="descname">trans_rdm1</code><span class="sig-paren">(</span><em>cibra</em>, <em>ciket</em>, <em>norb</em>, <em>nelec</em>, <em>link_index=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/direct_spin1.html#FCISolver.trans_rdm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.FCISolver.trans_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin traced transition 1-particle transition density matrices.</p>
<dl class="docutils">
<dt>1pdm[p,q] = :math:<a href="#id5"><span class="problematic" id="id6">`</span></a>langle <a href="#id59"><span class="problematic" id="id60">q_</span></a>alpha^dagger <a href="#id61"><span class="problematic" id="id62">p_</span></a>alpha rangle</dt>
<dd><ul class="first last simple">
<li>langle <a href="#id63"><span class="problematic" id="id64">q_</span></a>beta^dagger <a href="#id65"><span class="problematic" id="id66">p_</span></a>beta rangle`</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.fci.direct_spin1.FCISolver.trans_rdm12">
<code class="descname">trans_rdm12</code><span class="sig-paren">(</span><em>cibra</em>, <em>ciket</em>, <em>norb</em>, <em>nelec</em>, <em>link_index=None</em>, <em>reorder=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/direct_spin1.html#FCISolver.trans_rdm12"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.FCISolver.trans_rdm12" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin traced transition 1- and 2-particle transition density matrices.</p>
<p>1pdm[p,q] = <span class="math">\(\langle q^\dagger p\rangle\)</span>;
2pdm[p,q,r,s] = <span class="math">\(\langle p^\dagger r^\dagger s q\rangle\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.fci.direct_spin1.FCISolver.trans_rdm12s">
<code class="descname">trans_rdm12s</code><span class="sig-paren">(</span><em>cibra</em>, <em>ciket</em>, <em>norb</em>, <em>nelec</em>, <em>link_index=None</em>, <em>reorder=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/direct_spin1.html#FCISolver.trans_rdm12s"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.FCISolver.trans_rdm12s" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin separated 1- and 2-particle transition density matrices.
The return values include two lists, a list of 1-particle transition
density matrices and a list of 2-particle transition density matrices.
The density matrices are:
(alpha,alpha), (beta,beta) for 1-particle transition density matrices;
(alpha,alpha,alpha,alpha), (alpha,alpha,beta,beta),
(beta,beta,alpha,alpha), (beta,beta,beta,beta) for 2-particle transition
density matrices.</p>
<p>1pdm[p,q] = <span class="math">\(\langle q^\dagger p\rangle\)</span>;
2pdm[p,q,r,s] = <span class="math">\(\langle p^\dagger r^\dagger s q\rangle\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.fci.direct_spin1.FCISolver.trans_rdm1s">
<code class="descname">trans_rdm1s</code><span class="sig-paren">(</span><em>cibra</em>, <em>ciket</em>, <em>norb</em>, <em>nelec</em>, <em>link_index=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/direct_spin1.html#FCISolver.trans_rdm1s"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.FCISolver.trans_rdm1s" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin separated transition 1-particle density matrices.
The return values include two density matrices: (alpha,alpha), (beta,beta).
See also function <a class="reference internal" href="#pyscf.fci.direct_spin1.make_rdm1s" title="pyscf.fci.direct_spin1.make_rdm1s"><code class="xref py py-func docutils literal"><span class="pre">make_rdm1s()</span></code></a></p>
<p>1pdm[p,q] = <span class="math">\(\langle q^\dagger p \rangle\)</span></p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyscf.fci.direct_spin1.absorb_h1e">
<code class="descclassname">pyscf.fci.direct_spin1.</code><code class="descname">absorb_h1e</code><span class="sig-paren">(</span><em>h1e</em>, <em>eri</em>, <em>norb</em>, <em>nelec</em>, <em>fac=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/direct_spin1.html#absorb_h1e"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.absorb_h1e" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify 2e Hamiltonian to include 1e Hamiltonian contribution.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.direct_spin1.contract_1e">
<code class="descclassname">pyscf.fci.direct_spin1.</code><code class="descname">contract_1e</code><span class="sig-paren">(</span><em>f1e</em>, <em>fcivec</em>, <em>norb</em>, <em>nelec</em>, <em>link_index=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/direct_spin1.html#contract_1e"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.contract_1e" title="Permalink to this definition">¶</a></dt>
<dd><p>Contract the 1-electron Hamiltonian with a FCI vector to get a new FCI
vector.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.direct_spin1.contract_2e">
<code class="descclassname">pyscf.fci.direct_spin1.</code><code class="descname">contract_2e</code><span class="sig-paren">(</span><em>eri</em>, <em>fcivec</em>, <em>norb</em>, <em>nelec</em>, <em>link_index=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/direct_spin1.html#contract_2e"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.contract_2e" title="Permalink to this definition">¶</a></dt>
<dd><p>Contract the 2-electron Hamiltonian with a FCI vector to get a new FCI
vector.</p>
<p>Note the input arg eri is NOT the 2e hamiltonian matrix, the 2e hamiltonian is</p>
<div class="math">
\[\begin{split}h2e &amp;= eri_{pq,rs} p^+ q r^+ s \\
    &amp;= (pq|rs) p^+ r^+ s q - (pq|rs) \delta_{qr} p^+ s\end{split}\]</div>
<p>So eri is defined as</p>
<div class="math">
\[eri_{pq,rs} = (pq|rs) - (1/Nelec) \sum_q (pq|qs)\]</div>
<p>to restore the symmetry between pq and rs,</p>
<div class="math">
\[eri_{pq,rs} = (pq|rs) - (.5/Nelec) [\sum_q (pq|qs) + \sum_p (pq|rp)]\]</div>
<p>See also <code class="xref py py-func docutils literal"><span class="pre">direct_spin1.absorb_h1e()</span></code></p>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.direct_spin1.energy">
<code class="descclassname">pyscf.fci.direct_spin1.</code><code class="descname">energy</code><span class="sig-paren">(</span><em>h1e</em>, <em>eri</em>, <em>fcivec</em>, <em>norb</em>, <em>nelec</em>, <em>link_index=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/direct_spin1.html#energy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the FCI electronic energy for given Hamiltonian and FCI vector.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.direct_spin1.get_init_guess">
<code class="descclassname">pyscf.fci.direct_spin1.</code><code class="descname">get_init_guess</code><span class="sig-paren">(</span><em>norb</em>, <em>nelec</em>, <em>nroots</em>, <em>hdiag</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/direct_spin1.html#get_init_guess"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.get_init_guess" title="Permalink to this definition">¶</a></dt>
<dd><p>Initial guess is the single Slater determinant</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.direct_spin1.make_hdiag">
<code class="descclassname">pyscf.fci.direct_spin1.</code><code class="descname">make_hdiag</code><span class="sig-paren">(</span><em>h1e</em>, <em>eri</em>, <em>norb</em>, <em>nelec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/direct_spin1.html#make_hdiag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.make_hdiag" title="Permalink to this definition">¶</a></dt>
<dd><p>Diagonal Hamiltonian for Davidson preconditioner</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.direct_spin1.make_rdm1">
<code class="descclassname">pyscf.fci.direct_spin1.</code><code class="descname">make_rdm1</code><span class="sig-paren">(</span><em>fcivec</em>, <em>norb</em>, <em>nelec</em>, <em>link_index=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/direct_spin1.html#make_rdm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.make_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin-traced one-particle density matrix</p>
<p>dm1[p,q] = &lt;q_alpha^dagger p_alpha&gt; + &lt;q_beta^dagger p_beta&gt;</p>
<p>The convention is based on McWeeney&#8217;s book, Eq (5.4.20)
The contraction between 1-particle Hamiltonian and rdm1 is
E = einsum(&#8216;pq,qp&#8217;, h1, rdm1)</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.direct_spin1.make_rdm12">
<code class="descclassname">pyscf.fci.direct_spin1.</code><code class="descname">make_rdm12</code><span class="sig-paren">(</span><em>fcivec</em>, <em>norb</em>, <em>nelec</em>, <em>link_index=None</em>, <em>reorder=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/direct_spin1.html#make_rdm12"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.make_rdm12" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin traced 1- and 2-particle density matrices.</p>
<dl class="docutils">
<dt>1pdm[p,q] = :math:<a href="#id7"><span class="problematic" id="id8">`</span></a>langle <a href="#id67"><span class="problematic" id="id68">q_</span></a>alpha^dagger <a href="#id69"><span class="problematic" id="id70">p_</span></a>alpha rangle +</dt>
<dd>langle <a href="#id71"><span class="problematic" id="id72">q_</span></a>beta^dagger  <a href="#id73"><span class="problematic" id="id74">p_</span></a>beta rangle`;</dd>
<dt>2pdm[p,q,r,s] = :math:<a href="#id9"><span class="problematic" id="id10">`</span></a>langle <a href="#id75"><span class="problematic" id="id76">p_</span></a>alpha^dagger <a href="#id77"><span class="problematic" id="id78">r_</span></a>alpha^dagger <a href="#id79"><span class="problematic" id="id80">s_</span></a>alpha <a href="#id81"><span class="problematic" id="id82">q_</span></a>alpharangle +</dt>
<dd>langle <a href="#id83"><span class="problematic" id="id84">p_</span></a>beta^dagger  <a href="#id85"><span class="problematic" id="id86">r_</span></a>alpha^dagger <a href="#id87"><span class="problematic" id="id88">s_</span></a>alpha <a href="#id89"><span class="problematic" id="id90">q_</span></a>betarangle +
langle <a href="#id91"><span class="problematic" id="id92">p_</span></a>alpha^dagger <a href="#id93"><span class="problematic" id="id94">r_</span></a>beta^dagger  <a href="#id95"><span class="problematic" id="id96">s_</span></a>beta  <a href="#id97"><span class="problematic" id="id98">q_</span></a>alpharangle +
langle <a href="#id99"><span class="problematic" id="id100">p_</span></a>beta^dagger  <a href="#id101"><span class="problematic" id="id102">r_</span></a>beta^dagger  <a href="#id103"><span class="problematic" id="id104">s_</span></a>beta  <a href="#id105"><span class="problematic" id="id106">q_</span></a>betarangle`.</dd>
</dl>
<p>Energy should be computed as
E = einsum(&#8216;pq,qp&#8217;, h1, 1pdm) + 1/2 * einsum(&#8216;pqrs,pqrs&#8217;, eri, 2pdm)
where h1[p,q] = &lt;p|h|q&gt; and eri[p,q,r,s] = (pq|rs)</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.direct_spin1.make_rdm12s">
<code class="descclassname">pyscf.fci.direct_spin1.</code><code class="descname">make_rdm12s</code><span class="sig-paren">(</span><em>fcivec</em>, <em>norb</em>, <em>nelec</em>, <em>link_index=None</em>, <em>reorder=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/direct_spin1.html#make_rdm12s"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.make_rdm12s" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin separated 1- and 2-particle density matrices.
The return values include two lists, a list of 1-particle density matrices
and a list of 2-particle density matrices.  The density matrices are:
(alpha,alpha), (beta,beta) for 1-particle density matrices;
(alpha,alpha,alpha,alpha), (alpha,alpha,beta,beta),
(beta,beta,beta,beta) for 2-particle density matrices.</p>
<p>1pdm[p,q] = <span class="math">\(\langle q^\dagger p\rangle\)</span>;
2pdm[p,q,r,s] = <span class="math">\(\langle p^\dagger r^\dagger s q\rangle\)</span>.</p>
<p>Energy should be computed as
E = einsum(&#8216;pq,qp&#8217;, h1, 1pdm) + 1/2 * einsum(&#8216;pqrs,pqrs&#8217;, eri, 2pdm)
where h1[p,q] = &lt;p|h|q&gt; and eri[p,q,r,s] = (pq|rs)</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.direct_spin1.make_rdm1s">
<code class="descclassname">pyscf.fci.direct_spin1.</code><code class="descname">make_rdm1s</code><span class="sig-paren">(</span><em>fcivec</em>, <em>norb</em>, <em>nelec</em>, <em>link_index=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/direct_spin1.html#make_rdm1s"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.make_rdm1s" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin separated 1-particle density matrices.
The return values include two density matrices: (alpha,alpha), (beta,beta)</p>
<p>dm1[p,q] = &lt;q^dagger p&gt;</p>
<p>The convention is based on McWeeney&#8217;s book, Eq (5.4.20).
The contraction between 1-particle Hamiltonian and rdm1 is
E = einsum(&#8216;pq,qp&#8217;, h1, rdm1)</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.direct_spin1.pspace">
<code class="descclassname">pyscf.fci.direct_spin1.</code><code class="descname">pspace</code><span class="sig-paren">(</span><em>h1e</em>, <em>eri</em>, <em>norb</em>, <em>nelec</em>, <em>hdiag=None</em>, <em>np=400</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/direct_spin1.html#pspace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.pspace" title="Permalink to this definition">¶</a></dt>
<dd><p>pspace Hamiltonian to improve Davidson preconditioner. See, CPL, 169, 463</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.direct_spin1.trans_rdm1">
<code class="descclassname">pyscf.fci.direct_spin1.</code><code class="descname">trans_rdm1</code><span class="sig-paren">(</span><em>cibra</em>, <em>ciket</em>, <em>norb</em>, <em>nelec</em>, <em>link_index=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/direct_spin1.html#trans_rdm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.trans_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin traced transition 1-particle transition density matrices.</p>
<dl class="docutils">
<dt>1pdm[p,q] = :math:<a href="#id11"><span class="problematic" id="id12">`</span></a>langle <a href="#id107"><span class="problematic" id="id108">q_</span></a>alpha^dagger <a href="#id109"><span class="problematic" id="id110">p_</span></a>alpha rangle</dt>
<dd><ul class="first last simple">
<li>langle <a href="#id111"><span class="problematic" id="id112">q_</span></a>beta^dagger <a href="#id113"><span class="problematic" id="id114">p_</span></a>beta rangle`</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.direct_spin1.trans_rdm12">
<code class="descclassname">pyscf.fci.direct_spin1.</code><code class="descname">trans_rdm12</code><span class="sig-paren">(</span><em>cibra</em>, <em>ciket</em>, <em>norb</em>, <em>nelec</em>, <em>link_index=None</em>, <em>reorder=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/direct_spin1.html#trans_rdm12"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.trans_rdm12" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin traced transition 1- and 2-particle transition density matrices.</p>
<p>1pdm[p,q] = <span class="math">\(\langle q^\dagger p\rangle\)</span>;
2pdm[p,q,r,s] = <span class="math">\(\langle p^\dagger r^\dagger s q\rangle\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.direct_spin1.trans_rdm12s">
<code class="descclassname">pyscf.fci.direct_spin1.</code><code class="descname">trans_rdm12s</code><span class="sig-paren">(</span><em>cibra</em>, <em>ciket</em>, <em>norb</em>, <em>nelec</em>, <em>link_index=None</em>, <em>reorder=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/direct_spin1.html#trans_rdm12s"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.trans_rdm12s" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin separated 1- and 2-particle transition density matrices.
The return values include two lists, a list of 1-particle transition
density matrices and a list of 2-particle transition density matrices.
The density matrices are:
(alpha,alpha), (beta,beta) for 1-particle transition density matrices;
(alpha,alpha,alpha,alpha), (alpha,alpha,beta,beta),
(beta,beta,alpha,alpha), (beta,beta,beta,beta) for 2-particle transition
density matrices.</p>
<p>1pdm[p,q] = <span class="math">\(\langle q^\dagger p\rangle\)</span>;
2pdm[p,q,r,s] = <span class="math">\(\langle p^\dagger r^\dagger s q\rangle\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.direct_spin1.trans_rdm1s">
<code class="descclassname">pyscf.fci.direct_spin1.</code><code class="descname">trans_rdm1s</code><span class="sig-paren">(</span><em>cibra</em>, <em>ciket</em>, <em>norb</em>, <em>nelec</em>, <em>link_index=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/direct_spin1.html#trans_rdm1s"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.trans_rdm1s" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin separated transition 1-particle density matrices.
The return values include two density matrices: (alpha,alpha), (beta,beta).
See also function <a class="reference internal" href="#pyscf.fci.direct_spin1.make_rdm1s" title="pyscf.fci.direct_spin1.make_rdm1s"><code class="xref py py-func docutils literal"><span class="pre">make_rdm1s()</span></code></a></p>
<p>1pdm[p,q] = <span class="math">\(\langle q^\dagger p \rangle\)</span></p>
</dd></dl>

<span class="target" id="module-pyscf.fci.direct_spin1_symm"></span><dl class="docutils">
<dt>Different FCI solvers are implemented to support different type of symmetry.</dt>
<dd>Symmetry</dd>
</dl>
<p>File                Point group   Spin singlet   Real hermitian*    Alpha/beta degeneracy
direct_spin0_symm   Yes           Yes            Yes                Yes
direct_spin1_symm   Yes           No             Yes                Yes
direct_spin0        No            Yes            Yes                Yes
direct_spin1        No            No             Yes                Yes
direct_uhf          No            No             Yes                No
direct_nosym        No            No             No**               Yes</p>
<ul class="simple">
<li>Real hermitian Hamiltonian implies (ij|kl) = (ji|kl) = (ij|lk) = (ji|lk)</li>
</ul>
<p>** Hamiltonian is real but not hermitian, (ij|kl) != (ji|kl) ...</p>
<span class="target" id="module-pyscf.fci.direct_spin0"></span><p>FCI solver for Singlet state</p>
<dl class="docutils">
<dt>Different FCI solvers are implemented to support different type of symmetry.</dt>
<dd>Symmetry</dd>
</dl>
<p>File                Point group   Spin singlet   Real hermitian*    Alpha/beta degeneracy
direct_spin0_symm   Yes           Yes            Yes                Yes
direct_spin1_symm   Yes           No             Yes                Yes
direct_spin0        No            Yes            Yes                Yes
direct_spin1        No            No             Yes                Yes
direct_uhf          No            No             Yes                No
direct_nosym        No            No             No**               Yes</p>
<ul class="simple">
<li>Real hermitian Hamiltonian implies (ij|kl) = (ji|kl) = (ij|lk) = (ji|lk)</li>
</ul>
<p>** Hamiltonian is real but not hermitian, (ij|kl) != (ji|kl) ...</p>
<dl class="function">
<dt id="pyscf.fci.direct_spin0.contract_1e">
<code class="descclassname">pyscf.fci.direct_spin0.</code><code class="descname">contract_1e</code><span class="sig-paren">(</span><em>f1e</em>, <em>fcivec</em>, <em>norb</em>, <em>nelec</em>, <em>link_index=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/direct_spin0.html#contract_1e"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin0.contract_1e" title="Permalink to this definition">¶</a></dt>
<dd><p>Contract the 1-electron Hamiltonian with a FCI vector to get a new FCI
vector.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.direct_spin0.contract_2e">
<code class="descclassname">pyscf.fci.direct_spin0.</code><code class="descname">contract_2e</code><span class="sig-paren">(</span><em>eri</em>, <em>fcivec</em>, <em>norb</em>, <em>nelec</em>, <em>link_index=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/direct_spin0.html#contract_2e"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin0.contract_2e" title="Permalink to this definition">¶</a></dt>
<dd><p>Contract the 2-electron Hamiltonian with a FCI vector to get a new FCI
vector.</p>
<p>Note the input arg eri is NOT the 2e hamiltonian matrix, the 2e hamiltonian is</p>
<div class="math">
\[\begin{split}h2e &amp;= eri_{pq,rs} p^+ q r^+ s \\
    &amp;= (pq|rs) p^+ r^+ s q - (pq|rs) \delta_{qr} p^+ s\end{split}\]</div>
<p>So eri is defined as</p>
<div class="math">
\[eri_{pq,rs} = (pq|rs) - (1/Nelec) \sum_q (pq|qs)\]</div>
<p>to restore the symmetry between pq and rs,</p>
<div class="math">
\[eri_{pq,rs} = (pq|rs) - (.5/Nelec) [\sum_q (pq|qs) + \sum_p (pq|rp)]\]</div>
<p>See also <code class="xref py py-func docutils literal"><span class="pre">direct_spin1.absorb_h1e()</span></code></p>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.direct_spin0.make_hdiag">
<code class="descclassname">pyscf.fci.direct_spin0.</code><code class="descname">make_hdiag</code><span class="sig-paren">(</span><em>h1e</em>, <em>eri</em>, <em>norb</em>, <em>nelec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/direct_spin0.html#make_hdiag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin0.make_hdiag" title="Permalink to this definition">¶</a></dt>
<dd><p>Diagonal Hamiltonian for Davidson preconditioner</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.direct_spin0.make_rdm1">
<code class="descclassname">pyscf.fci.direct_spin0.</code><code class="descname">make_rdm1</code><span class="sig-paren">(</span><em>fcivec</em>, <em>norb</em>, <em>nelec</em>, <em>link_index=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/direct_spin0.html#make_rdm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin0.make_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin-traced one-particle density matrix</p>
<p>dm1[p,q] = &lt;q_alpha^dagger p_alpha&gt; + &lt;q_beta^dagger p_beta&gt;</p>
<p>The convention is based on McWeeney&#8217;s book, Eq (5.4.20)
The contraction between 1-particle Hamiltonian and rdm1 is
E = einsum(&#8216;pq,qp&#8217;, h1, rdm1)</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.direct_spin0.make_rdm12">
<code class="descclassname">pyscf.fci.direct_spin0.</code><code class="descname">make_rdm12</code><span class="sig-paren">(</span><em>fcivec</em>, <em>norb</em>, <em>nelec</em>, <em>link_index=None</em>, <em>reorder=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/direct_spin0.html#make_rdm12"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin0.make_rdm12" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin traced 1- and 2-particle density matrices.</p>
<dl class="docutils">
<dt>1pdm[p,q] = :math:<a href="#id13"><span class="problematic" id="id14">`</span></a>langle <a href="#id115"><span class="problematic" id="id116">q_</span></a>alpha^dagger <a href="#id117"><span class="problematic" id="id118">p_</span></a>alpha rangle +</dt>
<dd>langle <a href="#id119"><span class="problematic" id="id120">q_</span></a>beta^dagger  <a href="#id121"><span class="problematic" id="id122">p_</span></a>beta rangle`;</dd>
<dt>2pdm[p,q,r,s] = :math:<a href="#id15"><span class="problematic" id="id16">`</span></a>langle <a href="#id123"><span class="problematic" id="id124">p_</span></a>alpha^dagger <a href="#id125"><span class="problematic" id="id126">r_</span></a>alpha^dagger <a href="#id127"><span class="problematic" id="id128">s_</span></a>alpha <a href="#id129"><span class="problematic" id="id130">q_</span></a>alpharangle +</dt>
<dd>langle <a href="#id131"><span class="problematic" id="id132">p_</span></a>beta^dagger  <a href="#id133"><span class="problematic" id="id134">r_</span></a>alpha^dagger <a href="#id135"><span class="problematic" id="id136">s_</span></a>alpha <a href="#id137"><span class="problematic" id="id138">q_</span></a>betarangle +
langle <a href="#id139"><span class="problematic" id="id140">p_</span></a>alpha^dagger <a href="#id141"><span class="problematic" id="id142">r_</span></a>beta^dagger  <a href="#id143"><span class="problematic" id="id144">s_</span></a>beta  <a href="#id145"><span class="problematic" id="id146">q_</span></a>alpharangle +
langle <a href="#id147"><span class="problematic" id="id148">p_</span></a>beta^dagger  <a href="#id149"><span class="problematic" id="id150">r_</span></a>beta^dagger  <a href="#id151"><span class="problematic" id="id152">s_</span></a>beta  <a href="#id153"><span class="problematic" id="id154">q_</span></a>betarangle`.</dd>
</dl>
<p>Energy should be computed as
E = einsum(&#8216;pq,qp&#8217;, h1, 1pdm) + 1/2 * einsum(&#8216;pqrs,pqrs&#8217;, eri, 2pdm)
where h1[p,q] = &lt;p|h|q&gt; and eri[p,q,r,s] = (pq|rs)</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.direct_spin0.make_rdm1s">
<code class="descclassname">pyscf.fci.direct_spin0.</code><code class="descname">make_rdm1s</code><span class="sig-paren">(</span><em>fcivec</em>, <em>norb</em>, <em>nelec</em>, <em>link_index=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/direct_spin0.html#make_rdm1s"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin0.make_rdm1s" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin separated 1-particle density matrices.
The return values include two density matrices: (alpha,alpha), (beta,beta)</p>
<p>dm1[p,q] = &lt;q^dagger p&gt;</p>
<p>The convention is based on McWeeney&#8217;s book, Eq (5.4.20).
The contraction between 1-particle Hamiltonian and rdm1 is
E = einsum(&#8216;pq,qp&#8217;, h1, rdm1)</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.direct_spin0.trans_rdm1">
<code class="descclassname">pyscf.fci.direct_spin0.</code><code class="descname">trans_rdm1</code><span class="sig-paren">(</span><em>cibra</em>, <em>ciket</em>, <em>norb</em>, <em>nelec</em>, <em>link_index=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/direct_spin0.html#trans_rdm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin0.trans_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin traced transition 1-particle transition density matrices.</p>
<dl class="docutils">
<dt>1pdm[p,q] = :math:<a href="#id17"><span class="problematic" id="id18">`</span></a>langle <a href="#id155"><span class="problematic" id="id156">q_</span></a>alpha^dagger <a href="#id157"><span class="problematic" id="id158">p_</span></a>alpha rangle</dt>
<dd><ul class="first last simple">
<li>langle <a href="#id159"><span class="problematic" id="id160">q_</span></a>beta^dagger <a href="#id161"><span class="problematic" id="id162">p_</span></a>beta rangle`</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.direct_spin0.trans_rdm12">
<code class="descclassname">pyscf.fci.direct_spin0.</code><code class="descname">trans_rdm12</code><span class="sig-paren">(</span><em>cibra</em>, <em>ciket</em>, <em>norb</em>, <em>nelec</em>, <em>link_index=None</em>, <em>reorder=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/direct_spin0.html#trans_rdm12"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin0.trans_rdm12" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin traced transition 1- and 2-particle transition density matrices.</p>
<p>1pdm[p,q] = <span class="math">\(\langle q^\dagger p\rangle\)</span>;
2pdm[p,q,r,s] = <span class="math">\(\langle p^\dagger r^\dagger s q\rangle\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.direct_spin0.trans_rdm1s">
<code class="descclassname">pyscf.fci.direct_spin0.</code><code class="descname">trans_rdm1s</code><span class="sig-paren">(</span><em>cibra</em>, <em>ciket</em>, <em>norb</em>, <em>nelec</em>, <em>link_index=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/direct_spin0.html#trans_rdm1s"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin0.trans_rdm1s" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin separated transition 1-particle density matrices.
The return values include two density matrices: (alpha,alpha), (beta,beta).
See also function <a class="reference internal" href="#pyscf.fci.direct_spin0.make_rdm1s" title="pyscf.fci.direct_spin0.make_rdm1s"><code class="xref py py-func docutils literal"><span class="pre">make_rdm1s()</span></code></a></p>
<p>1pdm[p,q] = <span class="math">\(\langle q^\dagger p \rangle\)</span></p>
</dd></dl>

<span class="target" id="module-pyscf.fci.direct_spin0_symm"></span><dl class="docutils">
<dt>Different FCI solvers are implemented to support different type of symmetry.</dt>
<dd>Symmetry</dd>
</dl>
<p>File                Point group   Spin singlet   Real hermitian*    Alpha/beta degeneracy
direct_spin0_symm   Yes           Yes            Yes                Yes
direct_spin1_symm   Yes           No             Yes                Yes
direct_spin0        No            Yes            Yes                Yes
direct_spin1        No            No             Yes                Yes
direct_uhf          No            No             Yes                No
direct_nosym        No            No             No**               Yes</p>
<ul class="simple">
<li>Real hermitian Hamiltonian implies (ij|kl) = (ji|kl) = (ij|lk) = (ji|lk)</li>
</ul>
<p>** Hamiltonian is real but not hermitian, (ij|kl) != (ji|kl) ...</p>
<span class="target" id="module-pyscf.fci.direct_uhf"></span><dl class="docutils">
<dt>Different FCI solvers are implemented to support different type of symmetry.</dt>
<dd>Symmetry</dd>
</dl>
<p>File                Point group   Spin singlet   Real hermitian*    Alpha/beta degeneracy
direct_spin0_symm   Yes           Yes            Yes                Yes
direct_spin1_symm   Yes           No             Yes                Yes
direct_spin0        No            Yes            Yes                Yes
direct_spin1        No            No             Yes                Yes
direct_uhf          No            No             Yes                No
direct_nosym        No            No             No**               Yes</p>
<ul class="simple">
<li>Real hermitian Hamiltonian implies (ij|kl) = (ji|kl) = (ij|lk) = (ji|lk)</li>
</ul>
<p>** Hamiltonian is real but not hermitian, (ij|kl) != (ji|kl) ...</p>
</div>
<div class="section" id="module-pyscf.fci.cistring">
<span id="cistring"></span><h2>9.2. cistring<a class="headerlink" href="#module-pyscf.fci.cistring" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pyscf.fci.cistring.addr2str">
<code class="descclassname">pyscf.fci.cistring.</code><code class="descname">addr2str</code><span class="sig-paren">(</span><em>norb</em>, <em>nelec</em>, <em>addr</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/cistring.html#addr2str"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.cistring.addr2str" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert CI determinant address to string</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.cistring.addrs2str">
<code class="descclassname">pyscf.fci.cistring.</code><code class="descname">addrs2str</code><span class="sig-paren">(</span><em>norb</em>, <em>nelec</em>, <em>addrs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/cistring.html#addrs2str"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.cistring.addrs2str" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a list of CI determinant address to string</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.cistring.gen_cre_str_index">
<code class="descclassname">pyscf.fci.cistring.</code><code class="descname">gen_cre_str_index</code><span class="sig-paren">(</span><em>orb_list</em>, <em>nelec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/cistring.html#gen_cre_str_index"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.cistring.gen_cre_str_index" title="Permalink to this definition">¶</a></dt>
<dd><p>linkstr_index to map between N electron string to N+1 electron string.
It maps the given string to the address of the string which is generated by
the creation operator.</p>
<p>For given string str0, index[str0] is nvir x 4 array.  Each entry
[i(cre),&#8211;,str1,sign] means starting from str0, creating i, to get str1.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.cistring.gen_cre_str_index_o0">
<code class="descclassname">pyscf.fci.cistring.</code><code class="descname">gen_cre_str_index_o0</code><span class="sig-paren">(</span><em>orb_list</em>, <em>nelec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/cistring.html#gen_cre_str_index_o0"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.cistring.gen_cre_str_index_o0" title="Permalink to this definition">¶</a></dt>
<dd><p>Slow version of gen_cre_str_index function</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.cistring.gen_cre_str_index_o1">
<code class="descclassname">pyscf.fci.cistring.</code><code class="descname">gen_cre_str_index_o1</code><span class="sig-paren">(</span><em>orb_list</em>, <em>nelec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/cistring.html#gen_cre_str_index_o1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.cistring.gen_cre_str_index_o1" title="Permalink to this definition">¶</a></dt>
<dd><p>C implementation of gen_cre_str_index function</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.cistring.gen_des_str_index">
<code class="descclassname">pyscf.fci.cistring.</code><code class="descname">gen_des_str_index</code><span class="sig-paren">(</span><em>orb_list</em>, <em>nelec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/cistring.html#gen_des_str_index"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.cistring.gen_des_str_index" title="Permalink to this definition">¶</a></dt>
<dd><p>linkstr_index to map between N electron string to N-1 electron string.
It maps the given string to the address of the string which is generated by
the annihilation operator.</p>
<p>For given string str0, index[str0] is nvir x 4 array.  Each entry
[&#8211;,i(des),str1,sign] means starting from str0, annihilating i, to get str1.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.cistring.gen_des_str_index_o0">
<code class="descclassname">pyscf.fci.cistring.</code><code class="descname">gen_des_str_index_o0</code><span class="sig-paren">(</span><em>orb_list</em>, <em>nelec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/cistring.html#gen_des_str_index_o0"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.cistring.gen_des_str_index_o0" title="Permalink to this definition">¶</a></dt>
<dd><p>Slow version of gen_des_str_index function</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.cistring.gen_des_str_index_o1">
<code class="descclassname">pyscf.fci.cistring.</code><code class="descname">gen_des_str_index_o1</code><span class="sig-paren">(</span><em>orb_list</em>, <em>nelec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/cistring.html#gen_des_str_index_o1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.cistring.gen_des_str_index_o1" title="Permalink to this definition">¶</a></dt>
<dd><p>C implementation of gen_des_str_index function</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.cistring.gen_linkstr_index">
<code class="descclassname">pyscf.fci.cistring.</code><code class="descname">gen_linkstr_index</code><span class="sig-paren">(</span><em>orb_list</em>, <em>nocc</em>, <em>strs=None</em>, <em>tril=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/cistring.html#gen_linkstr_index"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.cistring.gen_linkstr_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Look up table, for the strings relationship in terms of a
creation-annihilating operator pair.</p>
<p>For given string str0, index[str0] is (nocc+nocc*nvir) x 4 array.
The first nocc rows [i(:occ),i(:occ),str0,sign] are occupied-occupied
excitations, which do not change the string. The next nocc*nvir rows
[a(:vir),i(:occ),str1,sign] are occupied-virtual exciations, starting from
str0, annihilating i, creating a, to get str1.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.cistring.gen_linkstr_index_trilidx">
<code class="descclassname">pyscf.fci.cistring.</code><code class="descname">gen_linkstr_index_trilidx</code><span class="sig-paren">(</span><em>orb_list</em>, <em>nocc</em>, <em>strs=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/cistring.html#gen_linkstr_index_trilidx"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.cistring.gen_linkstr_index_trilidx" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate linkstr_index with the assumption that <span class="math">\(p^+ q|0\rangle\)</span>
where <span class="math">\(p &gt; q\)</span>.
So the resultant link_index has the structure <code class="docutils literal"><span class="pre">[pq,</span> <span class="pre">*,</span> <span class="pre">str1,</span> <span class="pre">sign]</span></code>.
It is identical to a call to <code class="docutils literal"><span class="pre">reform_linkstr_index(gen_linkstr_index(...))</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.cistring.gen_strings4orblist">
<code class="descclassname">pyscf.fci.cistring.</code><code class="descname">gen_strings4orblist</code><span class="sig-paren">(</span><em>orb_list</em>, <em>nelec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/cistring.html#gen_strings4orblist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.cistring.gen_strings4orblist" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate string from the given orbital list.</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>list of int64.  One int64 element represents one string in binary format.
The binary format takes the convention that the one bit stands for one
orbital, bit-1 means occupied and bit-0 means unoccupied.  The lowest
(right-most) bit corresponds to the lowest orbital in the orb_list.</dd>
</dl>
<p>Exampels:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="nb">bin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">gen_strings4orblist</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="mi">2</span><span class="p">)]</span>
<span class="go">[0b11, 0b101, 0b110, 0b1001, 0b1010, 0b1100]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="nb">bin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">gen_strings4orblist</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="mi">2</span><span class="p">)]</span>
<span class="go">[0b1010, 0b1001, 0b11, 0b1100, 0b110, 0b101]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.cistring.reform_linkstr_index">
<code class="descclassname">pyscf.fci.cistring.</code><code class="descname">reform_linkstr_index</code><span class="sig-paren">(</span><em>link_index</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/cistring.html#reform_linkstr_index"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.cistring.reform_linkstr_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Compress the (a, i) pair index in linkstr_index to a lower triangular
index, to match the 4-fold symmetry of integrals.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.cistring.str2addr">
<code class="descclassname">pyscf.fci.cistring.</code><code class="descname">str2addr</code><span class="sig-paren">(</span><em>norb</em>, <em>nelec</em>, <em>string</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/cistring.html#str2addr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.cistring.str2addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert string to CI determinant address</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.cistring.strs2addr">
<code class="descclassname">pyscf.fci.cistring.</code><code class="descname">strs2addr</code><span class="sig-paren">(</span><em>norb</em>, <em>nelec</em>, <em>strings</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/cistring.html#strs2addr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.cistring.strs2addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a list of string to CI determinant address</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.cistring.tn_strs">
<code class="descclassname">pyscf.fci.cistring.</code><code class="descname">tn_strs</code><span class="sig-paren">(</span><em>norb</em>, <em>nelec</em>, <em>n</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/cistring.html#tn_strs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.cistring.tn_strs" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate strings for Tn amplitudes.  Eg n=1 (T1) has nvir*nocc strings,
n=2 (T2) has nvir*(nvir-1)/2 * nocc*(nocc-1)/2 strings.</p>
</dd></dl>

</div>
<div class="section" id="module-pyscf.fci.spin_op">
<span id="spin-operator"></span><h2>9.3. spin operator<a class="headerlink" href="#module-pyscf.fci.spin_op" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pyscf.fci.spin_op.contract_ss">
<code class="descclassname">pyscf.fci.spin_op.</code><code class="descname">contract_ss</code><span class="sig-paren">(</span><em>fcivec</em>, <em>norb</em>, <em>nelec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/spin_op.html#contract_ss"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.spin_op.contract_ss" title="Permalink to this definition">¶</a></dt>
<dd><p>Contract spin square operator with FCI wavefunction <span class="math">\(S^2 |CI&gt;\)</span></p>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.spin_op.local_spin">
<code class="descclassname">pyscf.fci.spin_op.</code><code class="descname">local_spin</code><span class="sig-paren">(</span><em>fcivec</em>, <em>norb</em>, <em>nelec</em>, <em>mo_coeff=None</em>, <em>ovlp=1</em>, <em>aolst=[]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/spin_op.html#local_spin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.spin_op.local_spin" title="Permalink to this definition">¶</a></dt>
<dd><p>Local spin expectation value, which is defined as</p>
<p>&lt;CI|(local S^2)|CI&gt;</p>
<p>The local S^2 operator only couples the orbitals specified in aolst. The
cross term which involves the interaction between the local part (in aolst)
and non-local part (not in aolst) is not included. As a result, the value
of local_spin is not additive. In other words, if local_spin is computed
twice with the complementary aolst in the two runs, the summation does not
equal to the S^2 of the entire system.</p>
<p>For a complete list of AOs, the value of local_spin is equivalent to &lt;CI|S^2|CI&gt;</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.spin_op.spin_square">
<code class="descclassname">pyscf.fci.spin_op.</code><code class="descname">spin_square</code><span class="sig-paren">(</span><em>fcivec</em>, <em>norb</em>, <em>nelec</em>, <em>mo_coeff=None</em>, <em>ovlp=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/spin_op.html#spin_square"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.spin_op.spin_square" title="Permalink to this definition">¶</a></dt>
<dd><p>General spin square operator.</p>
<p>... math:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">CI</span><span class="o">|</span><span class="n">S_</span><span class="o">+*</span><span class="n">S_</span><span class="o">-|</span><span class="n">CI</span><span class="o">&gt;</span> <span class="o">&amp;=</span> <span class="n">n_</span>\<span class="n">alpha</span> <span class="o">+</span> \<span class="n">delta_</span><span class="p">{</span><span class="n">ik</span><span class="p">}</span>\<span class="n">delta_</span><span class="p">{</span><span class="n">jl</span><span class="p">}</span><span class="n">Gamma_</span><span class="p">{</span><span class="n">i</span>\<span class="n">alpha</span> <span class="n">k</span>\<span class="n">beta</span> <span class="p">,</span><span class="n">j</span>\<span class="n">beta</span> <span class="n">l</span>\<span class="n">alpha</span> <span class="p">}</span> \\
<span class="o">&lt;</span><span class="n">CI</span><span class="o">|</span><span class="n">S_</span><span class="o">-*</span><span class="n">S_</span><span class="o">+|</span><span class="n">CI</span><span class="o">&gt;</span> <span class="o">&amp;=</span> <span class="n">n_</span>\<span class="n">beta</span> <span class="o">+</span> \<span class="n">delta_</span><span class="p">{</span><span class="n">ik</span><span class="p">}</span>\<span class="n">delta_</span><span class="p">{</span><span class="n">jl</span><span class="p">}</span><span class="n">Gamma_</span><span class="p">{</span><span class="n">i</span>\<span class="n">beta</span> <span class="n">k</span>\<span class="n">alpha</span> <span class="p">,</span><span class="n">j</span>\<span class="n">alpha</span> <span class="n">l</span>\<span class="n">beta</span> <span class="p">}</span> \\
<span class="o">&lt;</span><span class="n">CI</span><span class="o">|</span><span class="n">S_z</span><span class="o">*</span><span class="n">S_z</span><span class="o">|</span><span class="n">CI</span><span class="o">&gt;</span> <span class="o">&amp;=</span> \<span class="n">delta_</span><span class="p">{</span><span class="n">ik</span><span class="p">}</span>\<span class="n">delta_</span><span class="p">{</span><span class="n">jl</span><span class="p">}(</span><span class="n">Gamma_</span><span class="p">{</span><span class="n">i</span>\<span class="n">alpha</span> <span class="n">k</span>\<span class="n">alpha</span> <span class="p">,</span><span class="n">j</span>\<span class="n">alpha</span> <span class="n">l</span>\<span class="n">alpha</span> <span class="p">}</span>
                 <span class="o">-</span> <span class="n">Gamma_</span><span class="p">{</span><span class="n">i</span>\<span class="n">alpha</span> <span class="n">k</span>\<span class="n">alpha</span> <span class="p">,</span><span class="n">j</span>\<span class="n">beta</span> <span class="n">l</span>\<span class="n">beta</span> <span class="p">}</span>
                 <span class="o">-</span> <span class="n">Gamma_</span><span class="p">{</span><span class="n">i</span>\<span class="n">beta</span> <span class="n">k</span>\<span class="n">beta</span> <span class="p">,</span><span class="n">j</span>\<span class="n">alpha</span> <span class="n">l</span>\<span class="n">alpha</span><span class="p">}</span>
                 <span class="o">+</span> <span class="n">Gamma_</span><span class="p">{</span><span class="n">i</span>\<span class="n">beta</span> <span class="n">k</span>\<span class="n">beta</span> <span class="p">,</span><span class="n">j</span>\<span class="n">beta</span> <span class="n">l</span>\<span class="n">beta</span><span class="p">})</span>
                 <span class="o">+</span> <span class="p">(</span><span class="n">n_</span>\<span class="n">alpha</span><span class="o">+</span><span class="n">n_</span>\<span class="n">beta</span><span class="p">)</span><span class="o">/</span><span class="mi">4</span>
</pre></div>
</div>
<p>Given the overlap betwen non-degenerate alpha and beta orbitals, this
function can compute the expectation value spin square operator for
UHF-FCI wavefunction</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.spin_op.spin_square0">
<code class="descclassname">pyscf.fci.spin_op.</code><code class="descname">spin_square0</code><span class="sig-paren">(</span><em>fcivec</em>, <em>norb</em>, <em>nelec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/spin_op.html#spin_square0"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.spin_op.spin_square0" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin square for RHF-FCI CI wfn only (obtained from spin-degenerated
Hamiltonian)</p>
</dd></dl>

</div>
<div class="section" id="module-pyscf.fci.rdm">
<span id="rdm"></span><h2>9.4. rdm<a class="headerlink" href="#module-pyscf.fci.rdm" title="Permalink to this headline">¶</a></h2>
<p>FCI 1, 2, 3, 4-particle density matrices.</p>
<p>Note the 1-particle density matrix has the same convention as the mean-field
1-particle density matrix (see McWeeney&#8217;s book Eq 5.4.20), which is</p>
<blockquote>
<div>dm[p,q] = &lt; q^+ p &gt;</div></blockquote>
<dl class="docutils">
<dt>The contraction between 1-particle Hamiltonian and 1-pdm is</dt>
<dd>E = einsum(&#8216;pq,qp&#8217;, h1, 1pdm)</dd>
<dt>Different conventions are used in the high order density matrices:</dt>
<dd>dm[p,q,r,s,...] = &lt; p^+ r^+ ... s q &gt;</dd>
</dl>
<dl class="function">
<dt id="pyscf.fci.rdm.make_dm123">
<code class="descclassname">pyscf.fci.rdm.</code><code class="descname">make_dm123</code><span class="sig-paren">(</span><em>fname</em>, <em>cibra</em>, <em>ciket</em>, <em>norb</em>, <em>nelec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/rdm.html#make_dm123"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.rdm.make_dm123" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin traced 1, 2 and 3-particle density matrices.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>In this function, 2pdm[p,q,r,s] is <span class="math">\(\langle p^\dagger q r^\dagger s\rangle\)</span>;
3pdm[p,q,r,s,t,u] is <span class="math">\(\langle p^\dagger q r^\dagger s t^\dagger u\rangle\)</span>.</p>
<p class="last">After calling reorder_dm123, the 2pdm and 3pdm are transformed to
the normal density matrices:
2pdm[p,r,q,s] = <span class="math">\(\langle p^\dagger q^\dagger s r\rangle\)</span>
3pdm[p,s,q,t,r,u] = <span class="math">\(\langle p^\dagger q^\dagger r^\dagger u t s\rangle\)</span>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.rdm.make_dm1234">
<code class="descclassname">pyscf.fci.rdm.</code><code class="descname">make_dm1234</code><span class="sig-paren">(</span><em>fname</em>, <em>cibra</em>, <em>ciket</em>, <em>norb</em>, <em>nelec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/rdm.html#make_dm1234"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.rdm.make_dm1234" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin traced 1, 2, 3 and 4-particle density matrices.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>In this function, 2pdm[p,q,r,s] is <span class="math">\(\langle p^\dagger q r^\dagger s\rangle\)</span>;
3pdm[p,q,r,s,t,u] is <span class="math">\(\langle p^\dagger q r^\dagger s t^\dagger u\rangle\)</span>;
4pdm[p,q,r,s,t,u,v,w] is <span class="math">\(\langle p^\dagger q r^\dagger s t^\dagger u v^\dagger w\rangle\)</span>.</p>
<p class="last">After calling reorder_dm123, the 2pdm and 3pdm are transformed to
the normal density matrices:
2pdm[p,r,q,s] = <span class="math">\(\langle p^\dagger q^\dagger s r\rangle\)</span>
3pdm[p,s,q,t,r,u] = <span class="math">\(\langle p^\dagger q^\dagger r^\dagger u t s\rangle\)</span>.
4pdm[p,t,q,u,r,v,s,w] = <span class="math">\(\langle p^\dagger q^\dagger r^\dagger s^dagger w v u t\rangle\)</span>.</p>
</div>
</dd></dl>

</div>
<div class="section" id="module-pyscf.fci.addons">
<span id="addons"></span><h2>9.5. addons<a class="headerlink" href="#module-pyscf.fci.addons" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pyscf.fci.addons.cre_a">
<code class="descclassname">pyscf.fci.addons.</code><code class="descname">cre_a</code><span class="sig-paren">(</span><em>ci0</em>, <em>norb</em>, <em>neleca_nelecb</em>, <em>ap_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/addons.html#cre_a"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.addons.cre_a" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct (N+1)-electron wavefunction by adding an alpha electron in
the N-electron wavefunction.</p>
<p>... math:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">|</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span>\<span class="n">rangle</span> <span class="o">=</span> \<span class="n">hat</span><span class="p">{</span><span class="n">a</span><span class="p">}</span><span class="o">^+</span><span class="n">_p</span> <span class="o">|</span><span class="n">N</span>\<span class="n">rangle</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>ci0</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D array</span><dd>CI coefficients, row for alpha strings and column for beta strings.</dd>
<dt>norb</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Number of orbitals.</dd>
<dt>(neleca,nelecb)</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">(int,int)</span><dd>Number of (alpha, beta) electrons of the input CI function</dd>
<dt>ap_id</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Orbital index (0-based), for the creation operator</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>2D array, row for alpha strings and column for beta strings. Note it
has different number of rows to the input CI coefficients.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.addons.cre_b">
<code class="descclassname">pyscf.fci.addons.</code><code class="descname">cre_b</code><span class="sig-paren">(</span><em>ci0</em>, <em>norb</em>, <em>neleca_nelecb</em>, <em>ap_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/addons.html#cre_b"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.addons.cre_b" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct (N+1)-electron wavefunction by adding a beta electron in
the N-electron wavefunction.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>ci0</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D array</span><dd>CI coefficients, row for alpha strings and column for beta strings.</dd>
<dt>norb</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Number of orbitals.</dd>
<dt>(neleca,nelecb)</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">(int,int)</span><dd>Number of (alpha, beta) electrons of the input CI function</dd>
<dt>ap_id</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Orbital index (0-based), for the creation operator</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>2D array, row for alpha strings and column for beta strings. Note it
has different number of columns to the input CI coefficients.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.addons.cylindrical_init_guess">
<code class="descclassname">pyscf.fci.addons.</code><code class="descname">cylindrical_init_guess</code><span class="sig-paren">(</span><em>mol</em>, <em>norb</em>, <em>nelec</em>, <em>orbsym</em>, <em>wfnsym=0</em>, <em>singlet=True</em>, <em>nroots=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/addons.html#cylindrical_init_guess"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.addons.cylindrical_init_guess" title="Permalink to this definition">¶</a></dt>
<dd><p>FCI initial guess for system of cylindrical symmetry.
(In testing)</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O; O 1 1.2&#39;</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">orbsym</span> <span class="o">=</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ci0</span> <span class="o">=</span> <span class="n">fci</span><span class="o">.</span><span class="n">addons</span><span class="o">.</span><span class="n">cylindrical_init_guess</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">orbsym</span><span class="p">,</span> <span class="n">wfnsym</span><span class="o">=</span><span class="mi">10</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ci0</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ci0</span> <span class="o">=</span> <span class="n">fci</span><span class="o">.</span><span class="n">addons</span><span class="o">.</span><span class="n">cylindrical_init_guess</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">orbsym</span><span class="p">,</span> <span class="n">wfnsym</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">singlet</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ci0</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.addons.des_a">
<code class="descclassname">pyscf.fci.addons.</code><code class="descname">des_a</code><span class="sig-paren">(</span><em>ci0</em>, <em>norb</em>, <em>neleca_nelecb</em>, <em>ap_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/addons.html#des_a"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.addons.des_a" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct (N-1)-electron wavefunction by removing an alpha electron from
the N-electron wavefunction.</p>
<p>... math:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">|</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span>\<span class="n">rangle</span> <span class="o">=</span> \<span class="n">hat</span><span class="p">{</span><span class="n">a</span><span class="p">}</span><span class="n">_p</span> <span class="o">|</span><span class="n">N</span>\<span class="n">rangle</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>ci0</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D array</span><dd>CI coefficients, row for alpha strings and column for beta strings.</dd>
<dt>norb</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Number of orbitals.</dd>
<dt>(neleca,nelecb)</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">(int,int)</span><dd>Number of (alpha, beta) electrons of the input CI function</dd>
<dt>ap_id</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Orbital index (0-based), for the annihilation operator</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>2D array, row for alpha strings and column for beta strings.  Note it
has different number of rows to the input CI coefficients</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.addons.des_b">
<code class="descclassname">pyscf.fci.addons.</code><code class="descname">des_b</code><span class="sig-paren">(</span><em>ci0</em>, <em>norb</em>, <em>neleca_nelecb</em>, <em>ap_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/addons.html#des_b"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.addons.des_b" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct (N-1)-electron wavefunction by removing a beta electron from
N-electron wavefunction.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>ci0</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D array</span><dd>CI coefficients, row for alpha strings and column for beta strings.</dd>
<dt>norb</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Number of orbitals.</dd>
<dt>(neleca,nelecb)</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">(int,int)</span><dd>Number of (alpha, beta) electrons of the input CI function</dd>
<dt>ap_id</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Orbital index (0-based), for the annihilation operator</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>2D array, row for alpha strings and column for beta strings. Note it
has different number of columns to the input CI coefficients.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.addons.det_overlap">
<code class="descclassname">pyscf.fci.addons.</code><code class="descname">det_overlap</code><span class="sig-paren">(</span><em>string1</em>, <em>string2</em>, <em>norb</em>, <em>s=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/addons.html#det_overlap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.addons.det_overlap" title="Permalink to this definition">¶</a></dt>
<dd><p>Determinants overlap on non-orthogonal one-particle basis</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.addons.energy">
<code class="descclassname">pyscf.fci.addons.</code><code class="descname">energy</code><span class="sig-paren">(</span><em>h1e</em>, <em>eri</em>, <em>fcivec</em>, <em>norb</em>, <em>nelec</em>, <em>link_index=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/addons.html#energy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.addons.energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the FCI electronic energy for given Hamiltonian and FCI vector.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.addons.fix_spin_">
<code class="descclassname">pyscf.fci.addons.</code><code class="descname">fix_spin_</code><span class="sig-paren">(</span><em>fciobj</em>, <em>shift=0.2</em>, <em>ss=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/addons.html#fix_spin_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.addons.fix_spin_" title="Permalink to this definition">¶</a></dt>
<dd><p>If FCI solver cannot stay on spin eigenfunction, this function can
add a shift to the states which have wrong spin.</p>
<div class="math">
\[(H + shift*S^2) |\Psi\rangle = E |\Psi\rangle\]</div>
<dl class="docutils">
<dt>Args:</dt>
<dd>fciobj : An instance of <code class="xref py py-class docutils literal"><span class="pre">FCISolver</span></code></dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>shift</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Level shift for states which have different spin</dd>
<dt>ss</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">number</span><dd>S^2 expection value == s*(s+1)</dd>
</dl>
</dd>
<dt>Returns</dt>
<dd>A modified FCI object based on fciobj.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.addons.guess_wfnsym">
<code class="descclassname">pyscf.fci.addons.</code><code class="descname">guess_wfnsym</code><span class="sig-paren">(</span><em>ci</em>, <em>norb</em>, <em>nelec</em>, <em>orbsym</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/addons.html#guess_wfnsym"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.addons.guess_wfnsym" title="Permalink to this definition">¶</a></dt>
<dd><p>Guess the wavefunction symmetry based on the non-zero elements in the
given CI coefficients.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>ci</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D array</span><dd>CI coefficients, row for alpha strings and column for beta strings.</dd>
<dt>norb</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Number of orbitals.</dd>
<dt>nelec</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int or 2-item list</span><dd>Number of electrons, or 2-item list for (alpha, beta) electrons</dd>
<dt>orbsym</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">list of int</span><dd>The irrep ID for each orbital.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>Irrep ID</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.addons.initguess_triplet">
<code class="descclassname">pyscf.fci.addons.</code><code class="descname">initguess_triplet</code><span class="sig-paren">(</span><em>norb</em>, <em>nelec</em>, <em>binstring</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/addons.html#initguess_triplet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.addons.initguess_triplet" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a triplet initial guess for FCI solver</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.addons.large_ci">
<code class="descclassname">pyscf.fci.addons.</code><code class="descname">large_ci</code><span class="sig-paren">(</span><em>ci</em>, <em>norb</em>, <em>nelec</em>, <em>tol=0.1</em>, <em>return_strs=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/addons.html#large_ci"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.addons.large_ci" title="Permalink to this definition">¶</a></dt>
<dd><p>Search for the largest CI coefficients</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.addons.overlap">
<code class="descclassname">pyscf.fci.addons.</code><code class="descname">overlap</code><span class="sig-paren">(</span><em>bra</em>, <em>ket</em>, <em>norb</em>, <em>nelec</em>, <em>s=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/addons.html#overlap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.addons.overlap" title="Permalink to this definition">¶</a></dt>
<dd><p>Overlap between two CI wavefunctions</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>s</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D array or a list of 2D array</span><dd>The overlap matrix of non-orthogonal one-particle basis</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.addons.reorder">
<code class="descclassname">pyscf.fci.addons.</code><code class="descname">reorder</code><span class="sig-paren">(</span><em>ci</em>, <em>nelec</em>, <em>orbidxa</em>, <em>orbidxb=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/addons.html#reorder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.addons.reorder" title="Permalink to this definition">¶</a></dt>
<dd><p>Reorder the CI coefficients, to adapt the reordered orbitals (The relation
of the reordered orbitals and original orbitals is  new = old[idx]).  Eg.</p>
<p>The orbital ordering indices <code class="docutils literal"><span class="pre">orbidx</span> <span class="pre">=</span> <span class="pre">[2,0,1]</span></code> indicates the map
old orbital  a b c  -&gt;   new orbital  c a b.  The strings are reordered as
old-strings   0b011, 0b101, 0b110 ==  (1,2), (1,3), (2,3)   &lt;= apply orbidx to get orb-strings
orb-strings   (3,1), (3,2), (1,2) ==  0B101, 0B110, 0B011   &lt;= by gen_strings4orblist
then argsort to translate the string representation to the address
[2(=0B011), 0(=0B101), 1(=0B110)]</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.addons.symm_initguess">
<code class="descclassname">pyscf.fci.addons.</code><code class="descname">symm_initguess</code><span class="sig-paren">(</span><em>norb</em>, <em>nelec</em>, <em>orbsym</em>, <em>wfnsym=0</em>, <em>irrep_nelec=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/addons.html#symm_initguess"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.addons.symm_initguess" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate CI wavefunction initial guess which has the given symmetry.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>norb</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Number of orbitals.</dd>
<dt>nelec</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int or 2-item list</span><dd>Number of electrons, or 2-item list for (alpha, beta) electrons</dd>
<dt>orbsym</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">list of int</span><dd>The irrep ID for each orbital.</dd>
</dl>
</dd>
<dt>Kwags:</dt>
<dd><dl class="first last docutils">
<dt>wfnsym</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>The irrep ID of target symmetry</dd>
<dt>irrep_nelec</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">dict</span><dd>Freeze occupancy for certain irreps</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>CI coefficients 2D array which has the target symmetry.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.addons.symmetrize_wfn">
<code class="descclassname">pyscf.fci.addons.</code><code class="descname">symmetrize_wfn</code><span class="sig-paren">(</span><em>ci</em>, <em>norb</em>, <em>nelec</em>, <em>orbsym</em>, <em>wfnsym=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/addons.html#symmetrize_wfn"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.addons.symmetrize_wfn" title="Permalink to this definition">¶</a></dt>
<dd><p>Symmetrize the CI wavefunction by zeroing out the determinants which
do not have the right symmetry.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>ci</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D array</span><dd>CI coefficients, row for alpha strings and column for beta strings.</dd>
<dt>norb</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Number of orbitals.</dd>
<dt>nelec</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int or 2-item list</span><dd>Number of electrons, or 2-item list for (alpha, beta) electrons</dd>
<dt>orbsym</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">list of int</span><dd>The irrep ID for each orbital.</dd>
</dl>
</dd>
<dt>Kwags:</dt>
<dd><dl class="first last docutils">
<dt>wfnsym</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>The irrep ID of target symmetry</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>2D array which is the symmetrized CI coefficients</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.fci.addons.transform_ci_for_orbital_rotation">
<code class="descclassname">pyscf.fci.addons.</code><code class="descname">transform_ci_for_orbital_rotation</code><span class="sig-paren">(</span><em>ci</em>, <em>norb</em>, <em>nelec</em>, <em>u</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/fci/addons.html#transform_ci_for_orbital_rotation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.addons.transform_ci_for_orbital_rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform CI coefficients to the representation in new one-particle basis.
Solving CI problem for Hamiltonian h1, h2 defined in old basis,
CI_old = fci.kernel(h1, h2, ...)
Given orbital rotation u, the CI problem can be either solved by
transforming the Hamiltonian, or transforming the coefficients.
CI_new = fci.kernel(u^T*h1*u, ...) = transform_ci_for_orbital_rotation(CI_old, u)</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>u</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D array or a list of 2D array</span><dd>the orbital rotation to transform the old one-particle basis to new
one-particle basis</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="symm.html" class="btn btn-neutral float-right" title="10. symm – Point group symmetry and spin symmetry" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="mcscf.html" class="btn btn-neutral" title="8. mcscf — Multi-configurational self-consistent field" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015-, Qiming Sun &lt;osirpt.sun@gmail.com&gt;.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.5.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: ''
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>